<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第七章 STL | takisano</title><meta name="author" content="takisano"><meta name="copyright" content="takisano"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第七章 STLSTL主要由六个部分组成：空间配置器（Allocator）、适配器（Adapters）、容器（Containers）、迭代器（Iterator）、仿函数（Functors）和算法（Algorithm）。  容器  a. 容器是存储其他对象的对象，它存储的对象可以是自定义数据类型的对象，也可以是内置数据类型的对象。这些被存储的对象必须是同一种数据类型，它们归容器所有，称为容器的元素。当">
<meta property="og:type" content="article">
<meta property="og:title" content="第七章 STL">
<meta property="og:url" content="http://example.com/2022/12/18/c7/index.html">
<meta property="og:site_name" content="takisano">
<meta property="og:description" content="第七章 STLSTL主要由六个部分组成：空间配置器（Allocator）、适配器（Adapters）、容器（Containers）、迭代器（Iterator）、仿函数（Functors）和算法（Algorithm）。  容器  a. 容器是存储其他对象的对象，它存储的对象可以是自定义数据类型的对象，也可以是内置数据类型的对象。这些被存储的对象必须是同一种数据类型，它们归容器所有，称为容器的元素。当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2022-12-17T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-20T08:37:41.665Z">
<meta property="article:author" content="takisano">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/18/c7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第七章 STL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-20 16:37:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="takisano" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="takisano"><span class="site-name">takisano</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第七章 STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-17T16:00:00.000Z" title="发表于 2022-12-18 00:00:00">2022-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-20T08:37:41.665Z" title="更新于 2023-11-20 16:37:41">2023-11-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第七章 STL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第七章-STL"><a href="#第七章-STL" class="headerlink" title="第七章 STL"></a>第七章 STL</h1><p>STL主要由六个部分组成：空间配置器（Allocator）、适配器（Adapters）、容器（Containers）、迭代器（Iterator）、仿函数（Functors）和算法（Algorithm）。</p>
<ol>
<li>容器<br>  a. 容器是存储其他对象的对象，它存储的对象可以是自定义数据类型的对象，也可以是内置数据类型的对象。这些被存储的对象必须是同一种数据类型，它们归容器所有，称为容器的元素。当容器失效时，容器中的元素也会失效。容器本身包含了处理这些数据的方法。STL中的容器共有13种，<br>  b. 序列容器<br> ⅰ. vector<br> ⅱ. list<br> ⅲ. deque<br> ⅳ. array(C++11)<br> ⅴ. forward_list(C++11)<br>  c. 关联容器<br> ⅰ. set<br> ⅱ. multiset<br> ⅲ. map<br> ⅳ. multiset<br>  d. 无序容器<br> ⅰ. unordered_set(C++11)<br> ⅱ. unordered_multiset(C++11)<br> ⅲ. multiset_map(C++11)<br> ⅳ. unordered_multimap(C++11)</li>
<li>空间配置器<br>  a. C++标准库采用了空间配置器实现对象内存空间的分配和归还，空间配置器是特殊的内存模型。例如，使用vector容器，存储数据的空间由空间配置器完成内存的分配和资源回收。空间配置器本质上是对new和delete运算符再次封装而成的类模板，对外提供可用的接口，实现内存资源的自动化管理。</li>
<li>适配器<br>  a. 适配器主要指容器适配器。容器适配器也是一类容器，它除了能存储普通数据，还可以存储list、vector、deque等容器。容器适配器采用特定的数据管理策略，能够使容器在操作数据时表现出另一种行为。例如，使用容器适配器stack封装一个<code>vector&lt;int&gt;</code>容器，使<code>vector&lt;int&gt;</code>容器在处理数据时，表现出栈这种数据结构的特点（先进后出）。STL提供了三个容器适配器：stack（栈）、queue（队列）和priority_queue（优先队列）。适配器体现了STL设计的通用性，极大提高了编程效率。</li>
<li>迭代器<br>  a. 迭代器是STL提供的用于操作容器中元素的类模板，STL算法利用迭代器遍历容器中的元素，迭代器本身也提供了操作容器元素的方法，使容器元素访问更便捷。迭代器将容器与算法联系起来，起到了“黏合剂”的作用，STL提供的算法几乎都通过迭代器实现元素访问。STL提供了输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器五种类型的迭代器，使用迭代器访问容器元素更简单、易用，且代码更加紧凑、简洁。</li>
<li>仿函数<br>  a. 在前面3.4节我们学习了仿函数，仿函数通过重载(）运算符实现，使类具有函数一样的行为。仿函数也称为函数对象，是STL很重要的组成部分，它使STL的应用更加灵活方便，增强了算法的通用性。大多数STL算法可以使用一个仿函数作为参数，以达到某种数据操作的目的。例如，在排序算法中，可以使用仿函数less或greater作为参数，以实现数据从大到小或从小到大的排序。</li>
<li>算法<br>  a. 算法是STL定义的一系列函数模板，是STL非常重要的一部分内容。算法可以对容器中的元素施加特定操作。STL算法不依赖于容器的实现细节，只要容器的迭代器符合算法要求，算法就可以通过迭代器处理容器中的元素。</li>
</ol>
<h2 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h2><p>序列容器（Sequence Containers）也叫作顺序容器，序列容器各元素之间有顺序关系，每个元素都有固定位置，除非使用插入或删除操作改变这个元素的位置。序列容器是一种线性结构的有序群集，它最重要的特点就是可以在容器一端添加、删除元素。对于双向序列容器，允许在两端添加和删除元素。序列容器有连续存储和链式存储两种存储方式，如图7-2所示。STL提供的基本序列容器包括vector、deque、list、array和forward_list五种，在使用这五种容器时分别需要包含相应的头文件，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector容器与动态数组相同，在插入或删除元素时能够自动调整自身大小，即vector容器能够自动处理存储数据所需的空间。vector容器中的元素放置在连续的内存空间中，可以使用迭代器对其进行访问和遍历。</p>
<p>vector容器在插入元素时，插入位置之后的元素都要被顺序地向后移动，因此，在总体上vector容器插入操作效率并不高。插入位置越靠前，执行插入所需的时间就越多，但在vector容器尾部插入元素的效率比较高。删除vector容器中的元素时，被删除元素后面的元素会顺序向前移动，将被删除元素留下的空位补上。删除操作的效率和插入类似，被删除元素越靠前，删除操作所需的时间就越多。</p>
<ol>
<li>指定容器大小<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;元素类型&gt; 对象名 (容器大小);</span><br></pre></td></tr></table></figure></li>
<li>指定容器初始值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;元素类型&gt; 对象名 (容器大小, 元素初始值);</span><br></pre></td></tr></table></figure></li>
<li>初始化列表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;v1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">vector&lt;string&gt; v2 = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
使用列表初始化时，带“&#x3D;”符号与不带“&#x3D;”符号均可。</li>
<li>初始化状态为空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//创建储存类型int类型的容器v1</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;     <span class="comment">//用容器v1初始化容器v2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = v2;    <span class="comment">//用容器v2初始化容器v3</span></span><br></pre></td></tr></table></figure>
需要注意的是，用一个vector容器初始化另一个容器或相互赋值时，两个vector容器的元素类型必须相同。</li>
</ol>
<h4 id="获取容器和实际元素个数"><a href="#获取容器和实际元素个数" class="headerlink" title="获取容器和实际元素个数"></a>获取容器和实际元素个数</h4><p>vector容器的容量与容器实际元素个数并不一定相同，容器容量指容器最多可以存储的元素个数，是容器预分配的内存空间。而容器实际元素个数可能小于容器容量。vector提供了两个函数capacity()和size()，分别用于获取容器容量和容器实际元素个数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">capacity</span>();<span class="comment">//返回容器的容量</span></span><br><span class="line">v.<span class="built_in">size</span>();<span class="comment">//返回容器实际元素个数</span></span><br></pre></td></tr></table></figure>
<h4 id="访问容器中的元素"><a href="#访问容器中的元素" class="headerlink" title="访问容器中的元素"></a>访问容器中的元素</h4><p>由于vector重载了“[]”运算符，因此可以使用索引方式访问vector容器中的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">at</span>(<span class="type">int</span> index);</span><br></pre></td></tr></table></figure>
<h4 id="赋值函数"><a href="#赋值函数" class="headerlink" title="赋值函数"></a>赋值函数</h4><p>vector容器中的元素可以在创建容器时指定，也可以通过“[]”运算符完成赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(n,elem); <span class="comment">//将n个elem元素赋值给容器</span></span><br><span class="line">v.<span class="built_in">assign</span>(begin,end);<span class="comment">//将[begin,end)区间中的元素赋值给容器</span></span><br></pre></td></tr></table></figure>
<h4 id="获取头部和尾部元素"><a href="#获取头部和尾部元素" class="headerlink" title="获取头部和尾部元素"></a>获取头部和尾部元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">front</span>(); <span class="comment">//获取容器第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>(); <span class="comment">//获取容器最后一个元素</span></span><br></pre></td></tr></table></figure>
<h4 id="从尾部插入和删除元素"><a href="#从尾部插入和删除元素" class="headerlink" title="从尾部插入和删除元素"></a>从尾部插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(type elem&amp;t);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//创建一个空的vector容器v</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">//从尾部向容器v中插入10个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot;  &quot;</span>; <span class="comment">//输出容器v中的元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();               <span class="comment">//删除尾部元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">//此时元素个数为9</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;   <span class="comment">//输出容器v中的元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器的迭代器"><a href="#容器的迭代器" class="headerlink" title="容器的迭代器"></a>容器的迭代器</h4><p>vector容器提供了迭代器，通过迭代器可以访问、修改容器中的元素。vector容器提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，这四种迭代器作用分别如下。<br>iterator：正向遍历容器元素。<br>reverse_iterator：反向遍历容器元素。<br>const_iterator：正向遍历容器元素，但通过const_iterator只能访问容器元素，不能修改元素的值。<br>const_reverse_iterator：反向遍历容器元素，但通过const_reverse_iterator只能访问容器元素，不能修改元素的值。在使用迭代器之前，必须先定义迭代器对象，vector容器迭代器<br>vector&lt;元素类型&gt; 迭代器 迭代器对象名称;</p>
<p>需要注意的是，迭代器遍历容器到达尾部时，指向最后一个元素的后面，而不是指向最后一个元素，即使用end()函数、rend()函数、cend()函数和crend()函数获取的迭代器，指向最后一个元素后面的位置，而不是指向最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;           <span class="comment">//创建vector容器c</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos;           <span class="comment">//定义iterator迭代器pos</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator pos_r; <span class="comment">//定义reverse_iterator迭代器pos_r</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iterator迭代器:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (pos = c.<span class="built_in">begin</span>(); pos != c.<span class="built_in">end</span>(); ++pos) <span class="comment">//使用迭代器pos遍历容器c中的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;reverse_iterator迭代器:&quot;</span>;</span><br><span class="line">    <span class="comment">//使用迭代器pos_r反向遍历容器c中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (pos_r = c.<span class="built_in">rbegin</span>(); pos_r != c.<span class="built_in">rend</span>(); ++pos_r)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos_r &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小提示：迭代器失效<br>vector容器是一个顺序容器，在内存中是一块连续的内存，当插入或删除一个元素后，内存中的数据会移动，从而保证数据的连续。当插入或删除数据后，其他数据的地址可能会发生变化，迭代器获取容器位置信息的数据不正确，即迭代器失效，会导致访问出错。</p>
<h4 id="在任意位置插入和删除元素"><a href="#在任意位置插入和删除元素" class="headerlink" title="在任意位置插入和删除元素"></a>在任意位置插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos, elem);       <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos, n, elem);    <span class="comment">//在pos位置插入n个elem元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin, end)区间的数据</span></span><br><span class="line">v.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的数据</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v;                  <span class="comment">//创建空的vector容器v</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;a&#x27;</span>);        <span class="comment">//在头部位置插入元素a</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;b&#x27;</span>);        <span class="comment">//在头部位置插入元素b</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;c&#x27;</span>);        <span class="comment">//在头部位置插入元素c</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">5</span>, <span class="string">&#x27;t&#x27;</span>); <span class="comment">//在v.begin()+1位置插入5个元素t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)      <span class="comment">//输出容器v中的元素</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after erase elems:\n&quot;</span>;</span><br><span class="line">    <span class="comment">//删除begin()+1到begin()+6区间的5个元素</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">begin</span>() + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">//输出容器v中的元素</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多学一招：deque容器"><a href="#多学一招：deque容器" class="headerlink" title="多学一招：deque容器"></a>多学一招：deque容器</h4><p>deque容器与vector容器非常相似，采用动态内存管理的方式存储元素。与vector不同的是，deque是两端开口的，支持从两端插入、删除数据，并支持元素的随机访问。</p>
<p>deque的操作方法和vector容器几乎相同。最大的区别是deque容器不支持vector容器中的reserve()函数、capacity()函数和data()函数，并且新增了pop_front()、push_front()函数，用于从队首弹出、插入元素。</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是C++11标准新增加的容器，它也是一个序列容器，只是array的大小是固定的，一旦分配了array容器，其大小就不能再改变，不允许向array容器插入元素或从array容器中删除元素，即array容器不支持插入、删除操作。array容器的存储结构如图7-8所示。</p>
<h4 id="创建array容器"><a href="#创建array容器" class="headerlink" title="创建array容器"></a>创建array容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; a1;             <span class="comment">//定义大小为3的array容器a1</span></span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; a2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//定义array容器a2</span></span><br></pre></td></tr></table></figure>

<h4 id="修改容器元素"><a href="#修改容器元素" class="headerlink" title="修改容器元素"></a>修改容器元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(val);         <span class="comment">//使用val填充容器 </span></span><br><span class="line">a1.<span class="built_in">swap</span>(a2);         <span class="comment">//交换容器a1和容器a2的元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">//创建array容器c</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; c1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                <span class="comment">//创建array容器c1</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt;::iterator pos;                 <span class="comment">//定义iterator迭代器pos</span></span><br><span class="line">    c.<span class="built_in">swap</span>(c1);                                  <span class="comment">//交换容器c和容器c1的元素</span></span><br><span class="line">    <span class="keyword">for</span> (pos = c.<span class="built_in">begin</span>(); pos != c.<span class="built_in">end</span>(); ++pos) <span class="comment">//使用迭代器pos遍历容器c中的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list容器以双向链表形式实现，list容器通过指针将前面的元素和后边的元素链接到一起。list容器的存储结构如图7-10所示。<br>与vector容器和deque容器相比，list容器只能通过迭代器访问元素，不能通过索引方式访问元素。因为同为序列容器，list容器的接口大部分与vector和deque容器都相同，所以读者学习起来也比较容易。下面讲解list容器的常见用法</p>
<h4 id="创建list容器"><a href="#创建list容器" class="headerlink" title="创建list容器"></a>创建list容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lt;             <span class="comment">//创建一个空的list容器lt</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(n)</span></span>;          <span class="comment">//创建一个list容器lt，大小为n</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(n, elem)</span></span>;    <span class="comment">//创建一个list容器lt，包含n个elem元素</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(begin, end)</span></span>; <span class="comment">//创建一个list容器lt，用[begin, end)区间的值为元素赋值</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(lt1)</span></span>;        <span class="comment">//创建一个list容器lt，用容器lt1初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lt.<span class="built_in">assign</span>(n, elem);    <span class="comment">//将n个elem元素的值赋给lt</span></span><br><span class="line">lt.<span class="built_in">assign</span>(begin, end); <span class="comment">//用[begin, end)区间的值给lt中的元素赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><p>因为list容器是由链表实现的，内存区域并不连续，所以无法用“[]”运算符访问元素，也没有可随机访问元素的at()方法，但list容器提供了front()函数和back()函数用于获取头部元素和尾部元素。此外，list容器也支持迭代器访问元素，提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，还提供了获取这四种迭代器的成员函数。list迭代器的用法与vector迭代器相同，这里不再举例演示。</p>
<h3 id="插入元素和删除元素"><a href="#插入元素和删除元素" class="headerlink" title="插入元素和删除元素"></a>插入元素和删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lt.<span class="built_in">push_back</span>();             <span class="comment">//在尾部插入元素</span></span><br><span class="line">lt.<span class="built_in">push_front</span>();            <span class="comment">//在头部插入元素</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, elem);       <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, n, elem);    <span class="comment">//在pos位置插入n个元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin, end)区间的值作为元素</span></span><br><span class="line">lt.<span class="built_in">pop_back</span>();        <span class="comment">//从尾部删除元素</span></span><br><span class="line">lt.<span class="built_in">pop_front</span>();       <span class="comment">//从头部删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(pos);        <span class="comment">//从中间删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的元素</span></span><br><span class="line">lt.<span class="built_in">remove</span>(elem);      <span class="comment">//从容器中删除所有与elem匹配的元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(list&lt;T&gt; mylist)</span> <span class="comment">//定义函数模板，输出list容器元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> list&lt;T&gt;::iterator it; <span class="comment">//创建list的iterator迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lt; <span class="comment">//创建空的list容器lt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        lt.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    lt.<span class="built_in">pop_back</span>();    <span class="comment">//删除最后一个元素</span></span><br><span class="line">    lt.<span class="built_in">push_front</span>(<span class="number">5</span>); <span class="comment">//在头部添加元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;再次输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    lt.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除5之后，输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>C++11标准新增了forward_list容器，该容器由单链表实现。在forward_list容器中，除了最后一个元素，每个元素与下一个元素通过指针链接。由于forward_list容器是单链表实现的，因此它只能向后迭代。</p>
<p>由于同为链式存储的容器，因此forward_list的接口与list大部分相同。但是又因为forward_list是单链式存储，所以forward_list还提供了一些自己特有的函数，</p>
<h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><p>forward_list容器不支持insert()函数和erase()函数，但它提供了insert_after()函数和erase_after()函数用于插入和删除元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert_after</span>(pos, val);        <span class="comment">//将元素val插入pos位置</span></span><br><span class="line"><span class="built_in">insert_after</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin,end）区间内的元素</span></span><br><span class="line"><span class="built_in">erase_after</span>(pos);              <span class="comment">//删除pos位置的元素</span></span><br><span class="line"><span class="built_in">erase_after</span>(begin, end);       <span class="comment">//删除[begin,end）区间内的元素</span></span><br></pre></td></tr></table></figure>
<h4 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h4><p>forward_list新增了两个函数before_begin()和cbefore_begin()，其中，before_begin()函数用于获取指向容器第一个元素之前位置的迭代器；cbefore_begin()用于获取指向容器第一个元素之前位置的const_iterator迭代器。</p>
<h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>序列容器中元素的顺序都是由程序设计者决定的，程序设计者可以随意指定新元素的插入位置，而关联容器的所有元素都是经过排序的，即关联容器都是有序的。它的每一个元素都有一个键（key），容器中的元素是按照键的取值升序排列的。<br>关联容器内部实现为一个二叉树，在二叉树中，每个元素都有一个父节点和两个子节点，左子树的所有元素都比父节点小，右子树的所有元素都比父节点大。关联容器的有序二叉树如图7-13所示。关联容器内部结构都以这种二叉树结构实现，这也使得它可以高效地查找容器中的每一个元素，但却不能实现任意位置的操作。</p>
<p>STL提供了四种关联容器，分别是set、multiset、m ap和multim ap，其中set与multiset包含在头文件set中，m ap与multim ap包含在头文件m ap中。</p>
<h3 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h3><p>set与multiset都是集合，用于存储一组相同数据类型的元素。两者的区别是set用来存储一组无重复的元素，而multiset允许存储有重复的元素。集合支持插入、删除、查找等操作，但集合中的元素值不可以直接修改，因为这些元素都是自动排序的，如果想修改其中某一个元素的值，必须先删除原有的元素，再插入新的元素。</p>
<h4 id="创建set与multiset容器"><a href="#创建set与multiset容器" class="headerlink" title="创建set与multiset容器"></a>创建set与multiset容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; s;                 <span class="comment">//创建一个空的set容器，默认升序排列</span></span><br><span class="line">set&lt;T, op&gt; s;             <span class="comment">//创建一个空的set容器，按op规则排序</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(begin, end)</span></span>;     <span class="comment">//创建一个容器，用[begin,end)区间为其初始化</span></span><br><span class="line"><span class="function">set&lt;T, op&gt; <span class="title">s</span><span class="params">(begin, end)</span></span>; <span class="comment">//创建一个容器，用[begin,end)区间为其初始化，并按op规则排序</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(s1)</span></span>;             <span class="comment">//创建一个空的set容器，用另一个容器s1初始化</span></span><br><span class="line">set&lt;<span class="type">char</span>&gt; s1;</span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;()&gt; s2;</span><br><span class="line"><span class="function">set&lt;<span class="type">float</span>&gt; <span class="title">s3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">set&lt;string, greater&lt;string&gt;()&gt; <span class="built_in">s4</span>(begin, end);</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s5</span><span class="params">(s2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述代码分别用不同的方式定义了char、int等类型的set容器，其中容器s2与s4中的<code>greater&lt;T&gt;</code>是排序规则，指定容器中的元素按照从大到小的顺序排列。如果没有指定排序规则，则默认规则是<code>less&lt;T&gt;</code>，即容器中元素按照从小到大的顺序排列。<code>greater&lt;T&gt;</code>、<code>less&lt;T&gt;</code>是STL中定义的函数对象，包含在functional头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">char</span>&gt; ms1;</span><br><span class="line">multiset&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;()&gt; ms2;</span><br><span class="line"><span class="function">multiset&lt;<span class="type">float</span>&gt; <span class="title">ms3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">multiset&lt;string, greater&lt;string&gt;()&gt; <span class="built_in">ms4</span>(begin, end);</span><br><span class="line"><span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">ms5</span><span class="params">(s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="容器的大小"><a href="#容器的大小" class="headerlink" title="容器的大小"></a>容器的大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>();     <span class="comment">//返回容器中实际元素个数</span></span><br><span class="line">s.<span class="built_in">empty</span>();    <span class="comment">//判断容器是否为空</span></span><br><span class="line">s.<span class="built_in">max_size</span>(); <span class="comment">//返回容器容量</span></span><br></pre></td></tr></table></figure>
<p>上述函数调用中的s指集合容器，如无特殊说明，s既可以是set容器也可以是multiset容器，即两个容器都提供了这样的函数。<br>容器元素的查找和统计</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(elem);</span><br><span class="line">s.<span class="built_in">count</span>(elem);</span><br></pre></td></tr></table></figure>
<p>对于set容器，count()函数的返回值只能是0或1；对于multiset容器，count()函数返回值可能大于1。<br>容器的迭代器<br>set与multiset容器支持迭代器操作，提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，并且提供了获取这四种迭代器的成员函数。set与multiset的迭代用法与vector迭代器相同。</p>
<h4 id="插入和删除元素-1"><a href="#插入和删除元素-1" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><p>set与multiset容器提供了insert()函数与erase()函数，用于向容器中插入和删除元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(elem);       <span class="comment">//在容器中插入元素elem</span></span><br><span class="line">s.<span class="built_in">insert</span>(pos, elem);  <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">s.<span class="built_in">insert</span>(begin, end); <span class="comment">//在容器中插入[begin,end)区间的元素</span></span><br></pre></td></tr></table></figure>
<p>第一种形式的insert()函数将元素elem插入容器中。对于set容器，第一种形式的insert()函数调用的返回值是一个pair&lt;iterator,bool&gt;对象。pair&lt;iterator,bool&gt;对象的第一个参数iterator是迭代器，指示元素插入的位置；第二个参数bool类型的值代表元素是否插入成功。这是因为set容器中不允许存在重复的元素，如果要插入一个容器中已存在的元素，则插入操作会失败，而pair中的bool值标志插入是否成功。multiset容器则不存在这样的情况，因此multiset容器返回的是一个iterator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(elem);       <span class="comment">//删除元素elem</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s; <span class="comment">//创建set容器s，元素按降序排列</span></span><br><span class="line">    multiset&lt;<span class="type">char</span>&gt; ms;        <span class="comment">//创建multiset容器ms</span></span><br><span class="line">                              <span class="comment">//向s中插入元素</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ps;</span><br><span class="line">    ps = s.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps.second == <span class="literal">true</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;insert success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">39</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">//向ms中插入元素</span></span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    <span class="comment">//输出两个容器中的元素</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator its; <span class="comment">//创建容器s的迭代器，用于获取元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s容器中元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (its = s.<span class="built_in">begin</span>(); its != s.<span class="built_in">end</span>(); its++)</span><br><span class="line">        cout &lt;&lt; *its &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    multiset&lt;<span class="type">char</span>&gt;::iterator itms; <span class="comment">//创建容器ms的迭代器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ms容器中元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (itms = ms.<span class="built_in">begin</span>(); itms != ms.<span class="built_in">end</span>(); itms++)</span><br><span class="line">        cout &lt;&lt; *itms &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//查找容器ms中元素u的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ms容器中u元素个数：&quot;</span> &lt;&lt; ms.<span class="built_in">count</span>(<span class="string">&#x27;u&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多学一招：pair类模板"><a href="#多学一招：pair类模板" class="headerlink" title="多学一招：pair类模板"></a>多学一招：pair类模板</h4><p>在头文件utility中，定义了一个类模板pair。pair类模板的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1 &amp;a, <span class="type">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">    <span class="comment">// 允许使用兼容的pair进行复制构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt; &amp;p) : <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pair的主要作用是将两个数据进行组合，用来表示一个二元组或一个元素对，两个数据可以是同一个类型，也可以是不同的类型。当需要将两个元素组合在一起时，可以选择构造pair对象。当一个函数需要返回两个数据时，可以返回一个pair对象。例如，set容器的insert()函数第一种重载形式，就返回一个pair对象。下面讲解一下pair对象的创建与使用。</p>
<h4 id="创建pair对象"><a href="#创建pair对象" class="headerlink" title="创建pair对象"></a>创建pair对象</h4><p>创建pair对象可以调用pair的构造函数，还可以调用STL提供的make_pair()函数。make_pair()是一个函数模板，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function">pair&lt;V1, V2&gt; <span class="title">make_pair</span><span class="params">(T1 &amp;&amp;t, T2 &amp;&amp;u)</span></span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="pair对象的使用"><a href="#pair对象的使用" class="headerlink" title="pair对象的使用"></a>pair对象的使用</h4><p>pair类模板提供了两个成员变量first与second，first表示pair对象中的第一个元素，second表示第二个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>上述代码创建了一个pair对象p1，p1.first获取的是第一个元素，即int类型的1；p1.second获取的是第二个元素，即string类型的”abc”。</p>
<h3 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h3><p>m ap与multim ap称为映射，映射与集合的主要区别在于，集合的元素是键本身，而映射的元素是由键和附加数据构成的二元组，它很像“字典”，通过给定的键，可以快速找出与键对应的值。因此，映射的二叉树节点中存储了两个数据，一个是用来定位的数据，称为键；另一个是与键对应的数据，称为值。通常也说，映射中存储的是一键值对，映射的一种通常用法就是根据键查找对应的值。映射可分为单重映射（m ap）与多重映射（multim ap），两者的主要区别是：m ap存储的是无重复键的元素对，而multim ap允许相同的键重复出现，即一个键可以对应多个值，如图7-14所示。</p>
<h4 id="创建map与multimap容器"><a href="#创建map与multimap容器" class="headerlink" title="创建map与multimap容器"></a>创建map与multimap容器</h4><p>map与multimap重载了多个构造函数，因此m ap和multim ap容器的创建方式有多种。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; m;                 <span class="comment">//创建一个空的map容器</span></span><br><span class="line">map&lt;T1, T2, op&gt; m;             <span class="comment">//创建一个空的map容器，以op为准则排序</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(begin, end)</span></span>;     <span class="comment">//创建一个map容器，用[begin, end)区间赋值</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(begin, end, op)</span></span>; <span class="comment">//创建一个map容器，用[begin, end)区间赋值，op为排序准则</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(m1)</span></span>;             <span class="comment">//创建一个map容器，用另一个map容器m1初始化</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">float</span>, greater&lt;<span class="type">int</span>&gt;()&gt; m2;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">m3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">map&lt;string, <span class="type">int</span>, greater&lt;string&gt;()&gt; <span class="built_in">m4</span>(begin, end);</span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m5</span><span class="params">(m1)</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码分别调用不同的构造函数创建了五个m ap容器。需要注意的是，创建m ap容器时，类型参数必须有两个，这两个类型参数可以相同，也可以不同。multim ap容器的创建方式与m ap容器相同，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mt1;</span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">float</span>, greater&lt;<span class="type">int</span>&gt;()&gt; mt2;</span><br><span class="line"><span class="function">multimap&lt;string, <span class="type">int</span>&gt; <span class="title">mt3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">multimap&lt;string, <span class="type">int</span>, greater&lt;string&gt;()&gt; <span class="built_in">mt4</span>(begin, end);</span><br><span class="line"><span class="function">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mt5</span><span class="params">(m1)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="容器大小"><a href="#容器大小" class="headerlink" title="容器大小"></a>容器大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">cout</span>(key);</span><br><span class="line">m.<span class="built_in">max_size</span>();</span><br><span class="line">m.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>由于m ap容器中无重复元素，因此m ap容器的count()函数返回值只有0和1，而multim ap容器的count()函数返回值可能大于1。<br>容器元素的访问<br>map容器重载了“[]”运算符，可以通过m[key]的方式获取key对应的值。此外，m ap容器也提供了at()函数用于访问指定键对应的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[key];</span><br><span class="line">m.<span class="built_in">at</span>(key);</span><br></pre></td></tr></table></figure>
<p>m ap容器可以通过上述两种方式随机访问容器中元素，但multim ap容器中允许存在重复的键值，因此无法使用上述两种方式随机访问容器中元素。通过“[]”运算符和at()函数可以访问m ap容器中的元素，那么同样通过“[]”运算符和at()函数可以修改容器中的元素，示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[key] = value;</span><br><span class="line">m.<span class="built_in">at</span>(key) = value;</span><br></pre></td></tr></table></figure>
<p>如果key尚未存在，则插入元素对；如果key已存在，则新插入的value覆盖key原来的值。<br>容器的迭代器<br>如果key尚未存在，则插入元素对；如果key已存在，则新插入的value覆盖key原来的值。</p>
<h4 id="插入和删除元素-2"><a href="#插入和删除元素-2" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(elem);       <span class="comment">//在容器中插入元素elem</span></span><br><span class="line">m.<span class="built_in">insert</span>(pos, elem);  <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">m.<span class="built_in">insert</span>(begin, end); <span class="comment">//在容器中插入[begin, end)区间的值</span></span><br><span class="line">m.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间内的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(key);        <span class="comment">//删除键为key的元素对</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义printm()函数输出map容器元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printm</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt; p;           <span class="comment">//创建pair对象p</span></span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">double</span>&gt;::iterator it; <span class="comment">//定义map的iterator迭代器it</span></span><br><span class="line">    <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt;)*it;                 <span class="comment">//将迭代器指向的一对元素存放到p中</span></span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.second &lt;&lt; endl; <span class="comment">//输出一对元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义printmt()函数输出multimap容器元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printmt</span><span class="params">(multimap&lt;<span class="type">int</span>, string&gt; mymul)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">    multimap&lt;<span class="type">int</span>, string&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mymul.<span class="built_in">begin</span>(); it != mymul.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (pair&lt;<span class="type">int</span>, string&gt;)*it;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; m; <span class="comment">//创建一个map容器m</span></span><br><span class="line">    <span class="comment">//向容器m中插入元素</span></span><br><span class="line">    m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1.2</span>;</span><br><span class="line">    m[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3.6</span>;</span><br><span class="line">    m[<span class="string">&#x27;c&#x27;</span>] = <span class="number">6.4</span>;</span><br><span class="line">    m[<span class="string">&#x27;d&#x27;</span>] = <span class="number">0.8</span>;</span><br><span class="line">    m[<span class="string">&#x27;e&#x27;</span>] = <span class="number">5.3</span>;</span><br><span class="line">    m[<span class="string">&#x27;f&#x27;</span>] = <span class="number">3.6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printm</span>(m); <span class="comment">//调用printm()函数输出容器m中的元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map中key=a的值：&quot;</span> &lt;&lt; m.<span class="built_in">at</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map中key=f的元素个数：&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&#x27;f&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    multimap&lt;<span class="type">int</span>, string&gt; mt; <span class="comment">//创建一个multimap容器mt</span></span><br><span class="line">    <span class="comment">//向容器mt中插入元素</span></span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;China&quot;</span>));</span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;!&quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printmt</span>(mt); <span class="comment">//调用printmt()函数输出容器mt中的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>C++标准库中提供了三个容器适配器：stack（栈）、queue（队列）和priority queue（优先队列）。这三种容器适配器提供了简单易用的接口，满足了编程中的特殊数据处理需求，本节将针对这三种容器适配器进行讲解。</p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack中的元素具有后进先出的特点。stack只能从一端插入、删除、读取元素，不允许一次插入或删除多个元素，且不支持迭代器操作。</p>
<h4 id="创建stack"><a href="#创建stack" class="headerlink" title="创建stack"></a>创建stack</h4><ol>
<li>创建空的stack<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br></pre></td></tr></table></figure></li>
<li>创建存储序列容器的stack<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建vector容器v</span></span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(v); <span class="comment">//创建stack容器适配器s，存储容器v</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h4><p>stack除了具有vector容器相同功能的成员函数，如empty()、size()、emplace()和swap()函数，还提供以下操作函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">//包含头文件stack</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建vector容器v</span></span><br><span class="line">    stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(v); <span class="comment">//创建stack容器适配器s</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue中的元素具有先进先出的特点，元素只能从一端使用push()函数进行插入，从另一端使用pop()函数进行删除。<br>queue也不允许一次插入或删除多个元素，且不支持迭代器操作。queue创建对象的方式与stack相同，并且其接口与stack大部分都相同。除了提供了与vector相同的接口，queue还提供两个自己特有的成员函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//包含头文件queue</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建list容器l</span></span><br><span class="line">    queue&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(l); <span class="comment">//创建queue容器适配器q</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素&quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">//获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素&quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">//获取最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例7-9中，第7行代码创建了list容器l。第8行代码创建了queue容器适配器q，封装容器l。第9～10行代码分别调用push()函数和em place()函数在q尾部插入元素4和5。第11行代码调用pop()函数删除q头部元素，即第一个元素。第12～13行代码分别调用front()函数和back()函数获取第一个元素和最后一个元素并输出。由图7-20可知，程序输出的第一个元素和最后一个元素分别是2和5。第14～18行代码在while循环中调用front()函数获取第一个元素并输出，然后调用pop()函数删除第一个元素。由图7-20可知，程序成功输出了q中的元素。</p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>priority_queue中的元素可以按照自定义的方式进行动态排序。向priority_queue中插入或删除元素时，priority_queue会动态地调整，以保证元素有序。priority_queue的存储结构如图7-21所示。priority_queue创建方式与queue相同，只是在创建priority_queue时，可以指定优先规则，即最后一个模板参数可以是一个函数对象，指定元素排序规则。创建priority_queue的示例代码如下：</p>
<p>priority_queue的接口与queue相同，使用比较简单。下面通过案例演示priority_queue的具体用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q1.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q1);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, Comp&gt; q2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>通过迭代器既可分离容器与算法，又可连接容器与算法。从容器的角度看，只需提供适当的迭代器，就可以遍历容器中的数据，而不必关心数据将用于何种操作；从算法的角度看，只需要通过迭代器操作数据，不必关心是什么类型的容器。容器设计者只需要专注于容器的设计，算法设计者只需要专注于算法的设计，这样就可以很好地实现数据结构与算法的分离。STL提供了五种基本的迭代器：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机迭代器。</p>
<h3 id="输入迭代器与输出迭代器"><a href="#输入迭代器与输出迭代器" class="headerlink" title="输入迭代器与输出迭代器"></a>输入迭代器与输出迭代器</h3><p>输入迭代器和输出迭代器是最基本、要求最低的迭代器，几乎所有的迭代器都具备这两个迭代器的功能。</p>
<h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><p>输入迭代器（Input Iterator）只能一次一个地向后读取元素，并按此顺序传回元素值。输入迭代器支持对序列进行不可重复的单向遍历。</p>
<p>如果有两个输入迭代器itr1和itr2，且有itr1&#x3D;&#x3D;itr2，但这并不保证++itr1&#x3D;&#x3D;++itr2，更不能保证*(++itr1)&#x3D;&#x3D;*(++itr2)。因此，使用输入迭代器读入的序列不能保证是可重复的。</p>
<h4 id="输入迭代器-1"><a href="#输入迭代器-1" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><p>输出迭代器（Output Iterator）与输入迭代器相反，其作用是将元素逐个写入容器。输出迭代器也支持对序列进行单向遍历，当把迭代器移到下一个位置后，也不能保证之前的迭代器是有效的。</p>
<h4 id="前向迭代器"><a href="#前向迭代器" class="headerlink" title="前向迭代器"></a>前向迭代器</h4><p>前向迭代器（Forward Iterator）是输入迭代器和输出迭代器的集合，具有输入迭代器和输出迭代器的全部功能。前向迭代器支持对序列进行可重复的单向遍历，可以多次解析一个迭代器指定的位置，因此可以对一个值进行多次读写。前向迭代器去掉了输入迭代器与输出迭代器的一些不确定性，例如，如果有两个前向迭代器itr1和itr2，且有itr1&#x3D;&#x3D;itr2，那么++itr1&#x3D;&#x3D;++itr2一定是成立的。前后两次使用相等的前向迭代器读取同一个序列，只要序列的值在这个过程中没有被改写，就一定会得到相同的结果。<br>####双向迭代器与随机访问迭代器<br>双向迭代器（Bidirectional Iterator）是在前向迭代器的基础上增加了一个反向操作，即双向迭代器既可以前进，又可以后退，因此它比前向迭代器新增一个功能，可以进行自减操作，如itr++或者++itr。<br>随机访问迭代器（Random Iterator）是在双向迭代器的基础上又支持直接将迭代器向前或向后移动n个元素，而且还支持比较运算的操作。因此，随机访问迭代器的功能几乎和指针一样。随机访问迭代器支持的操作如表7-7所示。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法实际上是一系列的函数模板，STL定义了大约70个算法，这些算法以迭代器为参数，可以处理各种类型容器的元素。学习STL算法时，读者可以不必知道算法是如何设计的，但需要知道如何在自己的程序中使用这些算法。本节将介绍STL算法。</p>
<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="算法的头文件"><a href="#算法的头文件" class="headerlink" title="算法的头文件"></a>算法的头文件</h4><p>STL中提供的所有算法都包含在algorithm、numeric、functional三个头文件中。<br>其中，algorithm是最大的一个算法头文件，它由一系列函数模板组成，涉及的功能有比较、交换、查找、遍历、复制、修改、删除、合并、排序等。<br>numeric比较小，只包括在容器中进行简单数学运算的几个函数模板。<br>functional中定义了一些类模板，用于生成一些函数对象。</p>
<h4 id="算法的分类"><a href="#算法的分类" class="headerlink" title="算法的分类"></a>算法的分类</h4><p>STL中的算法大致可分为4类，分别如下所示。<br>不可变序列算法：不可变序列算法可以获取容器元素执行一定的操作，但算法不会改动原容器中元素的次序，也不改动元素值。<br>可变序列算法：可变序列算法能够修改容器中的元素值。由于可变序列算法可以修改元素的值，而迭代器指向的位置可能并不可用，可能会导致程序出错，因此可变序列算法对操作区间有一定要求。<br>排序算法：排序算法包括对序列进行排序、合并、搜索等，有序序列的集合操作以及堆操作相关算法也涉及排序，所有这些算法都通过对序列元素的比较操作完成。排序算法一般通过对容器中元素的赋值和交换来改变元素顺序。<br>数值算法：数值算法主要是对容器中的元素进行数值计算，例如，容器元素的累加计算、相邻元素差等。</p>
<h3 id="常用的算法"><a href="#常用的算法" class="headerlink" title="常用的算法"></a>常用的算法</h3><h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each()算法"></a>for_each()算法</h4><p>for_each()属于不可变序列算法，该算法可以依次处理容器中的每一个元素。for_each()算法原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt; </span></span><br><span class="line"><span class="function"><span class="title">for_each</span><span class="params">(InputIterator begin, InputIterator end, Function fun</span></span></span><br></pre></td></tr></table></figure>
<p>在上述算法原型中，参数begin、end表示要操作的元素区间；参数func是一个函数对象，表示对[begin,end)区间中的每个元素要施加的操作。for_each()算法只是对取出的元素进行相应操作，它不会对容器中的元素做任何修改，也不会改变原来容器的元素次序。</p>
<h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find()算法"></a>find()算法</h4><p>find()也是不可变序列算法，用于在指定区间查找某一元素是否存在。find()算法原型如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator begin, InputIterator end, <span class="type">const</span> T&amp; valu</span></span></span><br></pre></td></tr></table></figure>
<p>在上述算法原型中，参数begin、end表示要查找的元素区间；参数value表示要查找的元素值。find()算法是在[begin,end)区间查找value元素是否存在，如果存在，就返回指向这个元素的迭代器；如果不存在，就返回指向容器末尾的迭代器。</p>
<h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy()算法"></a>copy()算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator&gt; </span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(InputIterator begin, InputIterator end, OutputIterator DestBe</span></span></span><br></pre></td></tr></table></figure>
<p>在上述算法原型中，参数begin、end表示要复制的元素区间；参数D estBeg表示目的存储空间的起始位置。由于在讲解迭代器时，已经多次调用copy()函数将元素复制到cout流对象中从而输出到屏幕，因此这里不再赘述。</p>
<h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort()算法"></a>sort()算法</h4><p>sort()算法属于可变序列算法，用于对容器元素进行排序。sort()算法有两种重载形式，分别如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt&gt; <span class="comment">//第一种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Pred&gt; <span class="comment">//第二种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end, Pred op)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt&gt; <span class="comment">//第一种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Pred&gt; <span class="comment">//第二种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end, Pred op)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一种形式是默认的，按从小到大的顺序排列容器中的元素；第二种形式可以指定排序规则。第二种重载形式比第一种形式更加通用。</p>
<h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h4><p>accumulate()算法属于数值算法，用于累加指定区间的元素值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator begin, InputIterator end, T ini</span></span></span><br></pre></td></tr></table></figure>
<p>在上述算法原型中，参数begin、end表示要累加的元素区间；参数init表示累加的初始值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multi</span> <span class="comment">//定义类模板</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Multi</span>(<span class="type">const</span> T &amp;v) : <span class="built_in">value</span>(v) &#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;elem)</span> <span class="type">const</span>  <span class="comment">//重载“()”运算符</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        elem *= value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">assign</span>(arr, arr + <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//用数组为v容器赋值                                                  //调用for_each()函数将容器中每个元素都乘以2</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>(), <span class="built_in">Multi</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//调用copy()构造函数将容器中的元素输出到屏幕</span></span><br><span class="line">    <span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用find()算法查找容器中是否存在值为200的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器中有值为200的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器中不存在值为200的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用sort()算法将容器中的元素从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序之后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//累加容器中的元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/18/c6/" title="第六章 模板"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第六章 模板</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/18/c8/" title="第八章 I/O流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第八章 I/O流</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-STL"><span class="toc-number">1.</span> <span class="toc-text">第七章 STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.1.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%9E%E9%99%85%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">获取容器和实际元素个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">访问容器中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">赋值函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%B4%E9%83%A8%E5%92%8C%E5%B0%BE%E9%83%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">获取头部和尾部元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">从尾部插入和删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">容器的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">在任意位置插入和删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AD%A6%E4%B8%80%E6%8B%9B%EF%BC%9Adeque%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">多学一招：deque容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">1.1.2.</span> <span class="toc-text">array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAarray%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">创建array容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">修改容器元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">1.1.3.</span> <span class="toc-text">list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAlist%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">创建list容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">元素访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.4.</span> <span class="toc-text">插入元素和删除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward-list"><span class="toc-number">1.1.5.</span> <span class="toc-text">forward_list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">插入和删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">获取迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E4%B8%8Emultiset"><span class="toc-number">1.2.1.</span> <span class="toc-text">set与multiset</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAset%E4%B8%8Emultiset%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">创建set与multiset容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">容器的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">插入和删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AD%A6%E4%B8%80%E6%8B%9B%EF%BC%9Apair%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">多学一招：pair类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApair%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">创建pair对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">pair对象的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E4%B8%8Emultimap"><span class="toc-number">1.2.2.</span> <span class="toc-text">map与multimap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmap%E4%B8%8Emultimap%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">创建map与multimap容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">容器大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-2"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">插入和删除元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">容器适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">1.3.1.</span> <span class="toc-text">stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAstack"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">创建stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE-1"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">元素访问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">1.3.2.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.3.3.</span> <span class="toc-text">priority_queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">输入迭代器与输出迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">输入迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">输入迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">前向迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">算法的头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">算法的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">常用的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#for-each-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">for_each()算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">find()算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">copy()算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">sort()算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#accumulate-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">accumulate()算法</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By takisano</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>