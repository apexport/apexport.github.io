<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>takisano | takisano</title><meta name="author" content="takisano"><meta name="copyright" content="takisano"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第十章 C++11 新特性简洁的变成方式关键字auto在C++11标准之前，auto关键字已经存在，其作用是限定变量的作用域。在C++11标准中，auto被赋予了新的功能，使用它可以让编译器自动推导出变量的类型。示例代码如下所示： 1auto x &#x3D;10 &#x2F;&#x2F;变量x为int类型 在上述代码中，使用auto定义了变量x，并赋值为10，则变量x的类型由它的初始化值决定。由于编译器根据初始化值推导并确定">
<meta property="og:type" content="article">
<meta property="og:title" content="takisano">
<meta property="og:url" content="http://example.com/2022/12/18/c10/index.html">
<meta property="og:site_name" content="takisano">
<meta property="og:description" content="第十章 C++11 新特性简洁的变成方式关键字auto在C++11标准之前，auto关键字已经存在，其作用是限定变量的作用域。在C++11标准中，auto被赋予了新的功能，使用它可以让编译器自动推导出变量的类型。示例代码如下所示： 1auto x &#x3D;10 &#x2F;&#x2F;变量x为int类型 在上述代码中，使用auto定义了变量x，并赋值为10，则变量x的类型由它的初始化值决定。由于编译器根据初始化值推导并确定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2022-12-17T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-21T10:14:45.033Z">
<meta property="article:author" content="takisano">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/18/c10/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'takisano',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-21 18:14:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="takisano" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="takisano"><span class="site-name">takisano</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-17T16:00:00.000Z" title="发表于 2022-12-18 00:00:00">2022-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-21T10:14:45.033Z" title="更新于 2022-12-21 18:14:45">2022-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第十章-C-11-新特性"><a href="#第十章-C-11-新特性" class="headerlink" title="第十章 C++11 新特性"></a>第十章 C++11 新特性</h1><h2 id="简洁的变成方式"><a href="#简洁的变成方式" class="headerlink" title="简洁的变成方式"></a>简洁的变成方式</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>在C++11标准之前，auto关键字已经存在，其作用是限定变量的作用域。在C++11标准中，auto被赋予了新的功能，使用它可以让编译器自动推导出变量的类型。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x =<span class="number">10</span> <span class="comment">//变量x为int类型</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，使用auto定义了变量x，并赋值为10，则变量x的类型由它的初始化值决定。由于编译器根据初始化值推导并确定变量的类型，因此auto修饰的变量必须初始化。除了修饰变量，auto还可以作为函数的返回值，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//……功能代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，auto可以修饰函数的返回值，但是auto不能修饰函数参数。除了修饰变量、函数返回值等，auto最大的用途就是简化模板编程中的代码，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> value = m.<span class="built_in">begin</span>(); value != m.<span class="built_in">end</span>(); value++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用auto，则代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt;::iterator value;</span><br><span class="line"><span class="keyword">for</span> (value = m.<span class="built_in">begin</span>(); value != m.<span class="built_in">end</span>(); value++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，在模板编程中，变量的类型依赖于模板参数，有时很难确定变量的类型。当不确定变量类型时，可以使用auto关键字解决，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = x * y; <span class="comment">//使用auto修饰变量result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype关键字是C++11标准新增的关键字，功能与auto关键字类似，也是在编译时期进行类型推导，但decltype的用法与auto不同，decltype关键字的使用格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>
<p>在上述格式中，decltype关键字会根据表达式的结果推导出数据类型，但它并不会真正计算出表达式的值。需要注意的是，decltype关键字的参数表达式不能是具体的数据类型。decltype关键字的用法示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> b; </span><br><span class="line"><span class="type">float</span> f; </span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(a+b)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//推导结果：int </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(a+f)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//推导结果：float </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(<span class="type">int</span>)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//错误，不能通过编译</span></span><br></pre></td></tr></table></figure>
<p>在程序设计中，可以使用decltype关键字推导出的类型定义新变量，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> b; </span><br><span class="line"><span class="type">float</span> f; </span><br><span class="line"><span class="keyword">decltype</span>(a + b) x;        <span class="comment">//定义int类型变量x </span></span><br><span class="line"><span class="keyword">decltype</span>(a + f) y;        <span class="comment">//定义float类型变量y</span></span><br></pre></td></tr></table></figure>
<p>decltype关键字最为强大的功能是在泛型编程中，与auto关键字结合使用推导函数返回值类型。auto作为函数返回值占位符，-&gt;decltype()放在函数后面用于推导函数返回值类型。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T1 x, T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x * y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><p>在C语言中，为避免野指针的出现，通常使用NULL为指针赋值。C语言中NULL的定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure>
<p>由上述定义可知，NULL是一个<code>void*</code>类型的指针，其值为0。在使用NULL给其他指针赋值时，发生了隐式类型转换，即将<code>void*</code>类型指针转换为要赋值的指针类型。NULL的值被定义为字面常量0，这样会导致指针在使用过程中产生一些不可避免的错误。例如，有两个函数，函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> *p)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，有两个重载函数func()，如果在调用第一个func()函数时，传入的第二个参数为0或NULL，则编译器总会调用第二个func()函数，即两个参数都是int类型的函数。这就与实际想要调用的函数相违背。如果想要根据传入的参数成功调用相应的func()函数，则需要使用static_cast转换运算符将0强制转换，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);                         <span class="comment">//调用func(int a,int b) </span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(<span class="number">0</span>));    <span class="comment">//调用func(int a,int *p) </span></span><br></pre></td></tr></table></figure>
<p>虽然使用static_cast转换运算符解决了此问题，但是这种方式极易出错，而且会增加代码的复杂程度。为了修复上述缺陷，C++11标准引入了一个新的关键字nullptr，nullptr也表示空指针，可以为指针赋值，避免出现野指针。但是，nullptr是一个有类型的空指针常量，当使用nullptr给指针赋值时，nullptr可以隐式转换为等号左侧的指针类型。需要注意的是，nullptr只能被转换为其他指针类型，不能转换为非指针类型。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;     <span class="comment">//正确 </span></span><br><span class="line"><span class="type">int</span> x = <span class="literal">nullptr</span>;     <span class="comment">//错误，nullptr不能转换为int类型</span></span><br></pre></td></tr></table></figure>
<p>由于nullptr只能转换为其他指针类型，因此它能够消除字面常量0带来的二义性。在调用func()函数时，如果传入nullptr作为第二个参数，则func()函数能够被正确调用。示例代码如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);      <span class="comment">//调用func(int a,int b) </span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="literal">nullptr</span>);     <span class="comment">//调用func(int a,int *p)</span></span><br></pre></td></tr></table></figure>
<h4 id="default与-delete"><a href="#default与-delete" class="headerlink" title="&#x3D;default与&#x3D;delete"></a>&#x3D;default与&#x3D;delete</h4><p>构造函数、析构函数、拷贝构造函数等是类的特殊成员函数，如果在类中没有显式定义这些成员函数，编译器会提供默认的构造函数、析构函数、拷贝构造函数等。但是，如果在类中显式定义了这些函数，编译器将不会再提供默认的版本。例如，定义了动物类Anim al，并且在类中显式定义了构造函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Animal</span>(string name); </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，定义了有参构造函数，则编译器不再提供默认的构造函数。如果在程序中需要调用无参构造函数，就需要程序设计者自己定义一个无参构造函数，即使这个无参构造函数体为空，并没有实现任何功能。在实际开发中，一个项目工程中的类非常多，这样做势必会增加代码量。为了使代码更简洁、高效，C++11标准引入了一个新特性，在默认函数声明后面添加“&#x3D;default”，显式地指示编译器生成该函数的默认版本。例如，在Anim al类中，使用“&#x3D;default”指示编译器提供默认的构造函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Animal</span>() = <span class="keyword">default</span>;     <span class="comment">//编译器会提供默认的构造函数 </span></span><br><span class="line"> <span class="built_in">Animal</span>(string name); </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>有时，我们不希望类的某些成员函数在类外被调用，例如，在类外禁止调用类的拷贝构造函数。在C++98标准中，通常的做法是显式声明类的拷贝构造函数，并将其声明为类的私有成员。而C++11标准提供了一种更简便的方法，在函数的声明后面加上“&#x3D;delete”，编译器就会禁止函数在类外调用，这样的函数称为已删除函数。例如，禁止调用Anim al类的拷贝构造函数，则可以声明Anim al类的拷贝构造函数，并使用“&#x3D;delete”进行修饰，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">//… </span></span><br><span class="line"> <span class="built_in">Animal</span>(<span class="type">const</span> Animal&amp;) = <span class="keyword">delete</span>;   <span class="comment">//在类外禁止调用拷贝构造函数 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>在上述代码中，使用“&#x3D;delete”修饰拷贝构造函数，则在Anim al类外就无法再调用拷贝构造函数了。除了修饰类的成员函数，“&#x3D;delete”还可以修饰普通函数，被“&#x3D;delete”修饰的普通函数，在程序中也会被禁止调用。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> ch)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"><span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);       <span class="comment">//错误 </span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，func()函数被“&#x3D;delete”修饰，当传入字符’a’调用func()函数时，编译器就会报错，提示“func()函数是已删除函数”。</p>
<h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>在传统C++中，使用for循环遍历一组数据时，必须要明确指定for循环的遍历范围，但是在很多时候，对于一个有范围的集合，明确指定遍历范围是多余的，而且容易出现错误。针对这个问题，C++11标准提出了基于范围的for循环，该for循环语句可以自动确定遍历范围。基于范围的for循环语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量:对象) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//… </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>在上述语法格式中，for循环语句会遍历对象，将取到的值赋给变量，执行完循环体中的操作之后，再自动获取对象中的下一个值赋给变量，直到对象中的数据被迭代完毕。基于范围的for循环的用法示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:v) </span><br><span class="line"> cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式是C++11标准中非常重要的一个新特性，它用于定义匿名函数，使得代码更加灵活、简洁。lambda表达式与普通函数类似，也有参数列表、返回值类型和函数体，只是它的定义方式更简洁，并且可以在函数内部定义。lambda表达式的语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表)-&gt;返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p>根据捕获规则，捕获列表有以下五种常用的捕获形式。（1）[]：空捕获，表示lambda表达式不捕获任何变量。<br>（2）[var]：变量捕获，表示捕获局部变量var。如果捕获多个变量，变量之间用“，”分隔。<br>（3）[&amp;var]：引用捕获，表示以引用方式捕获局部变量var。<br>（4）[&#x3D;]：隐式捕获，表示捕获所有的局部变量。（5）[&amp;]：隐式引用捕获，表示以引用方式捕获所有的局部变量。<br>以上捕获方式还可以组合使用，通过组合，捕获列表可以实现更复杂的捕获功能，例如，[&#x3D;,&amp;a,&amp;b]表示以引用方式捕获变量a和变量b，以值传递方式捕获其他所有变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f = [num](<span class="type">int</span> x) -&gt; <span class="type">int</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + num; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建vector对象v</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">54</span>, <span class="number">148</span>, <span class="number">3</span>, <span class="number">848</span>, <span class="number">2</span>, <span class="number">89</span>&#125;;</span><br><span class="line">    <span class="comment">//调用for_each()函数遍历输出v容器中的元素</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> n)</span><br><span class="line">             &#123; cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr智能指针主要用来代替C++98标准中的auto_ptr，它的使用方法与auto_ptr相同，创建unique_ptr智能指针对象的语法格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_prt&lt;T&gt; 智能指针对象名称(指针);</span><br></pre></td></tr></table></figure>
<p>在上述格式中，<code>unique_ptr&lt;T&gt;</code>是模板类型，后面是智能指针对象名称，遵守标识符命名规范。智能指针对象名称后面的小括号中的参数是一个指针，该指针是new运算符申请堆内存空间返回的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;…&#125;; </span><br><span class="line"><span class="function">unique_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，第一行代码创建了一个unique_ptr智能指针对象pi，用于管理一个int类型堆内存空间指针。后两行代码创建了一个unique_ptr智能指针对象pA，用于管理一个A类型的堆内存空间指针。当程序运行结束时，即使没有delete，编译器也会调用unique_ptr模板类的析构函数释放new申请的堆内存空间。需要注意的是，使用智能指针需要包含m em ory头文件。unique_ptr智能指针对象之间不可以赋值，错误示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pt; </span><br><span class="line">pt = ps;     <span class="comment">//错误，不能对unique_ptr智能指针赋值 </span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，直接将智能指针ps赋值给智能指针pt，编译器会报错。这是因为在unique_ptr模板类中，使用“&#x3D;delete”修饰了“&#x3D;”运算符的重载函数。之所以这样做，是因为unique_ptr在实现时是通过所有权的方式管理new对象指针的，一个new对象指针只能被一个unique_ptr智能指针对象管理，即unique_ptr智能指针拥有对new对象指针的所有权。当发生赋值操作时，智能指针会转让所有权。例如，上述代码中的pt&#x3D;ps语句，如果赋值成功，pt将拥有对new对象指针的所有权，而ps则失去所有权，指向无效的数据，成了危险的悬挂指针。如果后面程序中使用到ps，会造成程序崩溃。C++98标准中的auto_ptr就是这种实现方式，因此auto_ptr使用起来比较危险。C++11标准为了修复这种缺陷，就将unique_ptr限制为不能直接使用“&#x3D;”进行赋值。如果需要实现unique_ptr智能指针对象之间的赋值，可以调用C++标准库提供的m ove()函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pt; </span><br><span class="line">pt = <span class="built_in">move</span>(ps);   <span class="comment">//正确，可以通过编译</span></span><br></pre></td></tr></table></figure>
<p>调用m ove()函数完成赋值之后，pt拥有new对象指针的所有权，而ps则被赋值为nullptr。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr是一种智能级别更高的指针，它在实现时采用了引用计数的方式，多个shared_ptr智能指针对象可以同时管理一个new对象指针。每增加一个shared_ptr智能指针对象，new对象指针的引用计数就加1；当shared_ptr智能指针对象失效时，new对象指针的引用计数就减1，而其他shared_ptr智能指针对象的使用并不会受到影响。只有在引用计数归为0时，shared_ptr才会真正释放所管理的堆内存空间。shared_ptr与unique_ptr用法相同，创建shared_ptr智能指针对象的格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; 智能指针对象名称(指针);</span><br></pre></td></tr></table></figure>
<p>shared_ptr提供了一些成员函数以更方便地管理堆内存空间，下面介绍几个常用的成员函数。<br>（1）get()函数：用于获取shared_ptr管理的new对象指针，函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>; </span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，get()函数返回一个T*类型的指针。当使用cout输出get()函数的返回结果时，会得到new对象的地址。<br>（2）use_count()函数：用于获取new对象的引用计数，函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，use_count()函数返回一个long类型的数据，表示new对象的引用计数。<br>（3）reset()函数：用于取消shared_ptr智能指针对象对new对象的引用，函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，reset()的声明比较简单，既没有参数也没有返回值。当调用reset()函数之后，new对象的引用计数就会减1。取消引用之后，当前智能指针对象被赋值为nullptr。下面通过案例演示shared_ptr智能指针的使用，如例10-2所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">       <span class="comment">//创建shared_ptr智能指针对象language1、language2、language3</span></span><br><span class="line">       <span class="function">shared_ptr&lt;string&gt; <span class="title">language1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">       shared_ptr&lt;string&gt; language2= language1; </span><br><span class="line">       shared_ptr&lt;string&gt; language3= language1; </span><br><span class="line">      <span class="comment">//通过智能指针对象language1、language2、language3调用get()函数 </span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language1: &quot;</span> &lt;&lt; language1.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language2: &quot;</span> &lt;&lt; language2.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language3: &quot;</span> &lt;&lt; language3.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span>; </span><br><span class="line">      cout &lt;&lt; language1.<span class="built_in">use_count</span>() &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language2.<span class="built_in">use_count</span>() &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language3.<span class="built_in">use_count</span>() &lt;&lt;endl; </span><br><span class="line">      language1.<span class="built_in">reset</span>(); </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span>; </span><br><span class="line">      cout &lt;&lt; language1.<span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language2.<span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language3.<span class="built_in">use_count</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language1: &quot;</span> &lt;&lt; language1.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language2: &quot;</span> &lt;&lt; language2.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language3: &quot;</span> &lt;&lt; language3.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>相比于unique_ptr与shared_ptr，weak_ptr智能指针的使用更复杂一些，它可以指向shared_ptr管理的new对象，却没有该对象的所有权，即无法通过weak_ptr对象管理new对象。shared_ptr、weak_ptr和new对象的关系示意图如图10-3所示。在图10-3中，shared_ptr对象和weak_ptr对象指向同一个new对象，但weak_ptr对象却不具有new对象的所有权。weak_ptr模板类没有提供与unique_ptr、shared_ptr相同的构造函数，因此，不能通过传递new对象指针的方式创建weak_ptr对象。weak_ptr最常见的用法是验证shared_ptr对象的有效性。weak_ptr提供了一个成员函数lock()，该函数用于返回一个shared_ptr对象，如果weak_ptr指向的new对象没有shared_ptr引用，则lock()函数返回nullptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(weak_ptr&lt;string&gt; &amp;pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过pw.lock()获取一个shared_ptr对象</span></span><br><span class="line">    shared_ptr&lt;string&gt; ps = pw.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;编程语言是&quot;</span> &lt;&lt; *ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;shared_ptr智能指针失效！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义shared_ptr对象pt1与pt2</span></span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">pt1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;string&gt; pt2 = pt1;</span><br><span class="line">    <span class="comment">//定义weak_ptr对象</span></span><br><span class="line">    weak_ptr&lt;string&gt; pw = pt1;</span><br><span class="line">    <span class="built_in">func</span>(pw); <span class="comment">//调用func()函数</span></span><br><span class="line">    *pt1 = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">    pt1.<span class="built_in">reset</span>(); <span class="comment">//取消pt1的引用</span></span><br><span class="line">    <span class="built_in">func</span>(pw);    <span class="comment">//调用func()函数</span></span><br><span class="line">    pt2.<span class="built_in">reset</span>(); <span class="comment">//取消pt2的引用</span></span><br><span class="line">    <span class="built_in">func</span>(pw);    <span class="comment">//调用func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过pt1修改new对象中的数据，但是，由于weak_ptr对new对象没有所有权，因此无法通过pw修改new对象中的数据。<br>提高编程效率<br>右值引用<br>在C++11标准出现之前，程序中只有左值与右值的概念，简单来说，左值就是“&#x3D;”符号左边的值，右值就是“&#x3D;”符号右边的值。区分左值与右值的一个简单、有效的方法为：可以取地址的是左值，不可以取地址的是右值。C++11标准对右值进行了更详细的划分，将右值分为纯右值与将亡值。纯右值是指字面常量、运算表达式、lambda表达式等；将亡值是那些即将被销毁却可以移动的值，如函数返回值。随着对右值的详细划分，C++11标准提出了右值引用的概念，右值引用就是定义一个标识符引用右值，右值引用通过“&amp;&amp;”符号定义，定义格式如下所示：<br>类型&amp;&amp; 引用名称&#x3D;右值;<br>在上述格式中，类型是要引用的右值的数据类型，“&amp;&amp;”符号表明这是一个右值引用，引用名称遵守标识符命名规范，“&#x3D;”符号后面是要引用的右值。下面定义一些右值引用，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; r1 = <span class="number">100</span>;   <span class="comment">//字面常量100是一个右值 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r2 = x + y;    <span class="comment">//表达式x+y是一个右值 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r3 = <span class="built_in">sqrt</span>(<span class="number">9.0</span>);   <span class="comment">//函数返回值是一个右值</span></span><br></pre></td></tr></table></figure>
<p>与左值引用相同，右值引用在定义时也必须初始化。右值引用只能引用右值，不能引用左值，错误示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; a = x;     <span class="comment">//错误 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; b = y;     <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，变量x、y都是左值，因此不能将它们绑定到右值引用。需要注意的是，一个已经定义的右值引用是一个左值，即已经定义的右值引用是可以被赋值的变量，因此不能使用右值引用来引用另一个右值引用，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">100</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; n = m;     <span class="comment">//错误，m是变量，是左值，不能被绑定到右值引用n上</span></span><br></pre></td></tr></table></figure>
<h3 id="移动构造"><a href="#移动构造" class="headerlink" title="*移动构造"></a>*移动构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="comment">//定义类A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> <span class="comment">//定义func()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;      <span class="comment">//创建对象a</span></span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">//返回对象a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A b = <span class="built_in">func</span>(); <span class="comment">//调用func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n);      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a);      <span class="comment">//移动构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();          <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(*(a.p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(A &amp;&amp;a) <span class="comment">//类外实现移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    p = a.p;       <span class="comment">//将当前对象指针指向a.p指向的空间</span></span><br><span class="line">    a.p = <span class="literal">nullptr</span>; <span class="comment">//将a.p赋值为nullptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A m = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n);      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a);      <span class="comment">//移动构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();          <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(*(a.p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(A &amp;&amp;a) <span class="comment">//类外实现移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    p = a.p;       <span class="comment">//将当前对象指针指向a.p指向的空间</span></span><br><span class="line">    a.p = <span class="literal">nullptr</span>; <span class="comment">//将a.p赋值为nullptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A m = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="move-函数"><a href="#move-函数" class="headerlink" title="move()函数"></a>move()函数</h3><p>移动构造函数是通过右值引用实现的，对于左值，也可以将其转化为右值，实现程序的性能优化。C++11在标准库utility中提供了m ove()函数，该函数的功能就是将一个左值强制转换为右值，以便可以通过右值引用使用该值。m ove()函数的用法示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; r = <span class="built_in">move</span>(x);   <span class="comment">//将左值x强制转换为右值 </span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，m ove()函数将左值x强制转换为右值，赋值给右值引用r。如果类中有指针或者动态数组成员，在对象被拷贝或赋值时，可以直接调用m ove()函数将对象转换为右值，去初始化另一个对象。使用右值进行初始化，调用的是移动构造函数，而不是拷贝构造函数，这样就可以避免大量数据的拷贝，能够极大地提高程序的运行效率。例如，在例10-5中，如果使用左值对象初始化另一个对象，则会调用拷贝构造函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;     <span class="comment">//对象a是左值，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>但是，如果将对象a转换为右值，则会调用移动构造函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function">A <span class="title">c</span><span class="params">(move(a))</span></span>;    <span class="comment">//对象a被转换为右值，调用移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>当对象内部有较大的堆内存数据时，应当定义移动构造函数，并使用m ove()函数完成对象之间的初始化，以避免没有意义的深拷贝。</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transimit</span><span class="params">(T &amp;t)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transimit</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(U &amp;&amp;u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">transimit</span>(u);       <span class="comment">//调用transimit()函数</span></span><br><span class="line">    <span class="built_in">transimit</span>(<span class="built_in">move</span>(u)); <span class="comment">//调用transimit()函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">1</span>); <span class="comment">//调用test()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在例10-6中，第3～6行代码定义了两个重载的模板函数transim it()，第一个重载函数接收一个左值引用作为参数，第二个重载函数接收一个右值引用作为参数。第7～12行代码定义模板函数test()，在test()函数内部以不同的参数调用transim it()函数。第15行代码调用test()函数，传入右值1作为参数。由图10-9可知，使用右值1调用test()函数时，test()函数的输出结果是“左值”“右值”。在调用过程中，右值1到test()函数内部变成了左值，因此transim it(u)其实是接收的左值，输出了“左值”；第二次调用transim it()函数时，使用m ove()函数将左值转换为右值，因此transim it(m ove(u))输出结果为“右值”。在例10-6中，调用test()函数时，传递的是右值，但在test()函数内部，第一次调用transim it()函数时，右值变为左值，这显然不符合程序设计者的期望。针对这种情况，C++11标准提供了一个函数forward()，它能够完全依照模板的参数类型，将参数传递给函数模板中调用的函数，即参数在转发过程中，参数类型一直保持不变，这种转发方式称为完美转发。例如，将例10-6中的第10行代码修改为下列形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transimit</span>(forward&lt;U&gt;(u));   <span class="comment">//调用forward()函数实现完美转发</span></span><br></pre></td></tr></table></figure>
<p>此时，再调用test(1)函数时，其输出结果均为“右值”。forward()函数在实现完美转发时遵循引用折叠规则，该规则通过形参和实参的类型推导出内层函数接收到的参数的实际类型。引用折叠规则如表10-1所示。<br>根据表10-1可推导出内层函数最终接收到的参数是左值引用还是右值引用。在引用折叠规则中，所有的右值引用都可以叠加，最后变成一个右值引用；所有的左值引用也都可以叠加，最后变成一个左值引用。在C++11标准库中，完美转发的应用非常广泛，如一些简单好用的函数（如m ake_pair()、m ake_unique()等）都使用了完美转发，它们减少了函数版本的重复，并且充分利用了右值引用，既简化了代码量，又提高了程序的运行效率。</p>
<h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>如果一个类定义了多个构造函数，这些构造函数就可能会有大量的重复代码。例如，有如下类定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()</span><br><span class="line">    &#123;                    <span class="comment">/*...其他代码*/</span></span><br><span class="line">    &#125;                    <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string name) <span class="comment">//只有一个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = <span class="number">1001</span>;</span><br><span class="line">        _score = <span class="number">97.6</span>;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> id) <span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = id;</span><br><span class="line">        _score = <span class="number">98.5</span>;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> id, <span class="type">double</span> score) <span class="comment">//有三个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = id;</span><br><span class="line">        _score = score;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">double</span> _score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，每一个构造函数都需要给成员变量赋值，这些赋值语句都很重复。为了简化构造函数的编写，C++11标准提出了委托构造函数。委托构造函数就是在构造函数定义时，调用另一个已经定义好的构造函数完成对象的初始化。被委托的构造函数称为目标构造函数。例如，修改上述代码中Student类的定义，在类中定义委托构造函数，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Student</span>():<span class="built_in">Student</span>(<span class="string">&quot;lili&quot;</span>,<span class="number">1003</span>,<span class="number">99</span>) &#123; <span class="comment">/*...其他代码*/</span> &#125;  <span class="comment">//委托构造函数 </span></span><br><span class="line"> <span class="built_in">Student</span>(string name):<span class="built_in">Student</span>(name,<span class="number">1001</span>,<span class="number">97.6</span>)   <span class="comment">//委托构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">Student</span>(string name, <span class="type">int</span> id):<span class="built_in">Student</span>(name,id,<span class="number">98.5</span>)  <span class="comment">//委托构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line"> <span class="type">int</span> _id; </span><br><span class="line"> <span class="type">double</span> _score; </span><br><span class="line"> <span class="built_in">Student</span>(<span class="type">const</span> string name, <span class="type">int</span> id, <span class="type">double</span> score)  <span class="comment">//目标构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      _name = name; </span><br><span class="line">      _id = id; </span><br><span class="line">      _score = score; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>上述代码中，无参构造函数、一个参数的构造函数、两个参数的构造函数都是委托构造函数，它们都委托有三个参数的目标构造函数完成对象的初始化工作。委托构造函数体中的语句在目标构造函数完全执行后才被执行。目标构造函数体中的局部变量不在委托构造函数体中起作用。在定义委托构造函数时，目标构造函数还可以再委托给另一个构造函数。但是，需要注意的是，委托构造函数不能递归定义（即构造函数C1不能委托给另一个构造函数C2，而C2再委托给C1）。<br>继承构造<br>在传统C++编程中，派生类不能继承基类的构造函数，无法通过继承直接调用基类构造函数完成基类成员变量的初始化。如果想要在派生类中完成基类成员变量的初始化，只能在派生类中定义若干构造函数，通过参数传递的方式，调用基类构造函数完成基类成员变量的初始化。为了简化代码的编写，C++11标准提出了继承构造函数的概念，使用using关键字在派生类中引入基类的构造函数，格式如下所示：<br>using 基类名::构造函数名;<br>在派生类中使用using关键字引入基类构造函数之后，派生类就不需要再定义用于参数传递的构造函数了。C++11标准将继承构造函数设计为派生类的隐匿声明函数，如果某个继承构造函数不被调用，编译器不会为其生成真正的函数代码。继承构造函数可以简化派生类的代码编写，但是它只能初始化基类的成员变量，无法初始化派生类的成员变量。如果要初始化派生类的成员变量，还需要定义相应的派生类构造函数。下面通过案例演示继承构造函数的调用，如例10-7所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="comment">//定义基类Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();                  <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num);           <span class="comment">//有一个int类型参数的构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> d);          <span class="comment">//有一个double类型参数的构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num, <span class="type">double</span> d); <span class="comment">//有两个参数的构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _num;  <span class="comment">//成员变量_num</span></span><br><span class="line">    <span class="type">double</span> _d; <span class="comment">//成员变量_d</span></span><br><span class="line">&#125;;</span><br><span class="line">Base::<span class="built_in">Base</span>() : _num(<span class="number">0</span>), _d(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">int</span> num) : _num(num), _d(<span class="number">1.2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数，初始化int num&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">double</span> d) : _num(<span class="number">100</span>), _d(d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数，初始化double d&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">int</span> num, <span class="type">double</span> d) : _num(num), _d(d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base两个参数构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base <span class="comment">//定义派生类Derive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;    <span class="comment">//继承基类构造函数</span></span><br><span class="line">    <span class="built_in">Derive</span>();            <span class="comment">//派生类无参构造函数</span></span><br><span class="line">    <span class="built_in">Derive</span>(string name); <span class="comment">//派生类有参构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name; <span class="comment">//派生类成员变量_name</span></span><br><span class="line">&#125;;</span><br><span class="line">Derive::<span class="built_in">Derive</span>() : _name(<span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Derive::<span class="built_in">Derive</span>(string name) : _name(name)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">d1</span><span class="params">()</span></span>;         <span class="comment">//调用Derive类的无参构造函数</span></span><br><span class="line">    <span class="function">Derive <span class="title">d2</span><span class="params">(<span class="string">&quot;qiqi&quot;</span>)</span></span>;   <span class="comment">//调用Derive类的有参构造函数</span></span><br><span class="line">    <span class="function">Derive <span class="title">d3</span><span class="params">(<span class="number">6</span>)</span></span>;        <span class="comment">//调用Base类的有参构造函数，初始化int num</span></span><br><span class="line">    <span class="function">Derive <span class="title">d4</span><span class="params">(<span class="number">12.8</span>)</span></span>;     <span class="comment">//调用Base类的有参构造函数，初始化double d</span></span><br><span class="line">    <span class="function">Derive <span class="title">d5</span><span class="params">(<span class="number">100</span>, <span class="number">2.9</span>)</span></span>; <span class="comment">//调用Base类的有两个参数的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在使用继承构造函数时，如果基类构造函数有默认值，则每个默认值使用与否的不同组合都会创建出新的构造函数，例如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Base</span>(<span class="type">int</span>  n = <span class="number">3</span>, <span class="type">double</span> d = <span class="number">3.14</span>) &#123;&#125;  <span class="comment">//带有默认值的构造函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base    <span class="comment">//Derive类公有继承Base类 </span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">using</span> Base::Base;     <span class="comment">//继承构造函数 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>在上述代码中，基类Base中定义了一个构造函数，该构造函数的两个参数均有默认值，则基类的构造函数在调用时会存在多种情况，分别如下所示。Base()：默认的构造函数，两个参数均使用默认值。Base(int n)：int类型的参数使用默认值。Base(int n,double d)：两个参数都不使用默认值。Base(const Base&amp;)：默认的拷贝构造函数。由于基类构造函数的版本有多个，因此派生类中的继承构造函数的版本也会有多个，分别如下所示。Derive()：默认的继承构造函数，两个参数都使用默认值。Derive(int)：带有一个参数的继承构造函数，int类型的参数使用默认值。Derive(int,double)：带有两个参数的继承构造函数，两个参数都不使用默认值。Derive(const Derive&amp;)：默认的拷贝构造函数。由此可知，若基类的构造函数是带有参数默认值的构造函数，会产生多个构造函数，应特别小心。此外，若派生类继承自多个基类，多个基类中的构造函数可能会导致派生类中的继承构造函数的函数名、参数相同，从而引发冲突。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Base1</span>(<span class="type">int</span> x) &#123;&#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Base2</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Base2</span>(<span class="type">int</span> x)&#123;&#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">using</span> Base1::Base1; </span><br><span class="line">  <span class="keyword">using</span> Base2::Base2; </span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>
<p>在上述代码中，两个基类构造函数都拥有int类型参数，这会导致派生类中重复定义相同类型的继承构造函数。例如，通过D erive d(100)创建对象时，编译器会提示D erive()构造函数调用不明确。此时，可以通过显式定义派生类构造函数解决这种冲突，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Derive</span>(<span class="type">int</span> x):<span class="built_in">Base1</span>(x), <span class="built_in">Base2</span>(x) &#123;&#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="函数包装"><a href="#函数包装" class="headerlink" title="函数包装"></a>函数包装</h3><p>C++11标准提供了一个函数包装器function，function是一个类模板，它能够为多种类似的函数提供统一的调用接口，即对函数进行包装。function可以包装除类成员函数之外的所有函数，包括普通函数、函数指针、lambda表达式和仿函数。在模板编程中，function能够用统一的方式处理函数，减少函数模板的实例化，因此可以提高程序的运行效率。在学习function之前来看一个案例，如例10-8所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个模板函数func()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count= &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;,&amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通函数square()，用于计算参数的平方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义类Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> id = <span class="number">1001</span>) : _id(id) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="keyword">return</span> _id + num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入square()函数名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;square()函数：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, square) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入仿函数Student()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student类：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, <span class="built_in">Student</span>(<span class="number">1002</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda表达式：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, [](<span class="type">int</span> b)</span><br><span class="line">                                     &#123; <span class="keyword">return</span> b / <span class="number">2</span>; &#125;)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用特征标相同的函数作为参数去调用函数模板时，只实例化一个对应的函数。为此，C++11标准提供了function函数包装器，function可以从调用特征标的角度定义一个对象，用于包装调用特征标相同的函数指针、函数对象或lambda表达式。例如，定义一个调用特征标为int(int)的function对象，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，function定义在functional标准库中，在使用function时，要包含该头文件。使用function包装调用特征标相同的函数，当使用这些函数作为参数调用函数模板时，function可以保证函数模板只实例化一次，下面通过修改例10-8演示function的使用，如例10-9所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;function.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个模板函数func()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count= &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;,&amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通函数square()，用于求参数的平方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义类Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> id = <span class="number">1001</span>) : _id(id) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="keyword">return</span> _id + num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi1 = square;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi2 = <span class="built_in">Student</span>(<span class="number">1002</span>);</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi3 = [](<span class="type">int</span> b)</span><br><span class="line">    &#123; <span class="keyword">return</span> b / <span class="number">2</span>; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;square()函数：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student类：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda表达式：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi3) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，C++项目都非常复杂庞大，函数模板的用途非常多，在调用函数模板时，通过function为调用特征标相同的函数提供统一的接口，可以极大地提高程序运行效率。在例10-9中，定义了三个function对象，为简化编程，可以只定义一个function对象，在调用时分别传入不同的函数名、函数对象或lambda表达式即可，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi; </span><br><span class="line"><span class="comment">//… </span></span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>(square)); </span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>(<span class="built_in">Student</span>(<span class="number">1002</span>))); </span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>([](<span class="type">int</span> b) &#123;<span class="keyword">return</span> b / <span class="number">2</span>; &#125;))</span><br></pre></td></tr></table></figure>
<h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><p>在C++11标准之前，C++语言并没有对并行编程提供语言级别的支持，C++使用的多线程都由第三方库提供，如POSIX标准（pthread）、OpenM G库或W indows线程库，它们都是基于过程的多线程，这使得C++并行编程在可移植性方面存在诸多不足。为此，C++11标准增加了线程及线程相关的类，用于支持并行编程，极大地提高了C++并行编程的可移植性。本节将针对C++并行编程的相关知识进行讲解。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>C++11标准提供了thread类模板用于创建线程，该类模板定义在thread标准库中，因此在创建线程时，需要包含thread头文件。thread类模板定义了一个无参构造函数和一个变参构造函数，因此在创建线程对象时，可以为线程传入参数，也可以不传入参数。需要注意的是，thread类模板不提供拷贝构造函数、赋值运算符重载等函数，因此线程对象之间不可以进行拷贝、赋值等操作。除了构造函数，thread类模板还定义了两个常用的成员函数：join()函数和detach()函数。（1）join()函数：该函数将线程和线程对象连接起来，即将子线程加入程序执行。join()函数是阻塞的，它可以阻塞主线程（当前线程），等待子线程工作结束之后，再启动主线程继续执行任务。（2）detach()函数：该函数分离线程与线程对象，即主线程和子线程可同时进行工作，主线程不必等待子线程结束。但是，detach()函数分离的线程对象不能再调用join()函数将它与线程连接起来。下面通过案例演示C++11标准中线程的创建与使用，如例10-10所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">//包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="comment">//定义函数func()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程工作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>; <span class="comment">//创建线程对象t</span></span><br><span class="line">    t.<span class="built_in">join</span>();       <span class="comment">//将子线程加入程序执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++多线程中，线程对象与线程是相互关联的，线程对象出了作用域之后就会被析构，如果此时线程函数还未执行完，程序就会发生错误，因此需要保证线程函数的生命周期在线程对象生命周期之内。一般通过调用thread中定义的join()函数阻塞主线程，等待子线程结束，或者调用thread中的detach()函数将线程与线程对象进行分离，让线程在后台执行，这样即使线程对象生命周期结束，线程也不会受到影响。例如，在例10-10中，将join()函数替换为detach()函数，将线程对象与线程分离，让线程在后台运行，再次运行程序，运行结果就可能发生变化。即使m ain()函数（主线程）结束，子线程对象t生命周期结束，子线程依然会在后台将func()函数执行完毕。<br>小提示：this_thread命名空间C++11标准定义了this_thread命名空间，该空间提供了一组获取当前线程信息的函数，分别如下所示。<br>（1）get_id()函数：获取当前线程id。<br>（2）yeild()函数：放弃当前线程的执行权。操作系统会调度其他线程执行未用完的时间片，当时间片用完之后，当前线程再与其他线程一起竞争CPU资源。<br>（3）sleep_until()函数：让当前线程休眠到某个时间点。<br>（4）sleep_for()函数：让当前线程休眠一段时间。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在并行编程中，为避免多线程对共享资源的竞争导致程序错误，线程会对共享资源进行保护。通常的做法是对共享资源上锁，当线程修改共享资源时，会获取锁将共享资源锁上，在操作完成之后再进行解锁。加锁之后，共享资源只能被当前线程操作，其他线程只能等待当前线程解锁退出之后再获取资源。为此，C++11标准提供了互斥锁mutex，用于为共享资源加锁，让多个线程互斥访问共享资源。mutex是一个类模板，定义在mutex标准库中，使用时要包含mutex头文件。mutex类模板定义了三个常用的成员函数：lock()函数、unlock()函数和try_lock()函数，用于实现上锁、解锁功能。下面分别介绍这三个函数。（1）lock()函数：用于给共享资源上锁。如果共享资源已经被其他线程上锁，则当前线程被阻塞；如果共享资源已经被当前线程上锁，则产生死锁。（2）unlock()函数：用于给共享资源解锁，释放当前线程对共享资源的所有权。（3）try_lock()函数：也用于给共享资源上锁，但它是尝试上锁，如果共享资源已经被其他线程上锁，try_lock()函数返回false，当前线程并不会被阻塞，而是继续执行其他任务；如果共享资源已经被当前线程上锁，则产生死锁。下面通过案例演示C++11标准中mutex的上锁、解锁的过程，如例10-11所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁mtx</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();                                          <span class="comment">//上锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; <span class="comment">//获取当前线程id</span></span><br><span class="line">    num++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread ths[<span class="number">3</span>]; <span class="comment">//定义线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ths[i] = <span class="built_in">thread</span>(func); <span class="comment">//分配线程任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;th : ths)</span><br><span class="line">        th.<span class="built_in">join</span>(); <span class="comment">//将线程加入程序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果注释掉第9行和第13行代码，即不给func()函数中的操作上锁，则三个线程会同时执行func()函数，输出的结果就会超出预期。例如，连续输出三个线程id，或者先输出counter值为3，再输出counter值为1。如果修改例10-11，调用try_lock()函数为func()函数上锁，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (mtx.<span class="built_in">try_lock</span>())    <span class="comment">//调用try_lock()函数加锁 </span></span><br><span class="line"> &#123; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; </span><br><span class="line">      num++; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl; </span><br><span class="line">      mtx.<span class="built_in">unlock</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="lock-guard和unique-lock"><a href="#lock-guard和unique-lock" class="headerlink" title="lock_guard和unique_lock"></a>lock_guard和unique_lock</h3><p>在10.4.2节我们学习了互斥锁mutex，通过mutex的成员函数为共享资源上锁、解锁，能够保证共享资源的安全性。但是，通过mutex上锁之后必须要手动解锁，如果忘记解锁，当前线程会一直拥有共享资源的所有权，其他线程不得访问共享资源，造成程序错误。此外，如果程序抛出了异常，mutex对象无法正确地析构，导致已经被上锁的共享资源无法解锁。为此，C++11标准提供了RAII技术的类模板：lock_guard和unique_lock。lock_guard和unique_lock可以管理mutex对象，自动为共享资源上锁、解锁，不需要程序设计者手动调用mutex的lock()函数和unlock()函数。即使程序抛出异常，lock_guard和unique_lock也能保证mutex对象正确解锁，在简化代码的同时，也保证了程序在异常情况下的安全性。下面分别介绍lock_guard和unique_lock。</p>
<h4 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h4><p>在10.4.2节我们学习了互斥锁mutex，通过mutex的成员函数为共享资源上锁、解锁，能够保证共享资源的安全性。但是，通过mutex上锁之后必须要手动解锁，如果忘记解锁，当前线程会一直拥有共享资源的所有权，其他线程不得访问共享资源，造成程序错误。此外，如果程序抛出了异常，mutex对象无法正确地析构，导致已经被上锁的共享资源无法解锁。为此，C++11标准提供了RAII技术的类模板：lock_guard和unique_lock。lock_guard和unique_lock可以管理mutex对象，自动为共享资源上锁、解锁，不需要程序设计者手动调用mutex的lock()函数和unlock()函数。即使程序抛出异常，lock_guard和unique_lock也能保证mutex对象正确解锁，在简化代码的同时，也保证了程序在异常情况下的安全性。下面分别介绍lock_guard和unique_lock。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁mtx</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;                       <span class="comment">//创建lock_guard对象locker</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; <span class="comment">//获取当前线程id</span></span><br><span class="line">    num++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread ths[<span class="number">3</span>]; <span class="comment">//定义线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ths[i] = <span class="built_in">thread</span>(func); <span class="comment">//分配线程任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;th : ths)</span><br><span class="line">        th.<span class="built_in">join</span>(); <span class="comment">//将线程加入程序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，lock_guard对象只是简化了mutex对象的上锁、解锁过程，但它并不负责mutex对象的生命周期。在例10-12中，当func()函数执行结束时，lock_guard对象locker析构，mutex对象mtx自动解锁，线程释放func()函数的所有权，但对象mtx的生命周期并没有结束。</p>
<h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><p>lock_guard只定义了构造函数和析构函数，没有定义其他成员函数，因此它的灵活性太低。为了提高锁的灵活性，C++11标准提供了另外一个RAII技术的类模板unique_lock。unique_lock与lock_guard相似，都可以很方便地为共享资源上锁、解锁，但unique_lock提供了更多的成员函数，它有多个重载的构造函数，而且unique_lock对象支持移动构造和移动赋值。需要注意的是，unique_lock对象不支持拷贝和赋值。下面简单介绍几个常用的成员函数。（1）lock()函数：为共享资源上锁，如果共享资源已经被其他线程上锁，则当前线程被阻塞；如果共享资源已经被当前线程上锁，则产生死锁。（2）try_lock()函数：尝试上锁，如果共享资源已经被其他线程上锁，该函数返回false，当前线程继续其他任务；如果共享资源已经被当前线程上锁，则产生死锁。（3）try_lock_for()函数：尝试在某个时间段内获取互斥锁，为共享资源上锁，如果在时间结束之前一直未获取互斥锁，则线程会一直处于阻塞状态。（4）try_lock_until()函数：尝试在某个时间点之前获取互斥锁，为共享资源上锁，如果到达时间点之前一直未获取互斥锁，则线程会一直处于阻塞状态。（5）unlock()函数：解锁。正是因为提供了更多的成员函数，unique_lock才能够更灵活地实现上锁和解锁控制，例如，转让mutex对象所有权（移动赋值）、在线程等待时期解锁等。但是，更灵活的代价就是空间开销也更大，运行效率相对较低。在编程过程中，如果只是为了保证数据同步，那么lock_guard完全能够满足使用需求。如果除了同步，还需要结合条件变量进行线程阻塞，则要选择unique_lock。小提示：RAII技术RAII（Resource Acquisition Is Initialization，资源获取初始化）是C++语言管理资源、避免内存泄漏的一个常用技术。RAII技术利用C++创建的对象最终被销毁的原则，在创建对象时获取对应的资源，在对象生命周期内控制对资源的访问，使资源始终有效。当对象生命周期结束后，释放资源。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="*条件变量"></a>*条件变量</h4><p>在多线程编程中，多个线程可能会因为竞争资源而导致死锁，一旦产生死锁，程序将无法继续运行。为了解决死锁问题，C++11标准引入了条件变量condition_variable类模板，用于实现线程间通信，避免产生死锁。condition_variable类模板定义了很多成员函数，用于实现进程通信的功能，下面介绍几个常用的成员函数。（1）wait()函数：会阻塞当前线程，直到其他线程调用唤醒函数将线程唤醒。当线程被阻塞时，wait()函数会释放互斥锁，使得被阻塞在互斥锁上的其他线程能够获取互斥锁以继续执行代码。一旦当前线程被唤醒，它就会重新夺回互斥锁。wait()函数有两种重载形式，函数声明分别如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Predicate&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred</span></span></span><br></pre></td></tr></table></figure>
<p>第一种重载形式称为无条件阻塞，它以mutex对象作为参数，在调用wait()函数阻塞当前线程时，wait()函数会在内部自动通过mutex对象调用unlock()函数解锁，使得阻塞在互斥锁上的其他线程恢复执行。第二种重载形式称为有条件阻塞，它有两个参数，第一个参数是mutex对象，第二个参数是一个条件，只有当条件为false时，调用wait()函数才能阻塞当前线程；在收到其他线程的通知后，只有当条件为true时，当前线程才能被唤醒。（2）wait_for()函数：也用于阻塞当前线程，但它可以指定一个时间段，当收到通知或超过时间段时，线程就会被唤醒。wait_for()函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv_status wait_for（unique_lock&lt;mutex&gt;＆ lck， </span><br><span class="line">                      <span class="type">const</span> chrono :: duration&lt;Rep，Period&gt;＆ rel_time）; </span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，wait_for()函数第一个参数为unique_lock对象，第二个参数为设置的时间段。函数返回值为cv_status类型，cv_status是C++11标准定义的枚举类型，它有两个枚举值：no-tim eout和tim eout。no-tim eout表示没有超时，即在规定的时间段内，当前线程收到了通知；tim eout表示超时。（3）wait_until()函数：可以指定一个时间点，当收到通知或超过时间点时，线程就会被唤醒。wait_until()函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv_status <span class="title">wait_until</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_tim</span></span></span><br><span class="line"><span class="params"><span class="function">                    </span></span></span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，wait_until()函数第一个参数为unique_lock对象，第二个参数为设置的时间点。函数返回值为cv_status类型。（4）notify_one()函数：用于唤醒某个被阻塞的线程。如果当前没有被阻塞的线程，则该函数什么也不做；如果有多个被阻塞的线程，则唤醒哪一个线程是随机的。notify_one()函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>在上述函数声明中，notify_one()函数没有参数，没有返回值，并且不抛出任何异常。（5）notify_all()函数：用于唤醒所有被阻塞的线程。如果当前没有被阻塞的线程，则该函数什么也不做。notify_all()函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>条件变量用于实现线程间通信，防止死锁发生，为了实现更灵活的上锁、解锁控制，条件变量通常与unique_lock结合使用。下面通过案例演示条件变量在并行编程中的使用，如例10-13所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; products;     <span class="comment">//创建队列容器products</span></span><br><span class="line">mutex mtx;               <span class="comment">//创建互斥锁mtx</span></span><br><span class="line">condition_variable cvar; <span class="comment">//定义条件变量cvar</span></span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;       <span class="comment">//定义变量done，表示产品是否生产完毕</span></span><br><span class="line"><span class="type">bool</span> notified = <span class="literal">false</span>;   <span class="comment">//定义变量notified，表示是否唤醒线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span>           <span class="comment">//生产函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//让当前线程休眠2s</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//创建unique_lock对象locker，获取互斥锁mtx</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">//生产产品，并将产品存放到products容器中</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;生产产品&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        products.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">//将notified值设置为true</span></span><br><span class="line">        notified = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//唤醒一个线程</span></span><br><span class="line">        cvar.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;       <span class="comment">//生产完毕，设置done的值为true</span></span><br><span class="line">    cvar.<span class="built_in">notify_one</span>(); <span class="comment">//唤醒一个线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span> <span class="comment">//定义消费函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建unique_lock对象locker，获取互斥锁mtx</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) <span class="comment">//判断产品是否生产完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!notified) <span class="comment">//避免虚假唤醒</span></span><br><span class="line">        &#123;</span><br><span class="line">            cvar.<span class="built_in">wait</span>(locker); <span class="comment">//继续阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!products.<span class="built_in">empty</span>()) <span class="comment">//如果products容器不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//消费产品</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;消费产品&quot;</span> &lt;&lt; products.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">            products.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        notified = <span class="literal">false</span>; <span class="comment">//消费完之后，将notified的值设置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">producer</span><span class="params">(produce)</span></span>; <span class="comment">//创建生产线程</span></span><br><span class="line">    <span class="function">thread <span class="title">consumer</span><span class="params">(consume)</span></span>; <span class="comment">//创建消费线程</span></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果为：生产线程每生产一个产品，消费线程就消费一个产品。生产线程每生产完一个产品，就会将notified的值设置为true，然后通过条件变量cvar调用notify_one()函数唤醒消费线程消费产品。</p>
<h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>在并行编程中，共享资源同时只能有一个线程进行操作，这些最小的不可并行执行的操作称为原子操作。原子操作都是通过上锁、解锁实现的，虽然使用lock_guard和unique_lock简化了上锁、解锁过程，但是由于上锁、解锁过程涉及许多对象的创建和析构，内存开销太大。为了减少多线程的内存开销，提高程序运行效率，C++11标准提供了原子类型atom ic。atom ic是一个类模板，它可以接受任意类型作为模板参数。创建的atom ic对象称为原子变量，使用原子变量就不需要互斥锁保护该变量进行的操作了。在使用原子类型之前来看一个案例，如例10-14所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num++; <span class="comment">//通过for循环修改num的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>; <span class="comment">//创建线程t1执行func()函数</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>; <span class="comment">//创建线程t2执行func()函数</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例10-15程序运行过程中，线程t1与线程t2交叉执行func()函数，修改num的值，并不是一个线程先执行完成所有for循环。输出num值之后，另一个线程才能去执行for循环进行修改。因此，第一次输出的num值并不是100000，但最终结果是正确的。原子变量只保证“num++”是原子操作（第10行代码），使得原子操作颗粒度更细（例10-14中，原子操作为第10～14行代码）。它相当于是在“num++”操作上上了锁，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;  <span class="comment">//加锁 </span></span><br><span class="line">     num++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，在for循环内部上了互斥锁，循环结束，locker对象失效。如果有多个线程修改num，则多个线程会交叉修改num的值。但是，相比于上锁，原子类型实现的是无锁编程，内存开销小，程序的运行效率会得到极大提高，并且代码更简洁。</p>
<h2 id="支持更多扩展"><a href="#支持更多扩展" class="headerlink" title="支持更多扩展"></a>支持更多扩展</h2><h3 id="原生字符串"><a href="#原生字符串" class="headerlink" title="原生字符串"></a>原生字符串</h3><p>在传统C++编程中，编写一个包含特殊字符的字符串是一件非常麻烦的事情。例如，输出一个包含HTM L文本的字符串，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;\ </span></span><br><span class="line"><span class="string">        &lt;html&gt;\ </span></span><br><span class="line"><span class="string">        &lt; head &gt;\ </span></span><br><span class="line"><span class="string">        &lt;title&gt;&lt;/title&gt;\ </span></span><br><span class="line"><span class="string">        &lt;script type = \&quot;text/javascript\&quot;&gt;\ </span></span><br><span class="line"><span class="string">        if(null)\ </span></span><br><span class="line"><span class="string">            alert(\&quot;null为真\&quot;);\ </span></span><br><span class="line"><span class="string">        else\ </span></span><br><span class="line"><span class="string">            alert(\&quot;null为假\&quot;);\ </span></span><br><span class="line"><span class="string">        &lt;/script&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/head&gt;\ </span></span><br><span class="line"><span class="string">        &lt;body&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/body&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/html&gt;\ </span></span><br><span class="line"><span class="string">        &quot;</span>; </span><br></pre></td></tr></table></figure>
<p>在上述代码中，字符串s包含HTM L文本，在每次换行处和双引号前都需要添加转义字符，而且其输出格式也无法达到预期的整齐。为此，C++11标准提供了对原生字符串的支持。所谓原生字符串，就是“所见即所得”，不需要在字符串中添加转义字符或其他的格式控制字符调整字符串的格式。原生字符串的定义很简单，语法格式如下所示：<br>R”(字符串)”;<br>在上述格式中，字母R表示这是一个原生字符串，后面是一对双引号，双引号中有一对小括号，字符串就放在小括号中。这样定义的字符串，字符串中所有的字符都保持最原始的字面意思。重新定义包含HTM L文本的字符串s为原生字符串，示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">R&quot;( </span></span><br><span class="line"><span class="string">        &lt;html&gt; </span></span><br><span class="line"><span class="string">        &lt;head&gt; </span></span><br><span class="line"><span class="string">        &lt;title&gt;&lt;/title&gt; </span></span><br><span class="line"><span class="string">        &lt;script type=&quot;text/javascript&quot;&gt; </span></span><br><span class="line"><span class="string">            if(null) </span></span><br><span class="line"><span class="string">                alert(&quot;null为真&quot;); </span></span><br><span class="line"><span class="string">            else </span></span><br><span class="line"><span class="string">                alert(&quot;null为假&quot;); </span></span><br><span class="line"><span class="string">        &lt;/script&gt; </span></span><br><span class="line"><span class="string">        &lt;/head&gt; </span></span><br><span class="line"><span class="string">        &lt;body&gt; </span></span><br><span class="line"><span class="string">        &lt;/body&gt; </span></span><br><span class="line"><span class="string">        &lt;/html&gt; </span></span><br><span class="line"><span class="string">        )&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，字符串s为原生字符串，不必在换行和双引号前再添加转义字符，而且在输出时，输出格式就是字符串所定义的格式。需要注意的是，在原生字符串中，所有具有特殊意义的字符都不再起作用。</p>
<h4 id="Unicode编码支持"><a href="#Unicode编码支持" class="headerlink" title="Unicode编码支持"></a>Unicode编码支持</h4><p>为了支持Unicode编码，C++11标准提供了两个新的内置数据类型，以存储不同编码长度的Unicode数据。（1）char16_t：用于存储UTF-16编码的Unicode数据，所占内存大小为2字节。（2）char32_t：用于存储UTF-32编码的Unicode数据，所占内存大小为4字节。对于UTF-8编码的Unicode数据，C++11标准仍然采用8字节大小的字符数组进行存储。为了区分不同编码方式的Unicode数据，C++11标准还定义了一些前缀，用于告知编译器按照什么样的编码方式编译这些数据，分别如下所示：u8：表示UTF-8编码方式。u：表示UTF-16编码方式。U：表示UTF-32编码方式。再加上wchar_t类型数据的前缀“L”，以及普通字符串字面常量，C++11一共有五种声明字符串的方式。下面通过案例演示C++11标准中字符串的声明方式，如例10-16所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通字符数组</span></span><br><span class="line">    <span class="type">char</span> arr1[] = <span class="string">&quot;你好，祖国&quot;</span>;</span><br><span class="line">    <span class="comment">// wchar_t类型数组</span></span><br><span class="line">    <span class="type">wchar_t</span> arr2[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-8编码方式</span></span><br><span class="line">    <span class="type">char</span> arr3[] = <span class="string">u8&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-16编码方式</span></span><br><span class="line">    <span class="type">char16_t</span> arr4[] = <span class="string">u&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-32编码方式</span></span><br><span class="line">    <span class="type">char32_t</span> arr5[] = <span class="string">U&quot;hello 和\u4f60\u597d\u554a&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr1:&quot;</span> &lt;&lt; arr1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr2:&quot;</span> &lt;&lt; arr2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr3:&quot;</span> &lt;&lt; arr3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr4:&quot;</span> &lt;&lt; arr4 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr5:&quot;</span> &lt;&lt; arr5 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新增的库"><a href="#新增的库" class="headerlink" title="新增的库"></a>新增的库</h3><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>标准库tuple中定义了tuple类模板，tuple类模板可以存储任意多个不同类型的值。示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">double</span>, string &gt; t= &#123;<span class="number">10</span>, <span class="number">3.6</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个tuple对象t，对象t中存储了三个值，分别是int类型的10、double类型的3.6和string类型的“hello”。若要获取tuple对象中的元素，可以调用std提供的函数模板get()。在调用get()函数获取tuple对象元素时，既可以通过索引获取，也可以通过类型获取，示例代码如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过索引获取 </span></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t); </span><br><span class="line"><span class="comment">//通过数据类型获取 </span></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;string&gt;(t)</span><br></pre></td></tr></table></figure>
<p>tuple还有其他很多操作，有兴趣的读者可以查阅C++标准库进行学习。</p>
<h4 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h4><p>chrono是C++11标准定义的时间库，chrono时间库的所有实现都在std::chrono命名空间中。chrono时间库定义了三个常用的类模板，分别介绍如下。<br>（1）duration：表示一段时间，如1小时、30秒等。chrono预定义了六个duration类模板的实例化对象，分别如下。hours：小时。minutes：分钟。seconds：秒。milliseconds：毫秒。microseconds：微秒。nanoseconds：纳秒。<br>（2）tim e_point：表示一个具体的时间点，如生日、飞机起飞时间等。<br>（3）system_clock：表示当前系统时钟，它提供了now()函数用于获取系统当前时间。下面通过案例演示chrono时间库的使用，如例10-17所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义duration对象oneday，表示一天</span></span><br><span class="line">    chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt; <span class="built_in">oneday</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取系统当前时间</span></span><br><span class="line">    chrono::system_clock::time_point today = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">//计算明天的时间</span></span><br><span class="line">    chrono::system_clock::time_point tomorrow = today + oneday;</span><br><span class="line">    <span class="type">time_t</span> t; <span class="comment">//创建time_t时间对象t</span></span><br><span class="line">              <span class="comment">//将对象today中的时间转换之后存储到时间对象t中</span></span><br><span class="line">    t = chrono::system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;today:&quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;t);</span><br><span class="line">    <span class="comment">//将对象tomorrow中的时间转换之后存储到时间对象t中</span></span><br><span class="line">    t = chrono::system_clock::<span class="built_in">to_time_t</span>(tomorrow);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tomorrow:&quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><p>regex标准库提供了对正则表达式的支持。regex标准库提供了regex类模板，在构造regex对象时，以一个正则表达式作为参数。为了处理正则表达式操作，C++11标准还提供了很多函数，下面简单介绍两个比较常用的匹配函数。（1）regex_m atch()函数：将字符串与正则表达式匹配，匹配成功返回true，匹配失败返回false。需要注意的是，regex_m atch()函数在匹配的时候，需要整个字符串匹配成功才能返回true。（2）regex_search()函数：在字符串中查找与正则表达式匹配的子串，查找成功返回true，查找失败返回false。regex_search()函数只要求字符串包含符合正则表达式的子串即可。regex_m atch()函数和regex_search()函数用法示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回false </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_search</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回true </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;1&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回true </span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;hello,China&quot;</span>;   <span class="comment">//定义字符串</span></span><br><span class="line">    <span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;(.&#123;5&#125;),(\\w&#123;5&#125;)&quot;</span>)</span></span>; <span class="comment">//正则表达式</span></span><br><span class="line">    smatch sm;                  <span class="comment">//创建smatch容器对象sm</span></span><br><span class="line">    <span class="built_in">regex_search</span>(s, sm, r);     <span class="comment">//调用regex_search()函数匹配</span></span><br><span class="line">                                <span class="comment">// for循环遍历容器sm，输出匹配的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sm.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; sm[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="alignof和alignas"><a href="#alignof和alignas" class="headerlink" title="alignof和alignas"></a>alignof和alignas</h3><p>C++11标准新增了alignof和alignas两个运算符。alignof运算符用于获取结构体和类的内存对齐方式，即按照多少字节对齐。alignof用法的示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">    <span class="type">int</span> b; </span><br><span class="line">    <span class="type">double</span> d; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> sex; </span><br><span class="line">&#125;; </span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(Obj) &lt;&lt; endl;  <span class="comment">//结果为8 </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(Student) &lt;&lt; endl; <span class="comment">//结果为4</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，首先定义了struct Obj结构体类型和学生类Student，然后使用alignof运算符分别获取struct Obj结构体类型和学生类Student的对齐字节。如果运行程序，会得出struct Obj结构体类型对齐字节为8，学生类Student的对齐字节为4。这是因为struct Obj结构体类型中最宽基本类型为double（8字节），学生类Student中最宽基本类型为int（4字节）。alignas运算符也用于设置结构体和类的内存对齐方式，用法也很简单。需要注意的是，在设置结构体和类的对齐方式时，对齐字节数必须是2的幂次方，并且不能小于结构体和类中最宽基本类型所占内存字节数，即不能小于默认对齐字节数。alignas用法示例代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) A    <span class="comment">//设置struct A的对齐方式为8字节 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(A) &lt;&lt; endl;   <span class="comment">//结果为8 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">1</span>) B    <span class="comment">//错误，对齐字节数小于默认对齐字节数 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">6</span>) C    <span class="comment">//错误，对齐字节数不是2的幂次方 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>在上述代码中，首先定义了struct A结构体类型（默认对齐为4字节），使用alignas运算符设置struct A结构体类型对齐方式为8字节。然后定义了struct B结构体类型，使用alignas运算符设置其对齐方式为1字节，编译器会报错，因为1字节小于struct B结构体类型的默认对齐字节数（4字节）。最后定义了struct C结构体类型，使用alignas运算符设置struct C结构体类型对齐方式为6字节，编译器会报错，因为6字节不是2的幂次方。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/18/c3/" title="第三章 运算符重载"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第三章 运算符重载</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/18/c4/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">第十章 C++11 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%B4%81%E7%9A%84%E5%8F%98%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">简洁的变成方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decltype"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nullptr"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">nullptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#default%E4%B8%8E-delete"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">&#x3D;default与&#x3D;delete</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">基于范围的for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.2.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.2.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.2.2.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.2.3.</span> <span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.4.</span> <span class="toc-text">*移动构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">move()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.2.6.</span> <span class="toc-text">完美转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.7.</span> <span class="toc-text">委托构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8C%85%E8%A3%85"><span class="toc-number">1.2.8.</span> <span class="toc-text">函数包装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">并行编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-guard%E5%92%8Cunique-lock"><span class="toc-number">1.3.3.</span> <span class="toc-text">lock_guard和unique_lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-guard"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">lock_guard</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unique-lock"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">unique_lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">*条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">原子类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%9B%B4%E5%A4%9A%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.</span> <span class="toc-text">支持更多扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.4.1.</span> <span class="toc-text">原生字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode%E7%BC%96%E7%A0%81%E6%94%AF%E6%8C%81"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Unicode编码支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%9A%84%E5%BA%93"><span class="toc-number">1.4.2.</span> <span class="toc-text">新增的库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tuple"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">tuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chrono"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">chrono</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#regex"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">regex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alignof%E5%92%8Calignas"><span class="toc-number">1.4.3.</span> <span class="toc-text">alignof和alignas</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By takisano</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>