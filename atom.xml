<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>takisano</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-12T04:52:39.630Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>takisano</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo</title>
    <link href="http://example.com/2023/11/12/1/"/>
    <id>http://example.com/2023/11/12/1/</id>
    <published>2023-11-12T04:51:09.608Z</published>
    <updated>2023-11-12T04:52:39.630Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>第一章 C++ 输出</title>
    <link href="http://example.com/2022/12/18/c1/"/>
    <id>http://example.com/2022/12/18/c1/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2023-11-12T09:15:28.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-C-输出"><a href="#第一章-C-输出" class="headerlink" title="第一章 C++ 输出"></a>第一章 C++ 输出</h1><h2 id="cout输出指定格式的数据"><a href="#cout输出指定格式的数据" class="headerlink" title="cout输出指定格式的数据"></a>cout输出指定格式的数据</h2><p>::: danger</p><p>输出时候需要引入头文件 <code>&lt;iomanip&gt;</code></p><p>:::</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;oct:&quot;</span> &lt;&lt; oct &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dec:&quot;</span> &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hex:&quot;</span> &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> f = <span class="number">3.1415926</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;默认输出：&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;格式化输出：&quot;</span> &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">7</span>) &lt;&lt; <span class="built_in">setiosflags</span>(ios::fixed) &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">3.1415</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">3.1415</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) &lt;&lt; <span class="number">3.1415</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; <span class="built_in">setiosflags</span>(ios::right) &lt;&lt; <span class="number">3.1415</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>::: danger<br>setw()函数用于指定域宽，setiosflags()函数用于设置对齐方式，setfill()用于设置填充方式<br>:::</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-C-输出&quot;&gt;&lt;a href=&quot;#第一章-C-输出&quot; class=&quot;headerlink&quot; title=&quot;第一章 C++ 输出&quot;&gt;&lt;/a&gt;第一章 C++ 输出&lt;/h1&gt;&lt;h2 id=&quot;cout输出指定格式的数据&quot;&gt;&lt;a href=&quot;#cout输出指定格式的数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第二章 类与对象</title>
    <link href="http://example.com/2022/12/18/c2/"/>
    <id>http://example.com/2022/12/18/c2/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2023-11-12T09:15:34.591Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="/2022/12/18/c1/" title="第一章 C++ 输出">第一章 C++ 输出</a></li><li><a href="/2022/12/18/c3/" title="第三章 运算符重载">第三章 运算符重载</a></li><li><a href="/2022/12/18/c2/" title="第二章 类与对象">第二章 类与对象</a></li></ol><h1 id="第二章-类与对象"><a href="#第二章-类与对象" class="headerlink" title="第二章 类与对象"></a>第二章 类与对象</h1><h2 id="创建类对象的方式"><a href="#创建类对象的方式" class="headerlink" title="创建类对象的方式"></a>创建类对象的方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">exam</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::exam</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++的考试成绩为100分！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::study</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;学习C++&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">/* 1.创建Student类对象stu */</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu._name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    stu._age = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu._name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; stu._age &lt;&lt; endl;</span><br><span class="line">    stu.<span class="built_in">study</span>();</span><br><span class="line">    stu.<span class="built_in">exam</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 2.创建Student类指针*stu1 */</span></span><br><span class="line">    Student *stu1 = <span class="keyword">new</span> Student;</span><br><span class="line">    stu1-&gt;_name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    stu1-&gt;_age = <span class="number">19</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名:&quot;</span> &lt;&lt; stu1-&gt;_name &lt;&lt; <span class="string">&quot;\t年龄:&quot;</span> &lt;&lt; stu1-&gt;_age &lt;&lt; endl;</span><br><span class="line">    stu1-&gt;<span class="built_in">study</span>();</span><br><span class="line">    stu1-&gt;<span class="built_in">exam</span>();</span><br><span class="line">    <span class="comment">//delete stu1 释放对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义学生类Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">//公有类型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">study</span><span class="params">()</span></span>;              <span class="comment">//声明表示学习的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">exam</span><span class="params">()</span></span>;               <span class="comment">//声明表示考试的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>; <span class="comment">//声明设置姓名的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>;      <span class="comment">//声明设置年龄的成员函数</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;          <span class="comment">//声明获取姓名的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span>;              <span class="comment">//声明获取年龄的成员函数</span></span><br><span class="line"><span class="keyword">private</span>:                       <span class="comment">//私有类型</span></span><br><span class="line">    string _name;              <span class="comment">//声明表示姓名的成员变量</span></span><br><span class="line">    <span class="type">int</span> _age;                  <span class="comment">//声明表示年龄的成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::study</span><span class="params">()</span> <span class="comment">//类外实现study()成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;学习C++&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::exam</span><span class="params">()</span> <span class="comment">//类外实现exam()成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++考试成绩100分&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span> <span class="comment">//类外实现setName()成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="comment">//类外实现setAge()成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;_name&quot;</span>&lt;&lt; <span class="string">&quot;年龄输入错误&quot;</span> &lt;&lt; endl;</span><br><span class="line">        _age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Student::getName</span><span class="params">()</span> <span class="comment">//类外实现getName()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::getAge</span><span class="params">()</span> <span class="comment">//类外实现getAge()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>::: danger<br>为了避免这种情况，在设计类时，要控制成员变量的访问权限，不允许外界随意访问。通过权限控制符可以限制外界对类的成员变量的访问，将对象的状态信息隐藏在对象内部，通过类提供的函数（接口）实现对类中成员的访问。在定义类时，将类中的成员变量设置为私有或保护属性，即使用private或protected关键字修饰成员变量。使用类提供的公有成员函数（public修饰的成员函数），如用于获取成员变量值的getXxx()函数和用于设置成员变量值的setXxx()函数，操作成员变量的值。<br>:::</p><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(string name)</span> <span class="comment">//类外实现setName()成员函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::getName</span><span class="params">()</span> <span class="comment">//类外实现getName()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类的成员变量为_nam e和_age，setNam e()函数和setAge()函数的形参为nam e和age，可以进行区分。如果将类的成员变量改为nam e和age，则这两个成员变量和setNam e()函数、setAge()函数的形参重名，在赋值时无法区分（nam e&#x3D;nam e，age&#x3D;age），此时可以使用this指针进行区分<br>如果类的成员函数返回值为一个对象，则可以使用return *this返回对象本身。</p></blockquote><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>（1）构造函数名必须与类名相同。<br>（2）构造函数名的前面不需要设置返回值类型。<br>（3）构造函数中无返回值，不能使用return返回。<br>（4）构造函数的成员权限控制符一般设置为<br>public</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">int</span> _hour;</span><br><span class="line">    <span class="type">int</span> _minute;</span><br><span class="line">    <span class="type">int</span> _second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _minute &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Clock::<span class="built_in">Clock</span>()</span><br><span class="line">&#123;</span><br><span class="line">    _hour = <span class="number">0</span>;</span><br><span class="line">    _minute = <span class="number">0</span>;</span><br><span class="line">    _second = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clock clk;</span><br><span class="line">    clk.<span class="built_in">showTime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">int</span> _hour;</span><br><span class="line">    <span class="type">int</span> _minute;</span><br><span class="line">    <span class="type">int</span> _second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _minute &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">         &lt;&lt; <span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; _second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span><br><span class="line">&#123;</span><br><span class="line">    _hour = hour;</span><br><span class="line">    _minute = minute;</span><br><span class="line">    _second = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Clock <span class="title">clk1</span><span class="params">(<span class="number">10</span>, <span class="number">22</span>, <span class="number">53</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Clock1:&quot;</span>;</span><br><span class="line">    clk1.<span class="built_in">showTime</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Clock <span class="title">clk2</span><span class="params">(<span class="number">23</span>, <span class="number">18</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Clock2:&quot;</span>;</span><br><span class="line">    clk2.<span class="built_in">showTime</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类方法中有输出时，主函数调用不可再使用cout输出<br>需要注意的是，在实现构造函数时，除了在函数体中初始化成员变量，还可以通过“：”运算符在构造函数后面初始化成员变量，这种方式称为列表初始化，其格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second):_hour(hour),_minute(minute),_second(second)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>没有参数，所以不能重构，一个类中智能有一个析构函数<br>①在一个函数中定义了一个对象，当函数调用结束时，对象应当被释放，对象释放之前编译器会调用析构函数释放资源。<br>②对于static修饰的对象和全局对象，只有在程序结束时编译器才会调用析构函数。<br>③对于new运算符创建的对象，在调用delete释放时，编译器会调用析构函数释放资源。<br>先构造再析构，后构造先析构（同栈）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">char</span> *_food;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rabbit</span>(string name, <span class="type">const</span> <span class="type">char</span> *pf);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">Rabbit</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Rabbit::<span class="built_in">Rabbit</span>(string name, <span class="type">const</span> <span class="type">char</span> *pf)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _name = name;</span><br><span class="line">    _food = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">memset</span>(_food, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(_food, pf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rabbit::eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; is eating &quot;</span> &lt;&lt; _food &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit::~<span class="built_in">Rabbit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用析构函数，析构&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (_food != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] _food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rabbit <span class="title">A</span><span class="params">(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;luobo&quot;</span>)</span></span>;</span><br><span class="line">    A.<span class="built_in">eat</span>();</span><br><span class="line">    <span class="function">Rabbit <span class="title">B</span><span class="params">(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;baicai&quot;</span>)</span></span>;</span><br><span class="line">    B.<span class="built_in">eat</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    构造函数名称(<span class="type">const</span> 类名&amp; 对象名)</span><br><span class="line">    &#123;</span><br><span class="line">        函数体</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>拷贝构造函数是特殊的构造函数，如果程序没有定义拷贝构造函数，C++会提供一个默认的拷贝构造函数，默认拷贝构造函数只能完成简单的赋值操作，无法完成含有堆内存成员数据的拷贝。例如，如果类中有指针类型的数据，默认的拷贝构造函数只是进行简单的指针赋值，即将新对象的指针成员指向原有对象的指针指向的内存空间，并没有为新对象的指针成员申请新空间，这种情况称为浅拷贝。浅拷贝在析构指向堆内存空间的变量时，往往会出现多次析构而导致程序错误。C++初学者自定义的拷贝构造函数往往实现的是浅拷贝。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>所谓深拷贝，就是在拷贝构造函数中完成更深层次的复制，当类中有指针成员时，深拷贝可以为新对象的指针分配一块内存空间，将数据复制到新空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 实现深拷贝 */</span></span><br><span class="line">Sheep::<span class="built_in">Sheep</span>(<span class="type">const</span> Sheep &amp;another)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _name = another._name;</span><br><span class="line">    _color = another._color;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(another._home) + <span class="number">1</span>;</span><br><span class="line">    _home = <span class="keyword">new</span> <span class="type">char</span>[len];</span><br><span class="line">    <span class="built_in">strcpy</span>(_home, another._home);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字修饰类的成员"><a href="#关键字修饰类的成员" class="headerlink" title="关键字修饰类的成员"></a>关键字修饰类的成员</h2><p>只允许类的成员函数读取成员变量的值，但不允许在成员函数内部修改成员变量的值，此时就需要使用const关键字修饰成员函数；<br>或者，类中的成员变量在多个对象之间共享，此时就需要使用static关键字修饰成员变量。</p><h3 id="const修饰类的成员"><a href="#const修饰类的成员" class="headerlink" title="const修饰类的成员"></a>const修饰类的成员</h3><p>使用const修饰的成员函数称为常成员函数。与修饰成员变量不同的是，修饰成员函数时，const位于成员函数的后面，其格式如下：<br>返回值类型 函数名() const;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">const</span> string _name;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> _age;</span><br><span class="line">    string _favFruit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string, <span class="type">int</span>, string, string);</span><br><span class="line">    ~<span class="built_in">Person</span>();</span><br><span class="line">    <span class="type">const</span> string _addr;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myInfor</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myInfor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">place</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person ::<span class="built_in">Person</span>(string name, <span class="type">int</span> age, string addr, string favFruit) : _name(name), _age(age), _addr(addr), _favFruit(favFruit)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::myInfor</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我叫&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot;今年&quot;</span> &lt;&lt; _age &lt;&lt; <span class="string">&quot;岁&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;我喜欢吃&quot;</span> &lt;&lt; _favFruit &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person ::~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::myInfor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _favFruit = <span class="string">&quot;桃子&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我叫&quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot;今年&quot;</span> &lt;&lt; _age &lt;&lt; <span class="string">&quot;岁&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;我喜欢吃&quot;</span> &lt;&lt; _favFruit &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">place</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::place</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我住在&quot;</span> &lt;&lt; _addr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;北大街&quot;</span>, <span class="string">&quot;苹果&quot;</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">myInfor</span>();</span><br><span class="line">    <span class="function"><span class="type">const</span> Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">18</span>, <span class="string">&quot;南大街&quot;</span>, <span class="string">&quot;橘子&quot;</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">myInfor</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static修饰类的成员"><a href="#static修饰类的成员" class="headerlink" title="static修饰类的成员"></a>static修饰类的成员</h3><p>static修饰的静态成员变量只能在类内部定义，在类外部初始化。静态成员变量在调用时，可以通过对象和类进行访问。由于static成员变量存储在类的外部，计算类的大小时不包含在内。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string name);</span><br><span class="line">    ~<span class="built_in">Student</span>();</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_name = name;</span><br><span class="line">    _sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student::~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::_sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">stu2</span><span class="params">(<span class="string">&quot;李四&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;人数是：&quot;</span> &lt;&lt; stu1._sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;人数是：&quot;</span> &lt;&lt; stu2._sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;人数是：&quot;</span> &lt;&lt; Student::_sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;stu1的大小是:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(stu1) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static修饰成员函数"><a href="#static修饰成员函数" class="headerlink" title="static修饰成员函数"></a>static修饰成员函数</h3><p>类中定义的普通函数只能通过对象调用，无法使用类调用。使用static修饰的成员函数，同静态成员变量一样，可以通过对象或类调用。<br>静态成员函数可以直接访问类中的静态成员变量和静态成员函数，对外提供了访问接口，实现了静态成员变量的管理。需要注意的是，静态成员函数属于类，不属于对象，没有this指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">float</span> _x;</span><br><span class="line">    <span class="type">float</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> x, <span class="type">float</span> y);</span><br><span class="line">    ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">getLen</span><span class="params">(Point &amp;p1, Point &amp;p2)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> _len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">float</span> Point::_len = <span class="number">0</span>;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">float</span> x = <span class="number">0</span>, <span class="type">float</span> y = <span class="number">0</span>) : _x(x), _y(y)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;初始化坐标点&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point::~<span class="built_in">Point</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Point::getLen</span><span class="params">(Point &amp;p1, Point &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="built_in">abs</span>(p1._x - p2._x);</span><br><span class="line">    <span class="type">float</span> y = <span class="built_in">abs</span>(p1._y - p2._y);</span><br><span class="line">    _len = <span class="built_in">sqrtf</span>(x * x + y * y);</span><br><span class="line">    <span class="keyword">return</span> _len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">6</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; Point::<span class="built_in">getLen</span>(p1, p2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static-const组合修饰类成员变量"><a href="#static-const组合修饰类成员变量" class="headerlink" title="static const组合修饰类成员变量"></a>static const组合修饰类成员变量</h3><p>使用static const修饰符组合修饰类成员，既实现了数据共享又达到了数据不被改变的目的。此时，修饰成员函数与修饰普通函数格式一样，修饰成员变量必须在类的内部进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">static</span> <span class="type">float</span> <span class="title">getLen</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">float</span> area;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">float</span> area = <span class="number">3600</span>;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> 函数返回值类型 友元函数名(形参列表);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">getArea</span><span class="params">(Circle &amp;Circle)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    <span class="type">float</span> _radius;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">float</span> radius);</span><br><span class="line">    ~<span class="built_in">Circle</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">float</span> radius = <span class="number">0</span>) : _radius(radius)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;初始化圆的半径为：&quot;</span> &lt;&lt; _radius &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle::~<span class="built_in">Circle</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getArea</span><span class="params">(Circle &amp;circle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的半径是：&quot;</span> &lt;&lt; circle._radius &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的面积是：&quot;</span> &lt;&lt; circle.PI * circle._radius * circle._radius &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;友元函数修改半径&quot;</span> &lt;&lt; endl;</span><br><span class="line">    circle._radius = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的半径是：&quot;</span> &lt;&lt; circle._radius &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Circle <span class="title">circle</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">getArea</span>(circle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">其他类的成员作为友元函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">int</span> <span class="title">B::fun</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;<span class="comment">//类B前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;<span class="comment">//声明类A是类B的友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _hour;</span><br><span class="line">    <span class="type">int</span> _minute;</span><br><span class="line">    <span class="type">int</span> _second;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">(Time&amp; time)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _year;</span><br><span class="line">        <span class="type">int</span> _month;</span><br><span class="line">        <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">&#123;</span><br><span class="line">    _year = year;</span><br><span class="line">    _month = month;</span><br><span class="line">    _day = day;</span><br><span class="line">&#125;</span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> hour ,<span class="type">int</span> minute, <span class="type">int</span> second)&#123;</span><br><span class="line">    _hour = hour;</span><br><span class="line">    _minute = minute;</span><br><span class="line">    _second = second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::showTime</span><span class="params">(Time&amp;time)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; _day &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; time._hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; time._minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; time._second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">date</span><span class="params">(<span class="number">2022</span>, <span class="number">11</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">time</span><span class="params">(<span class="number">21</span>, <span class="number">30</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">    date.<span class="built_in">showTime</span>(time);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①友元声明位置由程序设计者决定，且不受类中public、private、protected权限控制符的影响。<br>②友元关系是单向的，即类A是类B的友元，但B不是A的友元。<br>③友元关系不具有传递性，即类C是类D的友元，类E是类C的友元，但类E不是类D的友元。<br>④友元关系不能被继承。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;/2022/12/18/c1/&quot; title=&quot;第一章 C++ 输出&quot;&gt;第一章 C++ 输出&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/2022/12/18/c3/&quot; title=&quot;第三章 运算符重载&quot;&gt;第三章 运算符重载&lt;/a&gt;&lt;/li&gt;&lt;l</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第三章 运算符重载</title>
    <link href="http://example.com/2022/12/18/c3/"/>
    <id>http://example.com/2022/12/18/c3/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2023-11-12T09:15:38.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-运算符重载"><a href="#第三章-运算符重载" class="headerlink" title="第三章 运算符重载"></a>第三章 运算符重载</h1><h2 id="运算符重载的语法"><a href="#运算符重载的语法" class="headerlink" title="运算符重载的语法"></a>运算符重载的语法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span> 运算符名称(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a) <span class="type">const</span>;</span><br><span class="line">    A <span class="keyword">operator</span>-(<span class="type">const</span> A &amp;a) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(_x,_y)=&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; _y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>((_x + a._x), (_y + a._y));</span><br><span class="line">&#125;</span><br><span class="line">A A::<span class="keyword">operator</span>-(<span class="type">const</span> A &amp;a) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>((_x - a._x), (_y - a._y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1:&quot;</span>;</span><br><span class="line">    a1.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2:&quot;</span>;</span><br><span class="line">    a2.<span class="built_in">show</span>();</span><br><span class="line">    a = a1 + a2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line">    a = a1 - a2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载的形式"><a href="#运算符重载的形式" class="headerlink" title="运算符重载的形式"></a>运算符重载的形式</h3><p>左操作数.运算符重载函数(右操作数);<br>a1.operator+(a2);<br>操作数.运算符重载函数();<br>ClassName operator++();&#x2F;&#x2F;重载符前置++<br>ClassName operator++(int);&#x2F;&#x2F;重载运算符后置++</p><h3 id="重载为类的友元函数"><a href="#重载为类的友元函数" class="headerlink" title="重载为类的友元函数"></a>重载为类的友元函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> 返回值类型 <span class="keyword">operator</span> 运算符(参数列表)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a1, <span class="type">const</span> A &amp;a2);</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>-(<span class="type">const</span> A &amp;a1, <span class="type">const</span> A &amp;a2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::show</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(_x,_y)&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot;,&quot;</span>&lt;&lt;_y</span><br><span class="line">         &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a1, <span class="type">const</span> A &amp;a2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a1._x + a2._x, a1._y + a2._y);</span><br><span class="line">&#125;</span><br><span class="line">A <span class="keyword">operator</span>-(<span class="type">const</span> A &amp;a1, <span class="type">const</span> A &amp;a2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>(a1._x - a2._x, a1._y - a2._y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1:&quot;</span>;</span><br><span class="line">    a1.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a2:&quot;</span>;</span><br><span class="line">    a2.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    a = a1 + a2;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a:&quot;</span>;</span><br><span class="line">    a = a1 - a2;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入-输出运算符重载"><a href="#输入-输出运算符重载" class="headerlink" title="输入&#x2F;输出运算符重载"></a>输入&#x2F;输出运算符重载</h2><p>ostream &amp;operator&lt;&lt;(ostream &amp;, const 类对象引用);<br>istream &amp;operator&gt;&gt;(istream &amp;, 类对象引用);<br>输出运算符“&lt;&lt;”重载的第一个参数是ostream对象引用，该对象引用不能使用const修饰，第二个参数是输出对象的const引用。输入运算符“&gt;&gt;”重载的第一个参数是istream对象引用，第二个参数是要向其中存入数据的对象，该对象不能使用const修饰。变量不能私有化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> A &amp;a);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(ostream &amp;is, A &amp;a);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出流输出:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span></span><br><span class="line">       &lt;&lt; a._x</span><br><span class="line">       &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">       &lt;&lt; a._y</span><br><span class="line">       &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt; a._x &gt;&gt; a._y;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a1:&quot;</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重新输入a1的数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; a1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重新输入后a1：&quot;</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> id ,<span class="type">double</span> score):_id(id),_score(score)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">double</span> _score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1._score == s2._score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1._score != s2._score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1._score &gt; s2._score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student &amp;s1, <span class="type">const</span> Student &amp;s2)&#123;</span><br><span class="line">    <span class="keyword">return</span> s1._score &lt; s2._score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::dis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;学号&quot;</span> &lt;&lt; _id &lt;&lt; <span class="string">&quot;成绩&quot;</span> &lt;&lt; _score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">1001</span>,<span class="number">98</span>)</span>,<span class="title">s2</span><span class="params">(<span class="number">1002</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;比较两名学生的成绩：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (s1&gt;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        s1.<span class="built_in">dis</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1&lt;s2)</span><br><span class="line">    &#123;</span><br><span class="line">        s2.<span class="built_in">dis</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;两名学生成绩相同&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>对于赋值运算符来说，如果不重载，类会自动提供一个赋值运算符。这个默认的赋值运算符和默认的拷贝构造函数一样，实现的是浅拷贝。若数据成员中有指针，则默认的赋值运算符不能满足要求，会出现重析构的现象，这时就需要重载赋值运算符，实现深拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assign</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *url;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Assign</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *url); <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Assign</span>(<span class="type">const</span> Assign &amp;temp);                <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">Assign</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] name;</span><br><span class="line">        <span class="keyword">delete</span>[] url;</span><br><span class="line">    &#125;</span><br><span class="line">    Assign &amp;<span class="keyword">operator</span>=(Assign &amp;temp); <span class="comment">//赋值运算符重载</span></span><br><span class="line">&#125;;</span><br><span class="line">Assign::<span class="built_in">Assign</span>(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *url)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>-&gt;url = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(url) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (name)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    <span class="keyword">if</span> (url)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;url, url);</span><br><span class="line">&#125;</span><br><span class="line">Assign::<span class="built_in">Assign</span>(<span class="type">const</span> Assign &amp;temp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(temp.name) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>-&gt;url = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(temp.url) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (name)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, temp.name);</span><br><span class="line">    <span class="keyword">if</span> (url)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;url, temp.url);</span><br><span class="line">&#125;</span><br><span class="line">Assign &amp;Assign::<span class="keyword">operator</span>=(Assign &amp;temp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">    <span class="keyword">delete</span>[] url; <span class="comment">//先释放原来空间，再重新申请</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(temp.name) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>-&gt;url = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(temp.url) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (name)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, temp.name);</span><br><span class="line">    <span class="keyword">if</span> (url)</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;url, temp.url);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Assign <span class="title">a</span><span class="params">(<span class="string">&quot;传智播客&quot;</span>, <span class="string">&quot;http://net.itcast.cn/&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a对象：&quot;</span> &lt;&lt; a.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a.url &lt;&lt; endl;</span><br><span class="line">    <span class="function">Assign <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">//用a对象初始化b，调用的是拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b对象：&quot;</span> &lt;&lt; b.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.url &lt;&lt; endl;</span><br><span class="line">    <span class="function">Assign <span class="title">c</span><span class="params">(<span class="string">&quot;黑马训练营&quot;</span>, <span class="string">&quot;http://www.itheima.com/&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c对象：&quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c.url &lt;&lt; endl;</span><br><span class="line">    b = c; <span class="comment">//调用赋值重载函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b对象：&quot;</span> &lt;&lt; b.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.url &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符重载"><a href="#下标运算符重载" class="headerlink" title="下标运算符重载"></a>下标运算符重载</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span>[](参数列表)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tag</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">int</span> n);</span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">const</span> <span class="type">char</span> *src);</span><br><span class="line">    ~<span class="built_in">Tag</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> &amp;<span class="keyword">operator</span>[](<span class="type">int</span> n);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            cout &lt;&lt; buf[i];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Tag::<span class="built_in">Tag</span>(<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    size = n;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">    *(buf + size) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Tag::<span class="built_in">Tag</span>(<span class="type">const</span> <span class="type">char</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(src) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, src);</span><br><span class="line">    size = <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> &amp;Tag::<span class="keyword">operator</span>[](<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size || n &lt; <span class="number">0</span>) <span class="comment">//检查数组是否越界</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;越界&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *(buf + n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Tag <span class="title">arr1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        arr1[i] = <span class="number">65</span> + i; <span class="comment">//调用“[]”运算符重载函数赋值</span></span><br><span class="line">    arr1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">Tag <span class="title">arr2</span><span class="params">(<span class="string">&quot;Itcast!&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; arr2[<span class="number">6</span>] &lt;&lt; endl;</span><br><span class="line">    arr2[<span class="number">6</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    arr2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 数据类型名()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型转换函数以operator关键字开头，这一点和运算符重载规律一致。从类型转换函数格式可以看出，在重载的数据类型名前不能指定返回值类型，返回值的类型由重载的数据类型名确定，且函数没有参数。由于类型转换函数的主体是本类的对象，因此只能将类型转换函数重载为类的成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _id;</span><br><span class="line">    <span class="type">char</span> *_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string id, <span class="type">const</span> <span class="type">char</span> *name) : _id(id)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_name, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span> *() <span class="comment">//类型转换运算符重载函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; _id &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;1001&quot;</span>, <span class="string">&quot;小明&quot;</span>)</span></span>; <span class="comment">//调用普通构造函数创建对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1: &quot;</span>;</span><br><span class="line">    s1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="type">char</span> *ch = s1; <span class="comment">//调用类型转换函数</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换构造函数<br>转换构造函数指的是构造函数只有一个参数，且参数不是本类的const引用。用转换构造函数不仅可以将一个标准类型数据转换为类对象，也可以将另一个类的对象转换为转换构造函数所在的类对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B &amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从B类类型到A类类型的转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solid</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solid</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z) : _x(x), _y(y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;三维坐标:&quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; _y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; _z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Point</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x, _y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x, <span class="type">int</span> y) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Solid &amp;another)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_x = another._x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_y = another._y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;平面坐标：&quot;</span> &lt;&lt; _x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; _y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始坐标&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">Solid <span class="title">s</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    s.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;三维转换平面坐标&quot;</span> &lt;&lt; endl;</span><br><span class="line">    p = s;</span><br><span class="line">    p.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="仿函数——重载“（）”运算符"><a href="#仿函数——重载“（）”运算符" class="headerlink" title="仿函数——重载“（）”运算符"></a>仿函数——重载“（）”运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Show</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">float</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Show s1;</span><br><span class="line">    <span class="built_in">s1</span>(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">s1</span>(<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="智能指针——重载“-”和“-”运算符"><a href="#智能指针——重载“-”和“-”运算符" class="headerlink" title="智能指针——重载“*”和“-&gt;”运算符"></a>智能指针——重载“*”和“-&gt;”运算符</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-运算符重载&quot;&gt;&lt;a href=&quot;#第三章-运算符重载&quot; class=&quot;headerlink&quot; title=&quot;第三章 运算符重载&quot;&gt;&lt;/a&gt;第三章 运算符重载&lt;/h1&gt;&lt;h2 id=&quot;运算符重载的语法&quot;&gt;&lt;a href=&quot;#运算符重载的语法&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c10/"/>
    <id>http://example.com/2022/12/18/c10/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:45.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-C-11-新特性"><a href="#第十章-C-11-新特性" class="headerlink" title="第十章 C++11 新特性"></a>第十章 C++11 新特性</h1><h2 id="简洁的变成方式"><a href="#简洁的变成方式" class="headerlink" title="简洁的变成方式"></a>简洁的变成方式</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>在C++11标准之前，auto关键字已经存在，其作用是限定变量的作用域。在C++11标准中，auto被赋予了新的功能，使用它可以让编译器自动推导出变量的类型。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x =<span class="number">10</span> <span class="comment">//变量x为int类型</span></span><br></pre></td></tr></table></figure><p>在上述代码中，使用auto定义了变量x，并赋值为10，则变量x的类型由它的初始化值决定。由于编译器根据初始化值推导并确定变量的类型，因此auto修饰的变量必须初始化。除了修饰变量，auto还可以作为函数的返回值，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//……功能代码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，auto可以修饰函数的返回值，但是auto不能修饰函数参数。除了修饰变量、函数返回值等，auto最大的用途就是简化模板编程中的代码，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> value = m.<span class="built_in">begin</span>(); value != m.<span class="built_in">end</span>(); value++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用auto，则代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">map&lt;string, vector&lt;<span class="type">int</span>&gt;&gt;::iterator value;</span><br><span class="line"><span class="keyword">for</span> (value = m.<span class="built_in">begin</span>(); value != m.<span class="built_in">end</span>(); value++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在模板编程中，变量的类型依赖于模板参数，有时很难确定变量的类型。当不确定变量类型时，可以使用auto关键字解决，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(T1 x, T2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = x * y; <span class="comment">//使用auto修饰变量result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h4><p>decltype关键字是C++11标准新增的关键字，功能与auto关键字类似，也是在编译时期进行类型推导，但decltype的用法与auto不同，decltype关键字的使用格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure><p>在上述格式中，decltype关键字会根据表达式的结果推导出数据类型，但它并不会真正计算出表达式的值。需要注意的是，decltype关键字的参数表达式不能是具体的数据类型。decltype关键字的用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> b; </span><br><span class="line"><span class="type">float</span> f; </span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(a+b)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//推导结果：int </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(a+f)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//推导结果：float </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(<span class="keyword">decltype</span>(<span class="type">int</span>)).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">//错误，不能通过编译</span></span><br></pre></td></tr></table></figure><p>在程序设计中，可以使用decltype关键字推导出的类型定义新变量，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">int</span> b; </span><br><span class="line"><span class="type">float</span> f; </span><br><span class="line"><span class="keyword">decltype</span>(a + b) x;        <span class="comment">//定义int类型变量x </span></span><br><span class="line"><span class="keyword">decltype</span>(a + f) y;        <span class="comment">//定义float类型变量y</span></span><br></pre></td></tr></table></figure><p>decltype关键字最为强大的功能是在泛型编程中，与auto关键字结合使用推导函数返回值类型。auto作为函数返回值占位符，-&gt;decltype()放在函数后面用于推导函数返回值类型。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">multiply</span><span class="params">(T1 x, T2 y)</span>-&gt;<span class="title">decltype</span><span class="params">(x * y)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><p>在C语言中，为避免野指针的出现，通常使用NULL为指针赋值。C语言中NULL的定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br></pre></td></tr></table></figure><p>由上述定义可知，NULL是一个<code>void*</code>类型的指针，其值为0。在使用NULL给其他指针赋值时，发生了隐式类型转换，即将<code>void*</code>类型指针转换为要赋值的指针类型。NULL的值被定义为字面常量0，这样会导致指针在使用过程中产生一些不可避免的错误。例如，有两个函数，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> *p)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br></pre></td></tr></table></figure><p>在上述代码中，有两个重载函数func()，如果在调用第一个func()函数时，传入的第二个参数为0或NULL，则编译器总会调用第二个func()函数，即两个参数都是int类型的函数。这就与实际想要调用的函数相违背。如果想要根据传入的参数成功调用相应的func()函数，则需要使用static_cast转换运算符将0强制转换，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);                         <span class="comment">//调用func(int a,int b) </span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(<span class="number">0</span>));    <span class="comment">//调用func(int a,int *p) </span></span><br></pre></td></tr></table></figure><p>虽然使用static_cast转换运算符解决了此问题，但是这种方式极易出错，而且会增加代码的复杂程度。为了修复上述缺陷，C++11标准引入了一个新的关键字nullptr，nullptr也表示空指针，可以为指针赋值，避免出现野指针。但是，nullptr是一个有类型的空指针常量，当使用nullptr给指针赋值时，nullptr可以隐式转换为等号左侧的指针类型。需要注意的是，nullptr只能被转换为其他指针类型，不能转换为非指针类型。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;     <span class="comment">//正确 </span></span><br><span class="line"><span class="type">int</span> x = <span class="literal">nullptr</span>;     <span class="comment">//错误，nullptr不能转换为int类型</span></span><br></pre></td></tr></table></figure><p>由于nullptr只能转换为其他指针类型，因此它能够消除字面常量0带来的二义性。在调用func()函数时，如果传入nullptr作为第二个参数，则func()函数能够被正确调用。示例代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">0</span>);      <span class="comment">//调用func(int a,int b) </span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="literal">nullptr</span>);     <span class="comment">//调用func(int a,int *p)</span></span><br></pre></td></tr></table></figure><h4 id="default与-delete"><a href="#default与-delete" class="headerlink" title="&#x3D;default与&#x3D;delete"></a>&#x3D;default与&#x3D;delete</h4><p>构造函数、析构函数、拷贝构造函数等是类的特殊成员函数，如果在类中没有显式定义这些成员函数，编译器会提供默认的构造函数、析构函数、拷贝构造函数等。但是，如果在类中显式定义了这些函数，编译器将不会再提供默认的版本。例如，定义了动物类Anim al，并且在类中显式定义了构造函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Animal</span>(string name); </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，定义了有参构造函数，则编译器不再提供默认的构造函数。如果在程序中需要调用无参构造函数，就需要程序设计者自己定义一个无参构造函数，即使这个无参构造函数体为空，并没有实现任何功能。在实际开发中，一个项目工程中的类非常多，这样做势必会增加代码量。为了使代码更简洁、高效，C++11标准引入了一个新特性，在默认函数声明后面添加“&#x3D;default”，显式地指示编译器生成该函数的默认版本。例如，在Anim al类中，使用“&#x3D;default”指示编译器提供默认的构造函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Animal</span>() = <span class="keyword">default</span>;     <span class="comment">//编译器会提供默认的构造函数 </span></span><br><span class="line"> <span class="built_in">Animal</span>(string name); </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>有时，我们不希望类的某些成员函数在类外被调用，例如，在类外禁止调用类的拷贝构造函数。在C++98标准中，通常的做法是显式声明类的拷贝构造函数，并将其声明为类的私有成员。而C++11标准提供了一种更简便的方法，在函数的声明后面加上“&#x3D;delete”，编译器就会禁止函数在类外调用，这样的函数称为已删除函数。例如，禁止调用Anim al类的拷贝构造函数，则可以声明Anim al类的拷贝构造函数，并使用“&#x3D;delete”进行修饰，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="comment">//… </span></span><br><span class="line"> <span class="built_in">Animal</span>(<span class="type">const</span> Animal&amp;) = <span class="keyword">delete</span>;   <span class="comment">//在类外禁止调用拷贝构造函数 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在上述代码中，使用“&#x3D;delete”修饰拷贝构造函数，则在Anim al类外就无法再调用拷贝构造函数了。除了修饰类的成员函数，“&#x3D;delete”还可以修饰普通函数，被“&#x3D;delete”修饰的普通函数，在程序中也会被禁止调用。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> ch)</span> </span>= <span class="keyword">delete</span>; </span><br><span class="line"><span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);       <span class="comment">//错误 </span></span><br></pre></td></tr></table></figure><p>在上述代码中，func()函数被“&#x3D;delete”修饰，当传入字符’a’调用func()函数时，编译器就会报错，提示“func()函数是已删除函数”。</p><h3 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h3><p>在传统C++中，使用for循环遍历一组数据时，必须要明确指定for循环的遍历范围，但是在很多时候，对于一个有范围的集合，明确指定遍历范围是多余的，而且容易出现错误。针对这个问题，C++11标准提出了基于范围的for循环，该for循环语句可以自动确定遍历范围。基于范围的for循环语法格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量:对象) </span><br><span class="line">&#123; </span><br><span class="line"> <span class="comment">//… </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上述语法格式中，for循环语句会遍历对象，将取到的值赋给变量，执行完循环体中的操作之后，再自动获取对象中的下一个值赋给变量，直到对象中的数据被迭代完毕。基于范围的for循环的用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:v) </span><br><span class="line"> cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式是C++11标准中非常重要的一个新特性，它用于定义匿名函数，使得代码更加灵活、简洁。lambda表达式与普通函数类似，也有参数列表、返回值类型和函数体，只是它的定义方式更简洁，并且可以在函数内部定义。lambda表达式的语法格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表)-&gt;返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure><p>根据捕获规则，捕获列表有以下五种常用的捕获形式。（1）[]：空捕获，表示lambda表达式不捕获任何变量。<br>（2）[var]：变量捕获，表示捕获局部变量var。如果捕获多个变量，变量之间用“，”分隔。<br>（3）[&amp;var]：引用捕获，表示以引用方式捕获局部变量var。<br>（4）[&#x3D;]：隐式捕获，表示捕获所有的局部变量。（5）[&amp;]：隐式引用捕获，表示以引用方式捕获所有的局部变量。<br>以上捕获方式还可以组合使用，通过组合，捕获列表可以实现更复杂的捕获功能，例如，[&#x3D;,&amp;a,&amp;b]表示以引用方式捕获变量a和变量b，以值传递方式捕获其他所有变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// lambda表达式</span></span><br><span class="line">    <span class="keyword">auto</span> f = [num](<span class="type">int</span> x) -&gt; <span class="type">int</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + num; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建vector对象v</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">54</span>, <span class="number">148</span>, <span class="number">3</span>, <span class="number">848</span>, <span class="number">2</span>, <span class="number">89</span>&#125;;</span><br><span class="line">    <span class="comment">//调用for_each()函数遍历输出v容器中的元素</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> n)</span><br><span class="line">             &#123; cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>unique_ptr智能指针主要用来代替C++98标准中的auto_ptr，它的使用方法与auto_ptr相同，创建unique_ptr智能指针对象的语法格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_prt&lt;T&gt; 智能指针对象名称(指针);</span><br></pre></td></tr></table></figure><p>在上述格式中，<code>unique_ptr&lt;T&gt;</code>是模板类型，后面是智能指针对象名称，遵守标识符命名规范。智能指针对象名称后面的小括号中的参数是一个指针，该指针是new运算符申请堆内存空间返回的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;…&#125;; </span><br><span class="line"><span class="function">unique_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br></pre></td></tr></table></figure><p>在上述代码中，第一行代码创建了一个unique_ptr智能指针对象pi，用于管理一个int类型堆内存空间指针。后两行代码创建了一个unique_ptr智能指针对象pA，用于管理一个A类型的堆内存空间指针。当程序运行结束时，即使没有delete，编译器也会调用unique_ptr模板类的析构函数释放new申请的堆内存空间。需要注意的是，使用智能指针需要包含m em ory头文件。unique_ptr智能指针对象之间不可以赋值，错误示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pt; </span><br><span class="line">pt = ps;     <span class="comment">//错误，不能对unique_ptr智能指针赋值 </span></span><br></pre></td></tr></table></figure><p>在上述代码中，直接将智能指针ps赋值给智能指针pt，编译器会报错。这是因为在unique_ptr模板类中，使用“&#x3D;delete”修饰了“&#x3D;”运算符的重载函数。之所以这样做，是因为unique_ptr在实现时是通过所有权的方式管理new对象指针的，一个new对象指针只能被一个unique_ptr智能指针对象管理，即unique_ptr智能指针拥有对new对象指针的所有权。当发生赋值操作时，智能指针会转让所有权。例如，上述代码中的pt&#x3D;ps语句，如果赋值成功，pt将拥有对new对象指针的所有权，而ps则失去所有权，指向无效的数据，成了危险的悬挂指针。如果后面程序中使用到ps，会造成程序崩溃。C++98标准中的auto_ptr就是这种实现方式，因此auto_ptr使用起来比较危险。C++11标准为了修复这种缺陷，就将unique_ptr限制为不能直接使用“&#x3D;”进行赋值。如果需要实现unique_ptr智能指针对象之间的赋值，可以调用C++标准库提供的m ove()函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">ps</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pt; </span><br><span class="line">pt = <span class="built_in">move</span>(ps);   <span class="comment">//正确，可以通过编译</span></span><br></pre></td></tr></table></figure><p>调用m ove()函数完成赋值之后，pt拥有new对象指针的所有权，而ps则被赋值为nullptr。</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr是一种智能级别更高的指针，它在实现时采用了引用计数的方式，多个shared_ptr智能指针对象可以同时管理一个new对象指针。每增加一个shared_ptr智能指针对象，new对象指针的引用计数就加1；当shared_ptr智能指针对象失效时，new对象指针的引用计数就减1，而其他shared_ptr智能指针对象的使用并不会受到影响。只有在引用计数归为0时，shared_ptr才会真正释放所管理的堆内存空间。shared_ptr与unique_ptr用法相同，创建shared_ptr智能指针对象的格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; 智能指针对象名称(指针);</span><br></pre></td></tr></table></figure><p>shared_ptr提供了一些成员函数以更方便地管理堆内存空间，下面介绍几个常用的成员函数。<br>（1）get()函数：用于获取shared_ptr管理的new对象指针，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span>; </span><br></pre></td></tr></table></figure><p>在上述函数声明中，get()函数返回一个T*类型的指针。当使用cout输出get()函数的返回结果时，会得到new对象的地址。<br>（2）use_count()函数：用于获取new对象的引用计数，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>在上述函数声明中，use_count()函数返回一个long类型的数据，表示new对象的引用计数。<br>（3）reset()函数：用于取消shared_ptr智能指针对象对new对象的引用，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><p>在上述函数声明中，reset()的声明比较简单，既没有参数也没有返回值。当调用reset()函数之后，new对象的引用计数就会减1。取消引用之后，当前智能指针对象被赋值为nullptr。下面通过案例演示shared_ptr智能指针的使用，如例10-2所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span> </span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">       <span class="comment">//创建shared_ptr智能指针对象language1、language2、language3</span></span><br><span class="line">       <span class="function">shared_ptr&lt;string&gt; <span class="title">language1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>; </span><br><span class="line">       shared_ptr&lt;string&gt; language2= language1; </span><br><span class="line">       shared_ptr&lt;string&gt; language3= language1; </span><br><span class="line">      <span class="comment">//通过智能指针对象language1、language2、language3调用get()函数 </span></span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language1: &quot;</span> &lt;&lt; language1.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language2: &quot;</span> &lt;&lt; language2.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language3: &quot;</span> &lt;&lt; language3.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span>; </span><br><span class="line">      cout &lt;&lt; language1.<span class="built_in">use_count</span>() &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language2.<span class="built_in">use_count</span>() &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language3.<span class="built_in">use_count</span>() &lt;&lt;endl; </span><br><span class="line">      language1.<span class="built_in">reset</span>(); </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;引用计数：&quot;</span>; </span><br><span class="line">      cout &lt;&lt; language1.<span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language2.<span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">      cout &lt;&lt; language3.<span class="built_in">use_count</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language1: &quot;</span> &lt;&lt; language1.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language2: &quot;</span> &lt;&lt; language2.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;language3: &quot;</span> &lt;&lt; language3.<span class="built_in">get</span>() &lt;&lt; endl; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>相比于unique_ptr与shared_ptr，weak_ptr智能指针的使用更复杂一些，它可以指向shared_ptr管理的new对象，却没有该对象的所有权，即无法通过weak_ptr对象管理new对象。shared_ptr、weak_ptr和new对象的关系示意图如图10-3所示。在图10-3中，shared_ptr对象和weak_ptr对象指向同一个new对象，但weak_ptr对象却不具有new对象的所有权。weak_ptr模板类没有提供与unique_ptr、shared_ptr相同的构造函数，因此，不能通过传递new对象指针的方式创建weak_ptr对象。weak_ptr最常见的用法是验证shared_ptr对象的有效性。weak_ptr提供了一个成员函数lock()，该函数用于返回一个shared_ptr对象，如果weak_ptr指向的new对象没有shared_ptr引用，则lock()函数返回nullptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(weak_ptr&lt;string&gt; &amp;pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过pw.lock()获取一个shared_ptr对象</span></span><br><span class="line">    shared_ptr&lt;string&gt; ps = pw.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="literal">nullptr</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;编程语言是&quot;</span> &lt;&lt; *ps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;shared_ptr智能指针失效！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义shared_ptr对象pt1与pt2</span></span><br><span class="line">    <span class="function">shared_ptr&lt;string&gt; <span class="title">pt1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;C++&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;string&gt; pt2 = pt1;</span><br><span class="line">    <span class="comment">//定义weak_ptr对象</span></span><br><span class="line">    weak_ptr&lt;string&gt; pw = pt1;</span><br><span class="line">    <span class="built_in">func</span>(pw); <span class="comment">//调用func()函数</span></span><br><span class="line">    *pt1 = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">    pt1.<span class="built_in">reset</span>(); <span class="comment">//取消pt1的引用</span></span><br><span class="line">    <span class="built_in">func</span>(pw);    <span class="comment">//调用func()函数</span></span><br><span class="line">    pt2.<span class="built_in">reset</span>(); <span class="comment">//取消pt2的引用</span></span><br><span class="line">    <span class="built_in">func</span>(pw);    <span class="comment">//调用func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过pt1修改new对象中的数据，但是，由于weak_ptr对new对象没有所有权，因此无法通过pw修改new对象中的数据。<br>提高编程效率<br>右值引用<br>在C++11标准出现之前，程序中只有左值与右值的概念，简单来说，左值就是“&#x3D;”符号左边的值，右值就是“&#x3D;”符号右边的值。区分左值与右值的一个简单、有效的方法为：可以取地址的是左值，不可以取地址的是右值。C++11标准对右值进行了更详细的划分，将右值分为纯右值与将亡值。纯右值是指字面常量、运算表达式、lambda表达式等；将亡值是那些即将被销毁却可以移动的值，如函数返回值。随着对右值的详细划分，C++11标准提出了右值引用的概念，右值引用就是定义一个标识符引用右值，右值引用通过“&amp;&amp;”符号定义，定义格式如下所示：<br>类型&amp;&amp; 引用名称&#x3D;右值;<br>在上述格式中，类型是要引用的右值的数据类型，“&amp;&amp;”符号表明这是一个右值引用，引用名称遵守标识符命名规范，“&#x3D;”符号后面是要引用的右值。下面定义一些右值引用，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; r1 = <span class="number">100</span>;   <span class="comment">//字面常量100是一个右值 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r2 = x + y;    <span class="comment">//表达式x+y是一个右值 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; r3 = <span class="built_in">sqrt</span>(<span class="number">9.0</span>);   <span class="comment">//函数返回值是一个右值</span></span><br></pre></td></tr></table></figure><p>与左值引用相同，右值引用在定义时也必须初始化。右值引用只能引用右值，不能引用左值，错误示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; a = x;     <span class="comment">//错误 </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; b = y;     <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>在上述代码中，变量x、y都是左值，因此不能将它们绑定到右值引用。需要注意的是，一个已经定义的右值引用是一个左值，即已经定义的右值引用是可以被赋值的变量，因此不能使用右值引用来引用另一个右值引用，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; m = <span class="number">100</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; n = m;     <span class="comment">//错误，m是变量，是左值，不能被绑定到右值引用n上</span></span><br></pre></td></tr></table></figure><h3 id="移动构造"><a href="#移动构造" class="headerlink" title="*移动构造"></a>*移动构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="comment">//定义类A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> <span class="comment">//定义func()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;      <span class="comment">//创建对象a</span></span><br><span class="line">    <span class="keyword">return</span> a; <span class="comment">//返回对象a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A b = <span class="built_in">func</span>(); <span class="comment">//调用func()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n);      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a);      <span class="comment">//移动构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();          <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(*(a.p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(A &amp;&amp;a) <span class="comment">//类外实现移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    p = a.p;       <span class="comment">//将当前对象指针指向a.p指向的空间</span></span><br><span class="line">    a.p = <span class="literal">nullptr</span>; <span class="comment">//将a.p赋值为nullptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A m = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n);      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a); <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a);      <span class="comment">//移动构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();          <span class="comment">//析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(n))</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    p = <span class="keyword">new</span> <span class="built_in">int</span>(*(a.p));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(A &amp;&amp;a) <span class="comment">//类外实现移动构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    p = a.p;       <span class="comment">//将当前对象指针指向a.p指向的空间</span></span><br><span class="line">    a.p = <span class="literal">nullptr</span>; <span class="comment">//将a.p赋值为nullptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A m = <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="move-函数"><a href="#move-函数" class="headerlink" title="move()函数"></a>move()函数</h3><p>移动构造函数是通过右值引用实现的，对于左值，也可以将其转化为右值，实现程序的性能优化。C++11在标准库utility中提供了m ove()函数，该函数的功能就是将一个左值强制转换为右值，以便可以通过右值引用使用该值。m ove()函数的用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>; </span><br><span class="line"><span class="type">int</span>&amp;&amp; r = <span class="built_in">move</span>(x);   <span class="comment">//将左值x强制转换为右值 </span></span><br></pre></td></tr></table></figure><p>在上述代码中，m ove()函数将左值x强制转换为右值，赋值给右值引用r。如果类中有指针或者动态数组成员，在对象被拷贝或赋值时，可以直接调用m ove()函数将对象转换为右值，去初始化另一个对象。使用右值进行初始化，调用的是移动构造函数，而不是拷贝构造函数，这样就可以避免大量数据的拷贝，能够极大地提高程序的运行效率。例如，在例10-5中，如果使用左值对象初始化另一个对象，则会调用拷贝构造函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(a)</span></span>;     <span class="comment">//对象a是左值，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><p>但是，如果将对象a转换为右值，则会调用移动构造函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="function">A <span class="title">c</span><span class="params">(move(a))</span></span>;    <span class="comment">//对象a被转换为右值，调用移动构造函数</span></span><br></pre></td></tr></table></figure><p>当对象内部有较大的堆内存数据时，应当定义移动构造函数，并使用m ove()函数完成对象之间的初始化，以避免没有意义的深拷贝。</p><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transimit</span><span class="params">(T &amp;t)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transimit</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(U &amp;&amp;u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">transimit</span>(u);       <span class="comment">//调用transimit()函数</span></span><br><span class="line">    <span class="built_in">transimit</span>(<span class="built_in">move</span>(u)); <span class="comment">//调用transimit()函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>(<span class="number">1</span>); <span class="comment">//调用test()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例10-6中，第3～6行代码定义了两个重载的模板函数transim it()，第一个重载函数接收一个左值引用作为参数，第二个重载函数接收一个右值引用作为参数。第7～12行代码定义模板函数test()，在test()函数内部以不同的参数调用transim it()函数。第15行代码调用test()函数，传入右值1作为参数。由图10-9可知，使用右值1调用test()函数时，test()函数的输出结果是“左值”“右值”。在调用过程中，右值1到test()函数内部变成了左值，因此transim it(u)其实是接收的左值，输出了“左值”；第二次调用transim it()函数时，使用m ove()函数将左值转换为右值，因此transim it(m ove(u))输出结果为“右值”。在例10-6中，调用test()函数时，传递的是右值，但在test()函数内部，第一次调用transim it()函数时，右值变为左值，这显然不符合程序设计者的期望。针对这种情况，C++11标准提供了一个函数forward()，它能够完全依照模板的参数类型，将参数传递给函数模板中调用的函数，即参数在转发过程中，参数类型一直保持不变，这种转发方式称为完美转发。例如，将例10-6中的第10行代码修改为下列形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transimit</span>(forward&lt;U&gt;(u));   <span class="comment">//调用forward()函数实现完美转发</span></span><br></pre></td></tr></table></figure><p>此时，再调用test(1)函数时，其输出结果均为“右值”。forward()函数在实现完美转发时遵循引用折叠规则，该规则通过形参和实参的类型推导出内层函数接收到的参数的实际类型。引用折叠规则如表10-1所示。<br>根据表10-1可推导出内层函数最终接收到的参数是左值引用还是右值引用。在引用折叠规则中，所有的右值引用都可以叠加，最后变成一个右值引用；所有的左值引用也都可以叠加，最后变成一个左值引用。在C++11标准库中，完美转发的应用非常广泛，如一些简单好用的函数（如m ake_pair()、m ake_unique()等）都使用了完美转发，它们减少了函数版本的重复，并且充分利用了右值引用，既简化了代码量，又提高了程序的运行效率。</p><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>如果一个类定义了多个构造函数，这些构造函数就可能会有大量的重复代码。例如，有如下类定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()</span><br><span class="line">    &#123;                    <span class="comment">/*...其他代码*/</span></span><br><span class="line">    &#125;                    <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string name) <span class="comment">//只有一个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = <span class="number">1001</span>;</span><br><span class="line">        _score = <span class="number">97.6</span>;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> id) <span class="comment">//有两个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = id;</span><br><span class="line">        _score = <span class="number">98.5</span>;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Student</span>(string name, <span class="type">int</span> id, <span class="type">double</span> score) <span class="comment">//有三个参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _id = id;</span><br><span class="line">        _score = score;</span><br><span class="line">        <span class="comment">//...其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name;</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">    <span class="type">double</span> _score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，每一个构造函数都需要给成员变量赋值，这些赋值语句都很重复。为了简化构造函数的编写，C++11标准提出了委托构造函数。委托构造函数就是在构造函数定义时，调用另一个已经定义好的构造函数完成对象的初始化。被委托的构造函数称为目标构造函数。例如，修改上述代码中Student类的定义，在类中定义委托构造函数，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Student</span>():<span class="built_in">Student</span>(<span class="string">&quot;lili&quot;</span>,<span class="number">1003</span>,<span class="number">99</span>) &#123; <span class="comment">/*...其他代码*/</span> &#125;  <span class="comment">//委托构造函数 </span></span><br><span class="line"> <span class="built_in">Student</span>(string name):<span class="built_in">Student</span>(name,<span class="number">1001</span>,<span class="number">97.6</span>)   <span class="comment">//委托构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">Student</span>(string name, <span class="type">int</span> id):<span class="built_in">Student</span>(name,id,<span class="number">98.5</span>)  <span class="comment">//委托构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string _name; </span><br><span class="line"> <span class="type">int</span> _id; </span><br><span class="line"> <span class="type">double</span> _score; </span><br><span class="line"> <span class="built_in">Student</span>(<span class="type">const</span> string name, <span class="type">int</span> id, <span class="type">double</span> score)  <span class="comment">//目标构造函数 </span></span><br><span class="line"> &#123; </span><br><span class="line">      _name = name; </span><br><span class="line">      _id = id; </span><br><span class="line">      _score = score; </span><br><span class="line">      <span class="comment">//...其他代码 </span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>上述代码中，无参构造函数、一个参数的构造函数、两个参数的构造函数都是委托构造函数，它们都委托有三个参数的目标构造函数完成对象的初始化工作。委托构造函数体中的语句在目标构造函数完全执行后才被执行。目标构造函数体中的局部变量不在委托构造函数体中起作用。在定义委托构造函数时，目标构造函数还可以再委托给另一个构造函数。但是，需要注意的是，委托构造函数不能递归定义（即构造函数C1不能委托给另一个构造函数C2，而C2再委托给C1）。<br>继承构造<br>在传统C++编程中，派生类不能继承基类的构造函数，无法通过继承直接调用基类构造函数完成基类成员变量的初始化。如果想要在派生类中完成基类成员变量的初始化，只能在派生类中定义若干构造函数，通过参数传递的方式，调用基类构造函数完成基类成员变量的初始化。为了简化代码的编写，C++11标准提出了继承构造函数的概念，使用using关键字在派生类中引入基类的构造函数，格式如下所示：<br>using 基类名::构造函数名;<br>在派生类中使用using关键字引入基类构造函数之后，派生类就不需要再定义用于参数传递的构造函数了。C++11标准将继承构造函数设计为派生类的隐匿声明函数，如果某个继承构造函数不被调用，编译器不会为其生成真正的函数代码。继承构造函数可以简化派生类的代码编写，但是它只能初始化基类的成员变量，无法初始化派生类的成员变量。如果要初始化派生类的成员变量，还需要定义相应的派生类构造函数。下面通过案例演示继承构造函数的调用，如例10-7所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="comment">//定义基类Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();                  <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num);           <span class="comment">//有一个int类型参数的构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">double</span> d);          <span class="comment">//有一个double类型参数的构造函数</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num, <span class="type">double</span> d); <span class="comment">//有两个参数的构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _num;  <span class="comment">//成员变量_num</span></span><br><span class="line">    <span class="type">double</span> _d; <span class="comment">//成员变量_d</span></span><br><span class="line">&#125;;</span><br><span class="line">Base::<span class="built_in">Base</span>() : _num(<span class="number">0</span>), _d(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">int</span> num) : _num(num), _d(<span class="number">1.2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数，初始化int num&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">double</span> d) : _num(<span class="number">100</span>), _d(d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数，初始化double d&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Base::<span class="built_in">Base</span>(<span class="type">int</span> num, <span class="type">double</span> d) : _num(num), _d(d)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base两个参数构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base <span class="comment">//定义派生类Derive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;    <span class="comment">//继承基类构造函数</span></span><br><span class="line">    <span class="built_in">Derive</span>();            <span class="comment">//派生类无参构造函数</span></span><br><span class="line">    <span class="built_in">Derive</span>(string name); <span class="comment">//派生类有参构造函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name; <span class="comment">//派生类成员变量_name</span></span><br><span class="line">&#125;;</span><br><span class="line">Derive::<span class="built_in">Derive</span>() : _name(<span class="string">&quot;xixi&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Derive::<span class="built_in">Derive</span>(string name) : _name(name)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">d1</span><span class="params">()</span></span>;         <span class="comment">//调用Derive类的无参构造函数</span></span><br><span class="line">    <span class="function">Derive <span class="title">d2</span><span class="params">(<span class="string">&quot;qiqi&quot;</span>)</span></span>;   <span class="comment">//调用Derive类的有参构造函数</span></span><br><span class="line">    <span class="function">Derive <span class="title">d3</span><span class="params">(<span class="number">6</span>)</span></span>;        <span class="comment">//调用Base类的有参构造函数，初始化int num</span></span><br><span class="line">    <span class="function">Derive <span class="title">d4</span><span class="params">(<span class="number">12.8</span>)</span></span>;     <span class="comment">//调用Base类的有参构造函数，初始化double d</span></span><br><span class="line">    <span class="function">Derive <span class="title">d5</span><span class="params">(<span class="number">100</span>, <span class="number">2.9</span>)</span></span>; <span class="comment">//调用Base类的有两个参数的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在使用继承构造函数时，如果基类构造函数有默认值，则每个默认值使用与否的不同组合都会创建出新的构造函数，例如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Base</span>(<span class="type">int</span>  n = <span class="number">3</span>, <span class="type">double</span> d = <span class="number">3.14</span>) &#123;&#125;  <span class="comment">//带有默认值的构造函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base    <span class="comment">//Derive类公有继承Base类 </span></span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">using</span> Base::Base;     <span class="comment">//继承构造函数 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在上述代码中，基类Base中定义了一个构造函数，该构造函数的两个参数均有默认值，则基类的构造函数在调用时会存在多种情况，分别如下所示。Base()：默认的构造函数，两个参数均使用默认值。Base(int n)：int类型的参数使用默认值。Base(int n,double d)：两个参数都不使用默认值。Base(const Base&amp;)：默认的拷贝构造函数。由于基类构造函数的版本有多个，因此派生类中的继承构造函数的版本也会有多个，分别如下所示。Derive()：默认的继承构造函数，两个参数都使用默认值。Derive(int)：带有一个参数的继承构造函数，int类型的参数使用默认值。Derive(int,double)：带有两个参数的继承构造函数，两个参数都不使用默认值。Derive(const Derive&amp;)：默认的拷贝构造函数。由此可知，若基类的构造函数是带有参数默认值的构造函数，会产生多个构造函数，应特别小心。此外，若派生类继承自多个基类，多个基类中的构造函数可能会导致派生类中的继承构造函数的函数名、参数相同，从而引发冲突。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Base1</span>(<span class="type">int</span> x) &#123;&#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Base2</span> </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Base2</span>(<span class="type">int</span> x)&#123;&#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">using</span> Base1::Base1; </span><br><span class="line">  <span class="keyword">using</span> Base2::Base2; </span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure><p>在上述代码中，两个基类构造函数都拥有int类型参数，这会导致派生类中重复定义相同类型的继承构造函数。例如，通过D erive d(100)创建对象时，编译器会提示D erive()构造函数调用不明确。此时，可以通过显式定义派生类构造函数解决这种冲突，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Derive</span>(<span class="type">int</span> x):<span class="built_in">Base1</span>(x), <span class="built_in">Base2</span>(x) &#123;&#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h3 id="函数包装"><a href="#函数包装" class="headerlink" title="函数包装"></a>函数包装</h3><p>C++11标准提供了一个函数包装器function，function是一个类模板，它能够为多种类似的函数提供统一的调用接口，即对函数进行包装。function可以包装除类成员函数之外的所有函数，包括普通函数、函数指针、lambda表达式和仿函数。在模板编程中，function能够用统一的方式处理函数，减少函数模板的实例化，因此可以提高程序的运行效率。在学习function之前来看一个案例，如例10-8所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个模板函数func()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count= &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;,&amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通函数square()，用于计算参数的平方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义类Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> id = <span class="number">1001</span>) : _id(id) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="keyword">return</span> _id + num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入square()函数名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;square()函数：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, square) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入仿函数Student()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student类：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, <span class="built_in">Student</span>(<span class="number">1002</span>)) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用func()函数，第二个参数传入lambda表达式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda表达式：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, [](<span class="type">int</span> b)</span><br><span class="line">                                     &#123; <span class="keyword">return</span> b / <span class="number">2</span>; &#125;)</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用特征标相同的函数作为参数去调用函数模板时，只实例化一个对应的函数。为此，C++11标准提供了function函数包装器，function可以从调用特征标的角度定义一个对象，用于包装调用特征标相同的函数指针、函数对象或lambda表达式。例如，定义一个调用特征标为int(int)的function对象，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi;</span><br></pre></td></tr></table></figure><p>需要注意的是，function定义在functional标准库中，在使用function时，要包含该头文件。使用function包装调用特征标相同的函数，当使用这些函数作为参数调用函数模板时，function可以保证函数模板只实例化一次，下面通过修改例10-8演示function的使用，如例10-9所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;function.h&quot;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个模板函数func()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;count= &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;,&amp;count = &quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义普通函数square()，用于求参数的平方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义类Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> id = <span class="number">1001</span>) : _id(id) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123; <span class="keyword">return</span> _id + num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi1 = square;</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi2 = <span class="built_in">Student</span>(<span class="number">1002</span>);</span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi3 = [](<span class="type">int</span> b)</span><br><span class="line">    &#123; <span class="keyword">return</span> b / <span class="number">2</span>; &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;square()函数：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Student类：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda表达式：&quot;</span> &lt;&lt; <span class="built_in">func</span>(x, fi3) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中，C++项目都非常复杂庞大，函数模板的用途非常多，在调用函数模板时，通过function为调用特征标相同的函数提供统一的接口，可以极大地提高程序运行效率。在例10-9中，定义了三个function对象，为简化编程，可以只定义一个function对象，在调用时分别传入不同的函数名、函数对象或lambda表达式即可，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; fi; </span><br><span class="line"><span class="comment">//… </span></span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>(square)); </span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>(<span class="built_in">Student</span>(<span class="number">1002</span>))); </span><br><span class="line"><span class="built_in">func</span>(x, <span class="built_in">fi</span>([](<span class="type">int</span> b) &#123;<span class="keyword">return</span> b / <span class="number">2</span>; &#125;))</span><br></pre></td></tr></table></figure><h2 id="并行编程"><a href="#并行编程" class="headerlink" title="并行编程"></a>并行编程</h2><p>在C++11标准之前，C++语言并没有对并行编程提供语言级别的支持，C++使用的多线程都由第三方库提供，如POSIX标准（pthread）、OpenM G库或W indows线程库，它们都是基于过程的多线程，这使得C++并行编程在可移植性方面存在诸多不足。为此，C++11标准增加了线程及线程相关的类，用于支持并行编程，极大地提高了C++并行编程的可移植性。本节将针对C++并行编程的相关知识进行讲解。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>C++11标准提供了thread类模板用于创建线程，该类模板定义在thread标准库中，因此在创建线程时，需要包含thread头文件。thread类模板定义了一个无参构造函数和一个变参构造函数，因此在创建线程对象时，可以为线程传入参数，也可以不传入参数。需要注意的是，thread类模板不提供拷贝构造函数、赋值运算符重载等函数，因此线程对象之间不可以进行拷贝、赋值等操作。除了构造函数，thread类模板还定义了两个常用的成员函数：join()函数和detach()函数。（1）join()函数：该函数将线程和线程对象连接起来，即将子线程加入程序执行。join()函数是阻塞的，它可以阻塞主线程（当前线程），等待子线程工作结束之后，再启动主线程继续执行任务。（2）detach()函数：该函数分离线程与线程对象，即主线程和子线程可同时进行工作，主线程不必等待子线程结束。但是，detach()函数分离的线程对象不能再调用join()函数将它与线程连接起来。下面通过案例演示C++11标准中线程的创建与使用，如例10-10所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">//包含头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="comment">//定义函数func()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程工作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(func)</span></span>; <span class="comment">//创建线程对象t</span></span><br><span class="line">    t.<span class="built_in">join</span>();       <span class="comment">//将子线程加入程序执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++多线程中，线程对象与线程是相互关联的，线程对象出了作用域之后就会被析构，如果此时线程函数还未执行完，程序就会发生错误，因此需要保证线程函数的生命周期在线程对象生命周期之内。一般通过调用thread中定义的join()函数阻塞主线程，等待子线程结束，或者调用thread中的detach()函数将线程与线程对象进行分离，让线程在后台执行，这样即使线程对象生命周期结束，线程也不会受到影响。例如，在例10-10中，将join()函数替换为detach()函数，将线程对象与线程分离，让线程在后台运行，再次运行程序，运行结果就可能发生变化。即使m ain()函数（主线程）结束，子线程对象t生命周期结束，子线程依然会在后台将func()函数执行完毕。<br>小提示：this_thread命名空间C++11标准定义了this_thread命名空间，该空间提供了一组获取当前线程信息的函数，分别如下所示。<br>（1）get_id()函数：获取当前线程id。<br>（2）yeild()函数：放弃当前线程的执行权。操作系统会调度其他线程执行未用完的时间片，当时间片用完之后，当前线程再与其他线程一起竞争CPU资源。<br>（3）sleep_until()函数：让当前线程休眠到某个时间点。<br>（4）sleep_for()函数：让当前线程休眠一段时间。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在并行编程中，为避免多线程对共享资源的竞争导致程序错误，线程会对共享资源进行保护。通常的做法是对共享资源上锁，当线程修改共享资源时，会获取锁将共享资源锁上，在操作完成之后再进行解锁。加锁之后，共享资源只能被当前线程操作，其他线程只能等待当前线程解锁退出之后再获取资源。为此，C++11标准提供了互斥锁mutex，用于为共享资源加锁，让多个线程互斥访问共享资源。mutex是一个类模板，定义在mutex标准库中，使用时要包含mutex头文件。mutex类模板定义了三个常用的成员函数：lock()函数、unlock()函数和try_lock()函数，用于实现上锁、解锁功能。下面分别介绍这三个函数。（1）lock()函数：用于给共享资源上锁。如果共享资源已经被其他线程上锁，则当前线程被阻塞；如果共享资源已经被当前线程上锁，则产生死锁。（2）unlock()函数：用于给共享资源解锁，释放当前线程对共享资源的所有权。（3）try_lock()函数：也用于给共享资源上锁，但它是尝试上锁，如果共享资源已经被其他线程上锁，try_lock()函数返回false，当前线程并不会被阻塞，而是继续执行其他任务；如果共享资源已经被当前线程上锁，则产生死锁。下面通过案例演示C++11标准中mutex的上锁、解锁的过程，如例10-11所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁mtx</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();                                          <span class="comment">//上锁</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; <span class="comment">//获取当前线程id</span></span><br><span class="line">    num++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    mtx.<span class="built_in">unlock</span>(); <span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread ths[<span class="number">3</span>]; <span class="comment">//定义线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ths[i] = <span class="built_in">thread</span>(func); <span class="comment">//分配线程任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;th : ths)</span><br><span class="line">        th.<span class="built_in">join</span>(); <span class="comment">//将线程加入程序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果注释掉第9行和第13行代码，即不给func()函数中的操作上锁，则三个线程会同时执行func()函数，输出的结果就会超出预期。例如，连续输出三个线程id，或者先输出counter值为3，再输出counter值为1。如果修改例10-11，调用try_lock()函数为func()函数上锁，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (mtx.<span class="built_in">try_lock</span>())    <span class="comment">//调用try_lock()函数加锁 </span></span><br><span class="line"> &#123; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; </span><br><span class="line">      num++; </span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl; </span><br><span class="line">      mtx.<span class="built_in">unlock</span>(); </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="lock-guard和unique-lock"><a href="#lock-guard和unique-lock" class="headerlink" title="lock_guard和unique_lock"></a>lock_guard和unique_lock</h3><p>在10.4.2节我们学习了互斥锁mutex，通过mutex的成员函数为共享资源上锁、解锁，能够保证共享资源的安全性。但是，通过mutex上锁之后必须要手动解锁，如果忘记解锁，当前线程会一直拥有共享资源的所有权，其他线程不得访问共享资源，造成程序错误。此外，如果程序抛出了异常，mutex对象无法正确地析构，导致已经被上锁的共享资源无法解锁。为此，C++11标准提供了RAII技术的类模板：lock_guard和unique_lock。lock_guard和unique_lock可以管理mutex对象，自动为共享资源上锁、解锁，不需要程序设计者手动调用mutex的lock()函数和unlock()函数。即使程序抛出异常，lock_guard和unique_lock也能保证mutex对象正确解锁，在简化代码的同时，也保证了程序在异常情况下的安全性。下面分别介绍lock_guard和unique_lock。</p><h4 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h4><p>在10.4.2节我们学习了互斥锁mutex，通过mutex的成员函数为共享资源上锁、解锁，能够保证共享资源的安全性。但是，通过mutex上锁之后必须要手动解锁，如果忘记解锁，当前线程会一直拥有共享资源的所有权，其他线程不得访问共享资源，造成程序错误。此外，如果程序抛出了异常，mutex对象无法正确地析构，导致已经被上锁的共享资源无法解锁。为此，C++11标准提供了RAII技术的类模板：lock_guard和unique_lock。lock_guard和unique_lock可以管理mutex对象，自动为共享资源上锁、解锁，不需要程序设计者手动调用mutex的lock()函数和unlock()函数。即使程序抛出异常，lock_guard和unique_lock也能保证mutex对象正确解锁，在简化代码的同时，也保证了程序在异常情况下的安全性。下面分别介绍lock_guard和unique_lock。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁mtx</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;                       <span class="comment">//创建lock_guard对象locker</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;线程id: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl; <span class="comment">//获取当前线程id</span></span><br><span class="line">    num++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;counter:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread ths[<span class="number">3</span>]; <span class="comment">//定义线程数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        ths[i] = <span class="built_in">thread</span>(func); <span class="comment">//分配线程任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;th : ths)</span><br><span class="line">        th.<span class="built_in">join</span>(); <span class="comment">//将线程加入程序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;主线程工作结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，lock_guard对象只是简化了mutex对象的上锁、解锁过程，但它并不负责mutex对象的生命周期。在例10-12中，当func()函数执行结束时，lock_guard对象locker析构，mutex对象mtx自动解锁，线程释放func()函数的所有权，但对象mtx的生命周期并没有结束。</p><h4 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h4><p>lock_guard只定义了构造函数和析构函数，没有定义其他成员函数，因此它的灵活性太低。为了提高锁的灵活性，C++11标准提供了另外一个RAII技术的类模板unique_lock。unique_lock与lock_guard相似，都可以很方便地为共享资源上锁、解锁，但unique_lock提供了更多的成员函数，它有多个重载的构造函数，而且unique_lock对象支持移动构造和移动赋值。需要注意的是，unique_lock对象不支持拷贝和赋值。下面简单介绍几个常用的成员函数。（1）lock()函数：为共享资源上锁，如果共享资源已经被其他线程上锁，则当前线程被阻塞；如果共享资源已经被当前线程上锁，则产生死锁。（2）try_lock()函数：尝试上锁，如果共享资源已经被其他线程上锁，该函数返回false，当前线程继续其他任务；如果共享资源已经被当前线程上锁，则产生死锁。（3）try_lock_for()函数：尝试在某个时间段内获取互斥锁，为共享资源上锁，如果在时间结束之前一直未获取互斥锁，则线程会一直处于阻塞状态。（4）try_lock_until()函数：尝试在某个时间点之前获取互斥锁，为共享资源上锁，如果到达时间点之前一直未获取互斥锁，则线程会一直处于阻塞状态。（5）unlock()函数：解锁。正是因为提供了更多的成员函数，unique_lock才能够更灵活地实现上锁和解锁控制，例如，转让mutex对象所有权（移动赋值）、在线程等待时期解锁等。但是，更灵活的代价就是空间开销也更大，运行效率相对较低。在编程过程中，如果只是为了保证数据同步，那么lock_guard完全能够满足使用需求。如果除了同步，还需要结合条件变量进行线程阻塞，则要选择unique_lock。小提示：RAII技术RAII（Resource Acquisition Is Initialization，资源获取初始化）是C++语言管理资源、避免内存泄漏的一个常用技术。RAII技术利用C++创建的对象最终被销毁的原则，在创建对象时获取对应的资源，在对象生命周期内控制对资源的访问，使资源始终有效。当对象生命周期结束后，释放资源。</p><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="*条件变量"></a>*条件变量</h4><p>在多线程编程中，多个线程可能会因为竞争资源而导致死锁，一旦产生死锁，程序将无法继续运行。为了解决死锁问题，C++11标准引入了条件变量condition_variable类模板，用于实现线程间通信，避免产生死锁。condition_variable类模板定义了很多成员函数，用于实现进程通信的功能，下面介绍几个常用的成员函数。（1）wait()函数：会阻塞当前线程，直到其他线程调用唤醒函数将线程唤醒。当线程被阻塞时，wait()函数会释放互斥锁，使得被阻塞在互斥锁上的其他线程能够获取互斥锁以继续执行代码。一旦当前线程被唤醒，它就会重新夺回互斥锁。wait()函数有两种重载形式，函数声明分别如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Predicate&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred</span></span></span><br></pre></td></tr></table></figure><p>第一种重载形式称为无条件阻塞，它以mutex对象作为参数，在调用wait()函数阻塞当前线程时，wait()函数会在内部自动通过mutex对象调用unlock()函数解锁，使得阻塞在互斥锁上的其他线程恢复执行。第二种重载形式称为有条件阻塞，它有两个参数，第一个参数是mutex对象，第二个参数是一个条件，只有当条件为false时，调用wait()函数才能阻塞当前线程；在收到其他线程的通知后，只有当条件为true时，当前线程才能被唤醒。（2）wait_for()函数：也用于阻塞当前线程，但它可以指定一个时间段，当收到通知或超过时间段时，线程就会被唤醒。wait_for()函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv_status wait_for（unique_lock&lt;mutex&gt;＆ lck， </span><br><span class="line">                      <span class="type">const</span> chrono :: duration&lt;Rep，Period&gt;＆ rel_time）; </span><br></pre></td></tr></table></figure><p>在上述函数声明中，wait_for()函数第一个参数为unique_lock对象，第二个参数为设置的时间段。函数返回值为cv_status类型，cv_status是C++11标准定义的枚举类型，它有两个枚举值：no-tim eout和tim eout。no-tim eout表示没有超时，即在规定的时间段内，当前线程收到了通知；tim eout表示超时。（3）wait_until()函数：可以指定一个时间点，当收到通知或超过时间点时，线程就会被唤醒。wait_until()函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cv_status <span class="title">wait_until</span><span class="params">(unique_lock&lt;mutex&gt;&amp; lck, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> chrono::time_point&lt;Clock,Duration&gt;&amp; abs_tim</span></span></span><br><span class="line"><span class="params"><span class="function">                    </span></span></span><br></pre></td></tr></table></figure><p>在上述函数声明中，wait_until()函数第一个参数为unique_lock对象，第二个参数为设置的时间点。函数返回值为cv_status类型。（4）notify_one()函数：用于唤醒某个被阻塞的线程。如果当前没有被阻塞的线程，则该函数什么也不做；如果有多个被阻塞的线程，则唤醒哪一个线程是随机的。notify_one()函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>在上述函数声明中，notify_one()函数没有参数，没有返回值，并且不抛出任何异常。（5）notify_all()函数：用于唤醒所有被阻塞的线程。如果当前没有被阻塞的线程，则该函数什么也不做。notify_all()函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>条件变量用于实现线程间通信，防止死锁发生，为了实现更灵活的上锁、解锁控制，条件变量通常与unique_lock结合使用。下面通过案例演示条件变量在并行编程中的使用，如例10-13所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; products;     <span class="comment">//创建队列容器products</span></span><br><span class="line">mutex mtx;               <span class="comment">//创建互斥锁mtx</span></span><br><span class="line">condition_variable cvar; <span class="comment">//定义条件变量cvar</span></span><br><span class="line"><span class="type">bool</span> done = <span class="literal">false</span>;       <span class="comment">//定义变量done，表示产品是否生产完毕</span></span><br><span class="line"><span class="type">bool</span> notified = <span class="literal">false</span>;   <span class="comment">//定义变量notified，表示是否唤醒线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span>           <span class="comment">//生产函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//让当前线程休眠2s</span></span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//创建unique_lock对象locker，获取互斥锁mtx</span></span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="comment">//生产产品，并将产品存放到products容器中</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;生产产品&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        products.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="comment">//将notified值设置为true</span></span><br><span class="line">        notified = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//唤醒一个线程</span></span><br><span class="line">        cvar.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    done = <span class="literal">true</span>;       <span class="comment">//生产完毕，设置done的值为true</span></span><br><span class="line">    cvar.<span class="built_in">notify_one</span>(); <span class="comment">//唤醒一个线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span> <span class="comment">//定义消费函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建unique_lock对象locker，获取互斥锁mtx</span></span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!done) <span class="comment">//判断产品是否生产完毕</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (!notified) <span class="comment">//避免虚假唤醒</span></span><br><span class="line">        &#123;</span><br><span class="line">            cvar.<span class="built_in">wait</span>(locker); <span class="comment">//继续阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!products.<span class="built_in">empty</span>()) <span class="comment">//如果products容器不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//消费产品</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;消费产品&quot;</span> &lt;&lt; products.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">            products.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        notified = <span class="literal">false</span>; <span class="comment">//消费完之后，将notified的值设置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">producer</span><span class="params">(produce)</span></span>; <span class="comment">//创建生产线程</span></span><br><span class="line">    <span class="function">thread <span class="title">consumer</span><span class="params">(consume)</span></span>; <span class="comment">//创建消费线程</span></span><br><span class="line">    producer.<span class="built_in">join</span>();</span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果为：生产线程每生产一个产品，消费线程就消费一个产品。生产线程每生产完一个产品，就会将notified的值设置为true，然后通过条件变量cvar调用notify_one()函数唤醒消费线程消费产品。</p><h3 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h3><p>在并行编程中，共享资源同时只能有一个线程进行操作，这些最小的不可并行执行的操作称为原子操作。原子操作都是通过上锁、解锁实现的，虽然使用lock_guard和unique_lock简化了上锁、解锁过程，但是由于上锁、解锁过程涉及许多对象的创建和析构，内存开销太大。为了减少多线程的内存开销，提高程序运行效率，C++11标准提供了原子类型atom ic。atom ic是一个类模板，它可以接受任意类型作为模板参数。创建的atom ic对象称为原子变量，使用原子变量就不需要互斥锁保护该变量进行的操作了。在使用原子类型之前来看一个案例，如例10-14所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">mutex mtx;   <span class="comment">//定义互斥锁</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">//定义全局变量num</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num++; <span class="comment">//通过for循环修改num的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>; <span class="comment">//创建线程t1执行func()函数</span></span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>; <span class="comment">//创建线程t2执行func()函数</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main()num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例10-15程序运行过程中，线程t1与线程t2交叉执行func()函数，修改num的值，并不是一个线程先执行完成所有for循环。输出num值之后，另一个线程才能去执行for循环进行修改。因此，第一次输出的num值并不是100000，但最终结果是正确的。原子变量只保证“num++”是原子操作（第10行代码），使得原子操作颗粒度更细（例10-14中，原子操作为第10～14行代码）。它相当于是在“num++”操作上上了锁，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx)</span></span>;  <span class="comment">//加锁 </span></span><br><span class="line">     num++; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，在for循环内部上了互斥锁，循环结束，locker对象失效。如果有多个线程修改num，则多个线程会交叉修改num的值。但是，相比于上锁，原子类型实现的是无锁编程，内存开销小，程序的运行效率会得到极大提高，并且代码更简洁。</p><h2 id="支持更多扩展"><a href="#支持更多扩展" class="headerlink" title="支持更多扩展"></a>支持更多扩展</h2><h3 id="原生字符串"><a href="#原生字符串" class="headerlink" title="原生字符串"></a>原生字符串</h3><p>在传统C++编程中，编写一个包含特殊字符的字符串是一件非常麻烦的事情。例如，输出一个包含HTM L文本的字符串，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;\ </span></span><br><span class="line"><span class="string">        &lt;html&gt;\ </span></span><br><span class="line"><span class="string">        &lt; head &gt;\ </span></span><br><span class="line"><span class="string">        &lt;title&gt;&lt;/title&gt;\ </span></span><br><span class="line"><span class="string">        &lt;script type = \&quot;text/javascript\&quot;&gt;\ </span></span><br><span class="line"><span class="string">        if(null)\ </span></span><br><span class="line"><span class="string">            alert(\&quot;null为真\&quot;);\ </span></span><br><span class="line"><span class="string">        else\ </span></span><br><span class="line"><span class="string">            alert(\&quot;null为假\&quot;);\ </span></span><br><span class="line"><span class="string">        &lt;/script&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/head&gt;\ </span></span><br><span class="line"><span class="string">        &lt;body&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/body&gt;\ </span></span><br><span class="line"><span class="string">        &lt;/html&gt;\ </span></span><br><span class="line"><span class="string">        &quot;</span>; </span><br></pre></td></tr></table></figure><p>在上述代码中，字符串s包含HTM L文本，在每次换行处和双引号前都需要添加转义字符，而且其输出格式也无法达到预期的整齐。为此，C++11标准提供了对原生字符串的支持。所谓原生字符串，就是“所见即所得”，不需要在字符串中添加转义字符或其他的格式控制字符调整字符串的格式。原生字符串的定义很简单，语法格式如下所示：<br>R”(字符串)”;<br>在上述格式中，字母R表示这是一个原生字符串，后面是一对双引号，双引号中有一对小括号，字符串就放在小括号中。这样定义的字符串，字符串中所有的字符都保持最原始的字面意思。重新定义包含HTM L文本的字符串s为原生字符串，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">R&quot;( </span></span><br><span class="line"><span class="string">        &lt;html&gt; </span></span><br><span class="line"><span class="string">        &lt;head&gt; </span></span><br><span class="line"><span class="string">        &lt;title&gt;&lt;/title&gt; </span></span><br><span class="line"><span class="string">        &lt;script type=&quot;text/javascript&quot;&gt; </span></span><br><span class="line"><span class="string">            if(null) </span></span><br><span class="line"><span class="string">                alert(&quot;null为真&quot;); </span></span><br><span class="line"><span class="string">            else </span></span><br><span class="line"><span class="string">                alert(&quot;null为假&quot;); </span></span><br><span class="line"><span class="string">        &lt;/script&gt; </span></span><br><span class="line"><span class="string">        &lt;/head&gt; </span></span><br><span class="line"><span class="string">        &lt;body&gt; </span></span><br><span class="line"><span class="string">        &lt;/body&gt; </span></span><br><span class="line"><span class="string">        &lt;/html&gt; </span></span><br><span class="line"><span class="string">        )&quot;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，字符串s为原生字符串，不必在换行和双引号前再添加转义字符，而且在输出时，输出格式就是字符串所定义的格式。需要注意的是，在原生字符串中，所有具有特殊意义的字符都不再起作用。</p><h4 id="Unicode编码支持"><a href="#Unicode编码支持" class="headerlink" title="Unicode编码支持"></a>Unicode编码支持</h4><p>为了支持Unicode编码，C++11标准提供了两个新的内置数据类型，以存储不同编码长度的Unicode数据。（1）char16_t：用于存储UTF-16编码的Unicode数据，所占内存大小为2字节。（2）char32_t：用于存储UTF-32编码的Unicode数据，所占内存大小为4字节。对于UTF-8编码的Unicode数据，C++11标准仍然采用8字节大小的字符数组进行存储。为了区分不同编码方式的Unicode数据，C++11标准还定义了一些前缀，用于告知编译器按照什么样的编码方式编译这些数据，分别如下所示：u8：表示UTF-8编码方式。u：表示UTF-16编码方式。U：表示UTF-32编码方式。再加上wchar_t类型数据的前缀“L”，以及普通字符串字面常量，C++11一共有五种声明字符串的方式。下面通过案例演示C++11标准中字符串的声明方式，如例10-16所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//普通字符数组</span></span><br><span class="line">    <span class="type">char</span> arr1[] = <span class="string">&quot;你好，祖国&quot;</span>;</span><br><span class="line">    <span class="comment">// wchar_t类型数组</span></span><br><span class="line">    <span class="type">wchar_t</span> arr2[] = <span class="string">L&quot;中国&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-8编码方式</span></span><br><span class="line">    <span class="type">char</span> arr3[] = <span class="string">u8&quot;你好&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-16编码方式</span></span><br><span class="line">    <span class="type">char16_t</span> arr4[] = <span class="string">u&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// UTF-32编码方式</span></span><br><span class="line">    <span class="type">char32_t</span> arr5[] = <span class="string">U&quot;hello 和\u4f60\u597d\u554a&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr1:&quot;</span> &lt;&lt; arr1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr2:&quot;</span> &lt;&lt; arr2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr3:&quot;</span> &lt;&lt; arr3 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr4:&quot;</span> &lt;&lt; arr4 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr5:&quot;</span> &lt;&lt; arr5 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增的库"><a href="#新增的库" class="headerlink" title="新增的库"></a>新增的库</h3><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>标准库tuple中定义了tuple类模板，tuple类模板可以存储任意多个不同类型的值。示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">double</span>, string &gt; t= &#123;<span class="number">10</span>, <span class="number">3.6</span>, <span class="string">&quot;hello&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>上述代码定义了一个tuple对象t，对象t中存储了三个值，分别是int类型的10、double类型的3.6和string类型的“hello”。若要获取tuple对象中的元素，可以调用std提供的函数模板get()。在调用get()函数获取tuple对象元素时，既可以通过索引获取，也可以通过类型获取，示例代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过索引获取 </span></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t); </span><br><span class="line"><span class="comment">//通过数据类型获取 </span></span><br><span class="line"><span class="built_in">get</span>&lt;<span class="type">int</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(t); </span><br><span class="line"><span class="built_in">get</span>&lt;string&gt;(t)</span><br></pre></td></tr></table></figure><p>tuple还有其他很多操作，有兴趣的读者可以查阅C++标准库进行学习。</p><h4 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h4><p>chrono是C++11标准定义的时间库，chrono时间库的所有实现都在std::chrono命名空间中。chrono时间库定义了三个常用的类模板，分别介绍如下。<br>（1）duration：表示一段时间，如1小时、30秒等。chrono预定义了六个duration类模板的实例化对象，分别如下。hours：小时。minutes：分钟。seconds：秒。milliseconds：毫秒。microseconds：微秒。nanoseconds：纳秒。<br>（2）tim e_point：表示一个具体的时间点，如生日、飞机起飞时间等。<br>（3）system_clock：表示当前系统时钟，它提供了now()函数用于获取系统当前时间。下面通过案例演示chrono时间库的使用，如例10-17所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义duration对象oneday，表示一天</span></span><br><span class="line">    chrono::duration&lt;<span class="type">int</span>, ratio&lt;<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>&gt;&gt; <span class="built_in">oneday</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//获取系统当前时间</span></span><br><span class="line">    chrono::system_clock::time_point today = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">//计算明天的时间</span></span><br><span class="line">    chrono::system_clock::time_point tomorrow = today + oneday;</span><br><span class="line">    <span class="type">time_t</span> t; <span class="comment">//创建time_t时间对象t</span></span><br><span class="line">              <span class="comment">//将对象today中的时间转换之后存储到时间对象t中</span></span><br><span class="line">    t = chrono::system_clock::<span class="built_in">to_time_t</span>(today);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;today:&quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;t);</span><br><span class="line">    <span class="comment">//将对象tomorrow中的时间转换之后存储到时间对象t中</span></span><br><span class="line">    t = chrono::system_clock::<span class="built_in">to_time_t</span>(tomorrow);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tomorrow:&quot;</span> &lt;&lt; <span class="built_in">ctime</span>(&amp;t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="regex"><a href="#regex" class="headerlink" title="regex"></a>regex</h4><p>regex标准库提供了对正则表达式的支持。regex标准库提供了regex类模板，在构造regex对象时，以一个正则表达式作为参数。为了处理正则表达式操作，C++11标准还提供了很多函数，下面简单介绍两个比较常用的匹配函数。（1）regex_m atch()函数：将字符串与正则表达式匹配，匹配成功返回true，匹配失败返回false。需要注意的是，regex_m atch()函数在匹配的时候，需要整个字符串匹配成功才能返回true。（2）regex_search()函数：在字符串中查找与正则表达式匹配的子串，查找成功返回true，查找失败返回false。regex_search()函数只要求字符串包含符合正则表达式的子串即可。regex_m atch()函数和regex_search()函数用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回false </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_search</span>(<span class="string">&quot;123&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回true </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;1&quot;</span>, <span class="built_in">regex</span>(<span class="string">&quot;\\d&quot;</span>)) &lt;&lt; endl;   <span class="comment">//返回true </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;hello,China&quot;</span>;   <span class="comment">//定义字符串</span></span><br><span class="line">    <span class="function">regex <span class="title">r</span><span class="params">(<span class="string">&quot;(.&#123;5&#125;),(\\w&#123;5&#125;)&quot;</span>)</span></span>; <span class="comment">//正则表达式</span></span><br><span class="line">    smatch sm;                  <span class="comment">//创建smatch容器对象sm</span></span><br><span class="line">    <span class="built_in">regex_search</span>(s, sm, r);     <span class="comment">//调用regex_search()函数匹配</span></span><br><span class="line">                                <span class="comment">// for循环遍历容器sm，输出匹配的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sm.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; sm[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="alignof和alignas"><a href="#alignof和alignas" class="headerlink" title="alignof和alignas"></a>alignof和alignas</h3><p>C++11标准新增了alignof和alignas两个运算符。alignof运算符用于获取结构体和类的内存对齐方式，即按照多少字节对齐。alignof用法的示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Obj</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">    <span class="type">int</span> b; </span><br><span class="line">    <span class="type">double</span> d; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    string name; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> sex; </span><br><span class="line">&#125;; </span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(Obj) &lt;&lt; endl;  <span class="comment">//结果为8 </span></span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(Student) &lt;&lt; endl; <span class="comment">//结果为4</span></span><br></pre></td></tr></table></figure><p>在上述代码中，首先定义了struct Obj结构体类型和学生类Student，然后使用alignof运算符分别获取struct Obj结构体类型和学生类Student的对齐字节。如果运行程序，会得出struct Obj结构体类型对齐字节为8，学生类Student的对齐字节为4。这是因为struct Obj结构体类型中最宽基本类型为double（8字节），学生类Student中最宽基本类型为int（4字节）。alignas运算符也用于设置结构体和类的内存对齐方式，用法也很简单。需要注意的是，在设置结构体和类的对齐方式时，对齐字节数必须是2的幂次方，并且不能小于结构体和类中最宽基本类型所占内存字节数，即不能小于默认对齐字节数。alignas用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) A    <span class="comment">//设置struct A的对齐方式为8字节 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br><span class="line">cout &lt;&lt; <span class="built_in">alignof</span>(A) &lt;&lt; endl;   <span class="comment">//结果为8 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">1</span>) B    <span class="comment">//错误，对齐字节数小于默认对齐字节数 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">6</span>) C    <span class="comment">//错误，对齐字节数不是2的幂次方 </span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> num; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>在上述代码中，首先定义了struct A结构体类型（默认对齐为4字节），使用alignas运算符设置struct A结构体类型对齐方式为8字节。然后定义了struct B结构体类型，使用alignas运算符设置其对齐方式为1字节，编译器会报错，因为1字节小于struct B结构体类型的默认对齐字节数（4字节）。最后定义了struct C结构体类型，使用alignas运算符设置struct C结构体类型对齐方式为6字节，编译器会报错，因为6字节不是2的幂次方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十章-C-11-新特性&quot;&gt;&lt;a href=&quot;#第十章-C-11-新特性&quot; class=&quot;headerlink&quot; title=&quot;第十章 C++11 新特性&quot;&gt;&lt;/a&gt;第十章 C++11 新特性&lt;/h1&gt;&lt;h2 id=&quot;简洁的变成方式&quot;&gt;&lt;a href=&quot;#简洁的变</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c4/"/>
    <id>http://example.com/2022/12/18/c4/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:02.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-继承与派生"><a href="#第四章-继承与派生" class="headerlink" title="第四章 继承与派生"></a>第四章 继承与派生</h1><p>在C++中，继承就是在原有类的基础上产生出新类，新类会继承原有类的所有属性和方法。<br>原有的类称为基类或父类，新类称为派生类或子类。<br>派生类同样可以作为基类派生出新类。在多层次继承结构中，派生类上一层的基类称为直接基类，隔层次的基类称为间接基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名称 : 继承方式 基类名称</span><br><span class="line">&#123;</span><br><span class="line">    派生类成员声明</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（1）基类的构造函数与析构函数不能被继承。<br>（2）派生类对基类成员的继承没有选择权，不能选择继承或不继承某些成员。<br>（3）派生类中可以增加新的成员，用于实现新功能，保证派生类的功能在基类基础上有所扩展。（4）一个基类可以派生出多个派生类；一个派生类也可以继承自多个基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Animal::move</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物行为&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Cat</span>(string name);</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cat::<span class="built_in">Cat</span>(string name)&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot;会走&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cat <span class="title">cat</span><span class="params">(<span class="string">&quot;猫&quot;</span>)</span></span>;</span><br><span class="line">    cat.<span class="built_in">move</span>();</span><br><span class="line">    cat.<span class="built_in">walk</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ol><li>public</li><li>protected</li><li>private</li><li></li></ol><h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生构造函数(参数列表) : 基类构造函数(基类构造函数列表),成员对象(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    派生类新增成员的初始化语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）派生类构造函数与基类构造函数的调用顺序是，先调用基类构造函数再调用派生类构造函数。（2）派生类构造函数的参数列表中需要包含派生类新增成员变量和基类成员变量的参数值。调用基类构造函数时，基类构造函数从派生类的参数列表中获取实参，因此不需要类型名。（3）如果基类没有构造函数或仅存在无参构造函数，则在定义派生类构造函数时可以省略对基类构造函数的调用。（4）如果基类定义了有参构造函数，派生类必须定义构造函数，提供基类构造函数的参数，完成基类成员变量的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> <span class="comment">//定义发动机类Engine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Engine</span>(string type, <span class="type">int</span> power); <span class="comment">//发动机构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;                    <span class="comment">//发动机普通成员函数show()</span></span><br><span class="line">    ~<span class="built_in">Engine</span>();                      <span class="comment">//发动机析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _type; <span class="comment">//成员_type表示型号</span></span><br><span class="line">    <span class="type">int</span> _power;   <span class="comment">//成员_power表示功率</span></span><br><span class="line">&#125;;</span><br><span class="line">Engine::<span class="built_in">Engine</span>(string type, <span class="type">int</span> power) <span class="comment">//类外实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用发动机Engine构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _type = type;</span><br><span class="line">    _power = power;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Engine::show</span><span class="params">()</span> <span class="comment">//类外实现show()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;发动机型号：&quot;</span> &lt;&lt; _type &lt;&lt; <span class="string">&quot;,发动机功率：&quot;</span> &lt;&lt; _power &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Engine::~<span class="built_in">Engine</span>() <span class="comment">//类外实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用发动机Engine析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> <span class="comment">//定义交通工具类Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vehicle</span>(string name); <span class="comment">//交通工具类构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;           <span class="comment">//交通工具类普通成员函数run()</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span>;     <span class="comment">//交通工具类普通成员函数getName()</span></span><br><span class="line">    ~<span class="built_in">Vehicle</span>();           <span class="comment">//交通工具类析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name; <span class="comment">//成员_name表示交通工具的名称</span></span><br><span class="line">&#125;;</span><br><span class="line">Vehicle::<span class="built_in">Vehicle</span>(string name) <span class="comment">//类外实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用交通工具Vehicle构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vehicle::run</span><span class="params">()</span> <span class="comment">//类外实现run()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot;正在行驶中&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">Vehicle::getName</span><span class="params">()</span> <span class="comment">//类外实现getName()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line">Vehicle::~<span class="built_in">Vehicle</span>() <span class="comment">//类外实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用交通工具Vehicle析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义小汽车类Car，公有继承交通工具类Vehicle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//小汽车类构造函数，其参数包括了成员对象、基类成员变量、新增成员变量的参数</span></span><br><span class="line">    <span class="built_in">Car</span>(<span class="type">int</span> seats, string color, string type, <span class="type">int</span> power, string name);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">brake</span><span class="params">()</span></span>;   <span class="comment">//小汽车类普通成员函数brake()</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>; <span class="comment">//小汽车类普通成员函数display()</span></span><br><span class="line">    ~<span class="built_in">Car</span>();         <span class="comment">//小汽车类析构函数</span></span><br><span class="line">    Engine engine;  <span class="comment">//公有成员变量，Engine类对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _seats;    <span class="comment">//成员_seats表示座位数量</span></span><br><span class="line">    string _color; <span class="comment">//成员_color表示颜色</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现构造函数，后面使用“:”运算符调用成员对象构造函数、基类构造函数</span></span><br><span class="line">Car::<span class="built_in">Car</span>(<span class="type">int</span> seats, string color, string type, <span class="type">int</span> power, string name) : <span class="built_in">engine</span>(type, power), <span class="built_in">Vehicle</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用小汽车Car构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    _seats = seats;</span><br><span class="line">    _color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::brake</span><span class="params">()</span> <span class="comment">//类外实现brake()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;停车&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::display</span><span class="params">()</span> <span class="comment">//类外实现display()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;有&quot;</span> &lt;&lt; _seats &lt;&lt; <span class="string">&quot;个座位，&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;颜色为&quot;</span> &lt;&lt; _color &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Car::~<span class="built_in">Car</span>() <span class="comment">//类外实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用小汽车Car析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">car</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;EA113&quot;</span>, <span class="number">130</span>, <span class="string">&quot;passat&quot;</span>)</span></span>; <span class="comment">//创建小汽车类对象car</span></span><br><span class="line">    car.<span class="built_in">run</span>();                                 <span class="comment">//调用基类的run()函数</span></span><br><span class="line">    car.<span class="built_in">brake</span>();                               <span class="comment">//调用brake()函数</span></span><br><span class="line">    car.<span class="built_in">display</span>();                             <span class="comment">//调用display()函数</span></span><br><span class="line">    <span class="comment">//通过成员对象engine调用Engine类的show()函数，显示发动机信息</span></span><br><span class="line">    car.engine.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当创建派生类对象时，各个构造函数的调用顺序为：先调用基类构造函数，再调用成员对象的构造函数，最后调用派生类构造函数。基类构造函数与成员对象的构造函数的先后顺序不影响构造函数的调用顺序。<br>注意：虽然公有派生类的构造函数可以直接访问基类的公有成员变量和保护成员变量，甚至可以在构造函数中对它们进行初始化，但一般不这样做，而是通过调用基类的构造函数对它们进行初始化，再调用基类接口（普通成员函数）访问它们。这样可以降低类之间的耦合性。</p><h3 id="在派生类中隐藏基类成员函数"><a href="#在派生类中隐藏基类成员函数" class="headerlink" title="在派生类中隐藏基类成员函数"></a>在派生类中隐藏基类成员函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> <span class="comment">//定义交通工具类Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">//交通工具类普通成员函数run()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Vehicle::run</span><span class="params">()</span> <span class="comment">//类外实现run()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;基类run()函数：行驶&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle <span class="comment">//定义小汽车类Car，公有继承交通工具类Vehicle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>; <span class="comment">//小汽车类普通成员函数run()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::run</span><span class="params">()</span> <span class="comment">//类外实现run()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小汽车需要燃烧汽油,行驶速度快&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car;            <span class="comment">//创建小汽车类对象car</span></span><br><span class="line">    car.<span class="built_in">run</span>();          <span class="comment">//调用派生类的run()函数</span></span><br><span class="line">    car.Vehicle::<span class="built_in">run</span>(); <span class="comment">//通过基类名与作用域限定符调用基类run()函数</span></span><br><span class="line">    Vehicle *pv = &amp;car;</span><br><span class="line">    pv-&gt;<span class="built_in">run</span>(); <span class="comment">//基类指针调用基类run()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="多继承方式"><a href="#多继承方式" class="headerlink" title="多继承方式"></a>多继承方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类:继承方式 基类<span class="number">1</span>名称,继承方式 基类<span class="number">2</span>名称,..,继承方式 基类n名称</span><br><span class="line">&#123;</span><br><span class="line">    新增成员;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承派生类的构造函数和析构函数"><a href="#多继承派生类的构造函数和析构函数" class="headerlink" title="多继承派生类的构造函数和析构函数"></a>多继承派生类的构造函数和析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类构造函数名(参数列表) : 基类<span class="number">1</span>构造函数名(参数列表), 基类<span class="number">2</span>构造函数名(参数列表), ...</span><br><span class="line">&#123;</span><br><span class="line">    派生类新增成员的初始化语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Wood</span>        <span class="comment">//木材类Wood </span></span><br><span class="line">  &#123; </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">       <span class="built_in">Wood</span>()&#123;cout&lt;&lt;<span class="string">&quot;木材构造函数&quot;</span>&lt;&lt;endl; &#125;  </span><br><span class="line">       ~<span class="built_in">Wood</span>()&#123;cout&lt;&lt;<span class="string">&quot;木材析构函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">  &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Sofa</span>        <span class="comment">//沙发类Sofa </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">      <span class="built_in">Sofa</span>()&#123;cout&lt;&lt;<span class="string">&quot;沙发构造函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      ~<span class="built_in">Sofa</span>()&#123;cout&lt;&lt;<span class="string">&quot;沙发析构函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">sit</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Sofa用来坐...&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Bed</span>         <span class="comment">//床类Bed </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">      <span class="built_in">Bed</span>()&#123;cout&lt;&lt;<span class="string">&quot;床的构造函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      ~<span class="built_in">Bed</span>()&#123;cout&lt;&lt;<span class="string">&quot;床的析构函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Bed用来睡觉...&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Sofabed</span>:<span class="keyword">public</span> Sofa,<span class="keyword">public</span> Bed    <span class="comment">//Sofabed类，公有继承Sofa类和Bed类 </span></span><br><span class="line"> &#123; </span><br><span class="line"> <span class="keyword">public</span>: </span><br><span class="line">      <span class="built_in">Sofabed</span>()&#123;cout&lt;&lt;<span class="string">&quot;沙发床构造函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      ~<span class="built_in">Sofabed</span>()&#123;cout&lt;&lt;<span class="string">&quot;沙发床析构函数&quot;</span>&lt;&lt;endl; &#125; </span><br><span class="line">      Wood pearwood;      <span class="comment">//Wood对象pearwood </span></span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">      Sofabed sbed;       <span class="comment">//创建沙发床对象sbed </span></span><br><span class="line">      sbed.<span class="built_in">sit</span>();      <span class="comment">//通过sbed调用基类Sofa的sit()函数 </span></span><br><span class="line">      sbed.<span class="built_in">sleep</span>();       <span class="comment">//通过sbed调用基类Bed的sleep()函数 </span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="多继承二义性问题"><a href="#多继承二义性问题" class="headerlink" title="多继承二义性问题"></a>多继承二义性问题</h3><ol><li>不同积累有同名成员函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofa</span> <span class="comment">//沙发类Sofa</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rest</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;沙发可以坐着休息&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bed</span> <span class="comment">//床类Bed</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rest</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;床可以躺着休息&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofabed</span> : <span class="keyword">public</span> Sofa, <span class="keyword">public</span> Bed <span class="comment">// Sofabed类，公有继承Sofa类和Bed类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;沙发床综合了沙发和床的功能&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sofabed sbed; <span class="comment">//创建沙发床对象sbed</span></span><br><span class="line">    sbed.<span class="built_in">rest</span>();  <span class="comment">//通过sbed调用rest()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sbed.Sofa::<span class="built_in">rest</span>();<span class="comment">//调用基类Sofa的rest()函数</span></span><br><span class="line">sbed.Bed::<span class="built_in">rest</span>();<span class="comment">//调用基类Bed的rest()函数</span></span><br><span class="line"><span class="number">2.</span> 简介基类成员变量在派生类中有多份拷贝</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Furniture</span> <span class="comment">//家具类Furniture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Furniture</span>(string wood); <span class="comment">// Furniture类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _wood; <span class="comment">//成员变量_wood，表示材质</span></span><br><span class="line">&#125;;</span><br><span class="line">Furniture::<span class="built_in">Furniture</span>(string wood) <span class="comment">//类外实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    _wood = wood;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofa</span> : <span class="keyword">public</span> Furniture <span class="comment">//沙发类Sofa，公有继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood); <span class="comment">// Sofa类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _length; <span class="comment">//成员变量_length，表示沙发长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofa类构造函数</span></span><br><span class="line">Sofa::<span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _length = length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bed</span> : <span class="keyword">public</span> Furniture <span class="comment">//床类Bed，公有继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bed</span>(<span class="type">float</span> width, string wood); <span class="comment">// Bed类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _width; <span class="comment">//成员变量_width，表示床的宽度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Bed类构造函数</span></span><br><span class="line">Bed::<span class="built_in">Bed</span>(<span class="type">float</span> width, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofabed</span> : <span class="keyword">public</span> Sofa, <span class="keyword">public</span> Bed <span class="comment">// Sofabed类，公有继承Sofa类和Bed类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//成员函数getSize()，获取沙发床大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofabed类构造函数</span></span><br><span class="line">Sofabed::<span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2) : <span class="built_in">Sofa</span>(length, wood1), <span class="built_in">Bed</span>(width, wood2)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sofabed::getSize</span><span class="params">()</span> <span class="comment">//类外实现getSize()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床长&quot;</span> &lt;&lt; _length &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床宽&quot;</span> &lt;&lt; _width &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床材质为&quot;</span> &lt;&lt; _wood &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Sofabed <span class="title">sbed</span><span class="params">(<span class="number">1.8</span>, <span class="string">&quot;梨木&quot;</span>, <span class="number">1.5</span>, <span class="string">&quot;檀木&quot;</span>)</span></span>; <span class="comment">//创建Sofabed类对象sbed</span></span><br><span class="line">    sbed.<span class="built_in">getSize</span>();                         <span class="comment">//调用getSize()函数获取沙发床信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用以下代码可以解决上述代码报错问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;沙发床材质为&quot;</span> &lt;&lt; Sofa::_wood &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;沙发床材质为&quot;</span> &lt;&lt; Bed::_wood &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>在程序设计过程中，通常希望间接基类的成员变量在底层派生类中只有一份拷贝，从而避免成员访问的二义性。通过虚继承可以达到这样的目的，虚继承就是在派生类继承基类时，在权限控制符前加上virtual关键字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 : <span class="keyword">virtual</span> 权限控制符 基类名</span><br><span class="line">&#123;</span><br><span class="line">    派生类成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述格式中，在权限控制符前面添加了virtual关键字，就表明派生类虚继承了基类。<br>被虚继承的基类通常称为虚基类，虚基类只是针对虚继承，而不是针对基类本身。在普通继承中，该基类并不称为虚基类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Furniture</span> <span class="comment">//家具类Furniture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Furniture</span>(string wood); <span class="comment">// Furniture类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _wood; <span class="comment">//成员变量_wood，表示材质</span></span><br><span class="line">&#125;;</span><br><span class="line">Furniture::<span class="built_in">Furniture</span>(string wood) <span class="comment">//类外实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    _wood = wood;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofa</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Furniture <span class="comment">//沙发类Sofa，虚继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood); <span class="comment">// Sofa类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _length; <span class="comment">//成员变量_length，表示沙发长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofa类构造函数</span></span><br><span class="line">Sofa::<span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _length = length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bed</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Furniture <span class="comment">//床类Bed，虚继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bed</span>(<span class="type">float</span> width, string wood); <span class="comment">// Bed类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _width; <span class="comment">//成员变量_width，表示床的宽度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Bed类构造函数</span></span><br><span class="line">Bed::<span class="built_in">Bed</span>(<span class="type">float</span> width, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofabed</span> : <span class="keyword">public</span> Sofa, <span class="keyword">public</span> Bed <span class="comment">// Sofabed类，公有继承Sofa类和Bed类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//成员函数getSize()，获取沙发床大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofabed类构造函数</span></span><br><span class="line">Sofabed::<span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2) : <span class="built_in">Sofa</span>(length, wood1), <span class="built_in">Bed</span>(width, wood2), <span class="built_in">Furniture</span>(wood1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sofabed::getSize</span><span class="params">()</span> <span class="comment">//类外实现getSize()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床长&quot;</span> &lt;&lt; _length &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床宽&quot;</span> &lt;&lt; _width &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床材质为&quot;</span> &lt;&lt; _wood &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Sofabed <span class="title">sbed</span><span class="params">(<span class="number">1.8</span>, <span class="string">&quot;梨木&quot;</span>, <span class="number">1.5</span>, <span class="string">&quot;檀木&quot;</span>)</span></span>; <span class="comment">//创建Sofabed类对象sbed</span></span><br><span class="line">    sbed.<span class="built_in">getSize</span>();                         <span class="comment">//调用getSize()函数获取沙发床大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Furniture</span> <span class="comment">//家具类Furniture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Furniture</span>(string wood); <span class="comment">// Furniture类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _wood; <span class="comment">//成员变量_wood，表示材质</span></span><br><span class="line">&#125;;</span><br><span class="line">Furniture::<span class="built_in">Furniture</span>(string wood) <span class="comment">//类外实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    _wood = wood;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofa</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Furniture <span class="comment">//沙发类Sofa，虚继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood); <span class="comment">// Sofa类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _length; <span class="comment">//成员变量_length，表示沙发长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofa类构造函数</span></span><br><span class="line">Sofa::<span class="built_in">Sofa</span>(<span class="type">float</span> length, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _length = length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bed</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Furniture <span class="comment">//床类Bed，虚继承Furniture类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bed</span>(<span class="type">float</span> width, string wood); <span class="comment">// Bed类构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">float</span> _width; <span class="comment">//成员变量_width，表示床的宽度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Bed类构造函数</span></span><br><span class="line">Bed::<span class="built_in">Bed</span>(<span class="type">float</span> width, string wood) : <span class="built_in">Furniture</span>(wood)</span><br><span class="line">&#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sofabed</span> : <span class="keyword">public</span> Sofa, <span class="keyword">public</span> Bed <span class="comment">// Sofabed类，公有继承Sofa类和Bed类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getSize</span><span class="params">()</span></span>; <span class="comment">//成员函数getSize()，获取沙发床大小</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现Sofabed类构造函数</span></span><br><span class="line">Sofabed::<span class="built_in">Sofabed</span>(<span class="type">float</span> length, string wood1, <span class="type">float</span> width, string wood2) : <span class="built_in">Sofa</span>(length, wood1), <span class="built_in">Bed</span>(width, wood2), <span class="built_in">Furniture</span>(wood1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sofabed::getSize</span><span class="params">()</span> <span class="comment">//类外实现getSize()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床长&quot;</span> &lt;&lt; _length &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床宽&quot;</span> &lt;&lt; _width &lt;&lt; <span class="string">&quot;米&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;沙发床材质为&quot;</span> &lt;&lt; _wood &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Sofabed <span class="title">sbed</span><span class="params">(<span class="number">1.8</span>, <span class="string">&quot;梨木&quot;</span>, <span class="number">1.5</span>, <span class="string">&quot;檀木&quot;</span>)</span></span>; <span class="comment">//创建Sofabed类对象sbed</span></span><br><span class="line">    sbed.<span class="built_in">getSize</span>();                         <span class="comment">//调用getSize()函数获取沙发床大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在虚继承中，每个虚继承的派生类都会增加一个虚基类指针vbptr，该指针位于派生类对象的顶部。vbptr指针指向一个虚基类表vbtable（不占对象内存），虚基类表中记录了基类成员变量相对于vbptr指针的偏移量，根据偏移量就可以找到基类成员变量。当虚基类的派生类被当作基类继承时，虚基类指针vbptr也会被继承，因此底层派生类对象中成员变量的排列方式与普通继承有所不同。</p><p>另外，需要注意的是，在虚继承中，底层派生类的构造函数不仅负责调用直接基类的构造函数，还负责调用间接基类的构造函数。在整个对象的创建过程中，间接基类的构造函数只会调用一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章-继承与派生&quot;&gt;&lt;a href=&quot;#第四章-继承与派生&quot; class=&quot;headerlink&quot; title=&quot;第四章 继承与派生&quot;&gt;&lt;/a&gt;第四章 继承与派生&lt;/h1&gt;&lt;p&gt;在C++中，继承就是在原有类的基础上产生出新类，新类会继承原有类的所有属性和方法。&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c5/"/>
    <id>http://example.com/2022/12/18/c5/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:11.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-多态与虚函数"><a href="#第五章-多态与虚函数" class="headerlink" title="第五章 多态与虚函数"></a>第五章 多态与虚函数</h1><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中的多态分为静态多态和动态多态。<br>静态多态是函数重载，在编译阶段就能确定调用哪个函数。<br>动态多态是由继承产生的，指同一个属性或行为在基类及其各派生类中具有不同的语义，不同的对象根据所接收的消息做出不同的响应，这种现象称为动态多态</p><p>多态的三个条件<br>（1）基类声明虚函数。<br>（2）派生类重写基类的虚函数。<br>（3）将基类指针指向派生类对象，通过基类指针访问虚函数。</p><h2 id="虚函数实现多态"><a href="#虚函数实现多态" class="headerlink" title="虚函数实现多态"></a>虚函数实现多态</h2><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    权限控制符 : <span class="keyword">virtual</span> 函数返回值类型 函数名(参数列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）构造函数不能声明为虚函数，但析构函数可以声明为虚函数。<br>（2）虚函数不能是静态成员函数。<br>（3）友元函数不能声明为虚函数，但虚函数可以作为另一个类的友元函数。</p><p>虚函数只能是类的成员函数，不能将类外的普通函数声明为虚函数，因为虚函数的作用是让派生类对虚函数重新定义，它只能存在于类的继承层次结构中。</p><p>若类中声明了虚函数，并且派生类重新定义了虚函数，当使用基类指针或基类引用操作派生类对象调用函数时，系统会自动调用派生类中的虚函数代替基类虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//动物类Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明虚函数speak()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Animal::speak</span><span class="params">()</span> <span class="comment">//类外实现虚函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物叫声&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal <span class="comment">//猫类Cat，公有继承Animal类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明虚函数speak()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::speak</span><span class="params">()</span> <span class="comment">//类外实现虚函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;猫的叫声：喵喵&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal <span class="comment">//狗类Dog，公有继承Animal类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明虚函数speak()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dog::speak</span><span class="params">()</span> <span class="comment">//类外实现虚函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;狗的叫声：汪汪&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;           <span class="comment">//创建Cat类对象cat</span></span><br><span class="line">    Animal *pA = &amp;cat; <span class="comment">//定义Animal类指针pA指向对象cat</span></span><br><span class="line">    pA-&gt;<span class="built_in">speak</span>();       <span class="comment">//通过pA调用speak()函数</span></span><br><span class="line">    Dog dog;           <span class="comment">//创建Dog类对象dog</span></span><br><span class="line">    Animal *pB = &amp;dog; <span class="comment">//定义Animal类指针pB指向对象dog</span></span><br><span class="line">    pB-&gt;<span class="built_in">speak</span>();       <span class="comment">//通过pB调用speak()函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多学一招：override和final（C-11新标准）"><a href="#多学一招：override和final（C-11新标准）" class="headerlink" title="多学一招：override和final（C++11新标准）"></a>多学一招：override和final（C++11新标准）</h2><ol><li>override<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="comment">//基类Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base <span class="comment">//派生类Derive，公有继承Base类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//可通过编译</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//不能通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>编译报错原因：show()函数不是重写基类虚函数<br>利用override关键字可以判断派生类是否准确地对基类虚函数进行重写，防止出现因书写错误而导致的基类虚函数重写失败。此时，可以通过override关键字进行检查。</li><li>final<br>final关键字有两种用法：修饰类、修饰虚函数。当使用final关键字修饰类时，表示该类不可以被继承。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="keyword">final</span> <span class="comment">// final修饰类，Base类不能被继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base <span class="comment">//编译错误</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>除了修饰类，final关键字还可以修饰虚函数，当使用final关键字修饰虚函数时，虚函数不能在派生类中重写。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//不能通过编译</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚函数实现多态的机制"><a href="#虚函数实现多态的机制" class="headerlink" title="虚函数实现多态的机制"></a>虚函数实现多态的机制</h3><p>在编写程序时，我们需要根据函数名、函数返回值类型、函数参数等信息正确调用函数，这个匹配过程通常称为绑定。C++提供了两种函数绑定机制：静态绑定和动态绑定。静态绑定也称为静态联编、早绑定，它是指编译器在编译时期就能确定要调用的函数。动态绑定也称为动态联编、迟绑定，它是指编译器在运行时期才能确定要调用的函数。<br>虚函数就是通过动态绑定实现多态的，当编译器在编译过程中遇到virtual关键字时，它不会对函数调用进行绑定，而是为包含虚函数的类建立一张虚函数表Vtable。在虚函数表中，编译器按照虚函数的声明顺序依次保存虚函数地址。同时，编译器会在类中添加一个隐藏的虚函数指针VPTR，指向虚函数表。在创建对象时，将虚函数指针VPTR放置在对象的起始位置，为其分配空间，并调用构造函数将其初始化为虚函数表地址。需要注意的是，虚函数表不占用对象空间。<br>派生类继承基类时，也继承了基类的虚函数指针。当创建派生类对象时，派生类对象中的虚函数指针指向自己的虚函数表。在派生类的虚函数表中，派生类虚函数会覆盖基类的同名虚函数。当通过基类指针或基类引用操作派生类对象时，以操作的对象内存为准，从对象中获取虚函数指针，通过虚函数指针找到虚函数表，调用对应的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> <span class="comment">//定义基类Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">//声明虚函数func()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1</span><span class="params">()</span></span>; <span class="comment">//声明虚函数base1()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show1</span><span class="params">()</span></span>; <span class="comment">//声明虚函数show1()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> <span class="comment">//定义基类Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">//声明虚函数func()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base2</span><span class="params">()</span></span>; <span class="comment">//声明虚函数base2()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show2</span><span class="params">()</span></span>; <span class="comment">//声明虚函数show2()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义Derive类，公有继承Base1和Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">//声明虚函数func()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">base1</span><span class="params">()</span></span>; <span class="comment">//声明虚函数base1()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show2</span><span class="params">()</span></span>; <span class="comment">//声明虚函数show2()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>virtural ~析构函数();<br>在基类中声明虚析构函数之后，基类的所有派生类的析构函数都自动成为虚析构函数。<br>在基类声明虚析构函数之后，使用基类指针或引用操作派生类对象，在析构派生类对象时，编译器会先调用派生类的析构函数释放派生类对象资源，然后再调用基类析构函数。如果基类没有声明虚析构函数，在析构派生类对象时，编译器只会调用基类析构函数，不会调用派生类析构函数，导致派生类对象申请的资源不能正确释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="comment">//基类Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>(); <span class="comment">//虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Base::~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base <span class="comment">//派生类Derive，公有继承Base类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derive</span>(); <span class="comment">//虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Derive::~<span class="built_in">Derive</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derive类析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *pb = <span class="keyword">new</span> Derive; <span class="comment">//基类指针指向派生类对象</span></span><br><span class="line">    <span class="keyword">delete</span> pb;             <span class="comment">//释放基类指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编写C++程序时，最好把基类的析构函数声明为虚析构函数，即使基类不需要析构函数，也要显式定义一个函数体为空的虚析构函数，这样所有派生类的析构函数都会自动成为虚析构函数。如果程序中通过基类指针释放派生类对象，编译器能够调用派生类的析构函数完成派生类对象的释放。</p><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>有时候在基类中声明函数并不是基类本身的需要，而是考虑到派生类的需求，在基类中声明一个函数，函数的具体实现由派生类根据本类的需求定义。<br>virtual 函数返回值类型 函数名(参数列表) &#x3D; 0;<br>上述格式中，纯虚函数后面“&#x3D;0”并不是函数的返回值为0，它只是告诉编译器这是一个纯虚函数，在派生类中会完成具体的实现。<br>纯虚函数的作用是在基类中为派生类保留一个接口，方便派生类根据需要完成定义，实现多态。派生类都应该实现基类的纯虚函数，如果派生类没有实现基类的纯虚函数，则该函数在派生类中仍然是纯虚函数。<br>如果一个类中包含纯虚函数，这样的类称为抽象类。<br>抽象类的作用主要是通过它为一个类群建立一个公共接口（纯虚函数），使它们能够更有效地发挥多态性。<br>抽象类声明了公共接口，而接口的完整实现由派生类定义。<br>抽象类只能作为基类派生新类，不能创建抽象类的对象，但可以定义抽象类的指针或引用，通过指针或引用操作派生类对象。<br>抽象类可以有多个纯虚函数，如果派生类需要实例化对象，则在派生类中需要全部实现基类的纯虚函数。<br>如果派生类没有全部实现基类的纯虚函数，未实现的纯虚函数在派生类中仍然是纯虚函数，则派生类也是抽象类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//动物类Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数speak()</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">//纯虚函数eat()</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>();        <span class="comment">//虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用Animal析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal <span class="comment">//猫类Cat，公有继承Animal类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明speak()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;   <span class="comment">//声明eat()函数</span></span><br><span class="line">    ~<span class="built_in">Cat</span>();       <span class="comment">//声明析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::speak</span><span class="params">()</span> <span class="comment">//实现speak()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫喵喵叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::eat</span><span class="params">()</span> <span class="comment">//实现eat()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫吃鱼&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Cat::~<span class="built_in">Cat</span>() <span class="comment">//实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用Cat析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rabbit</span> : <span class="keyword">public</span> Animal <span class="comment">//兔子类Rabbit，公有继承Animal类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明speak()函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span>;   <span class="comment">//声明eat()函数</span></span><br><span class="line">    ~<span class="built_in">Rabbit</span>();    <span class="comment">//声明析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rabbit::speak</span><span class="params">()</span> <span class="comment">//实现speak()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小兔子咕咕叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rabbit::eat</span><span class="params">()</span> <span class="comment">//实现eat()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小兔子吃白菜&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Rabbit::~<span class="built_in">Rabbit</span>() <span class="comment">//实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用Rabbit析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *pC = <span class="keyword">new</span> Cat;    <span class="comment">//定义基类指针pC指向Cat类对象</span></span><br><span class="line">    pC-&gt;<span class="built_in">speak</span>();             <span class="comment">//通过pC指针调用Cat类的speak()函数</span></span><br><span class="line">    pC-&gt;<span class="built_in">eat</span>();               <span class="comment">//通过pC指针调用Cat类的eat()函数</span></span><br><span class="line">    <span class="keyword">delete</span> pC;               <span class="comment">//释放pC指针指向的空间</span></span><br><span class="line">    Animal *pR = <span class="keyword">new</span> Rabbit; <span class="comment">//定义基类指针pR指向Rabbit类对象</span></span><br><span class="line">    pR-&gt;<span class="built_in">speak</span>();             <span class="comment">//通过pR指针调用Rabbit类的speak()函数</span></span><br><span class="line">    pR-&gt;<span class="built_in">eat</span>();               <span class="comment">//通过pR指针调用Rabbit类的eat()函数</span></span><br><span class="line">    <span class="keyword">delete</span> pR;               <span class="comment">//释放pR指针指向的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章-多态与虚函数&quot;&gt;&lt;a href=&quot;#第五章-多态与虚函数&quot; class=&quot;headerlink&quot; title=&quot;第五章 多态与虚函数&quot;&gt;&lt;/a&gt;第五章 多态与虚函数&lt;/h1&gt;&lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c7/"/>
    <id>http://example.com/2022/12/18/c7/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:24.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-STL"><a href="#第七章-STL" class="headerlink" title="第七章 STL"></a>第七章 STL</h1><p>STL主要由六个部分组成：空间配置器（Allocator）、适配器（Adapters）、容器（Containers）、迭代器（Iterator）、仿函数（Functors）和算法（Algorithm）。</p><ol><li>容器<br>  a. 容器是存储其他对象的对象，它存储的对象可以是自定义数据类型的对象，也可以是内置数据类型的对象。这些被存储的对象必须是同一种数据类型，它们归容器所有，称为容器的元素。当容器失效时，容器中的元素也会失效。容器本身包含了处理这些数据的方法。STL中的容器共有13种，<br>  b. 序列容器<br> ⅰ. vector<br> ⅱ. list<br> ⅲ. deque<br> ⅳ. array(C++11)<br> ⅴ. forward_list(C++11)<br>  c. 关联容器<br> ⅰ. set<br> ⅱ. multiset<br> ⅲ. map<br> ⅳ. multiset<br>  d. 无序容器<br> ⅰ. unordered_set(C++11)<br> ⅱ. unordered_multiset(C++11)<br> ⅲ. multiset_map(C++11)<br> ⅳ. unordered_multimap(C++11)</li><li>空间配置器<br>  a. C++标准库采用了空间配置器实现对象内存空间的分配和归还，空间配置器是特殊的内存模型。例如，使用vector容器，存储数据的空间由空间配置器完成内存的分配和资源回收。空间配置器本质上是对new和delete运算符再次封装而成的类模板，对外提供可用的接口，实现内存资源的自动化管理。</li><li>适配器<br>  a. 适配器主要指容器适配器。容器适配器也是一类容器，它除了能存储普通数据，还可以存储list、vector、deque等容器。容器适配器采用特定的数据管理策略，能够使容器在操作数据时表现出另一种行为。例如，使用容器适配器stack封装一个<code>vector&lt;int&gt;</code>容器，使<code>vector&lt;int&gt;</code>容器在处理数据时，表现出栈这种数据结构的特点（先进后出）。STL提供了三个容器适配器：stack（栈）、queue（队列）和priority_queue（优先队列）。适配器体现了STL设计的通用性，极大提高了编程效率。</li><li>迭代器<br>  a. 迭代器是STL提供的用于操作容器中元素的类模板，STL算法利用迭代器遍历容器中的元素，迭代器本身也提供了操作容器元素的方法，使容器元素访问更便捷。迭代器将容器与算法联系起来，起到了“黏合剂”的作用，STL提供的算法几乎都通过迭代器实现元素访问。STL提供了输入迭代器、输出迭代器、正向迭代器、双向迭代器和随机访问迭代器五种类型的迭代器，使用迭代器访问容器元素更简单、易用，且代码更加紧凑、简洁。</li><li>仿函数<br>  a. 在前面3.4节我们学习了仿函数，仿函数通过重载(）运算符实现，使类具有函数一样的行为。仿函数也称为函数对象，是STL很重要的组成部分，它使STL的应用更加灵活方便，增强了算法的通用性。大多数STL算法可以使用一个仿函数作为参数，以达到某种数据操作的目的。例如，在排序算法中，可以使用仿函数less或greater作为参数，以实现数据从大到小或从小到大的排序。</li><li>算法<br>  a. 算法是STL定义的一系列函数模板，是STL非常重要的一部分内容。算法可以对容器中的元素施加特定操作。STL算法不依赖于容器的实现细节，只要容器的迭代器符合算法要求，算法就可以通过迭代器处理容器中的元素。</li></ol><h2 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h2><p>序列容器（Sequence Containers）也叫作顺序容器，序列容器各元素之间有顺序关系，每个元素都有固定位置，除非使用插入或删除操作改变这个元素的位置。序列容器是一种线性结构的有序群集，它最重要的特点就是可以在容器一端添加、删除元素。对于双向序列容器，允许在两端添加和删除元素。序列容器有连续存储和链式存储两种存储方式，如图7-2所示。STL提供的基本序列容器包括vector、deque、list、array和forward_list五种，在使用这五种容器时分别需要包含相应的头文件，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector容器与动态数组相同，在插入或删除元素时能够自动调整自身大小，即vector容器能够自动处理存储数据所需的空间。vector容器中的元素放置在连续的内存空间中，可以使用迭代器对其进行访问和遍历。</p><p>vector容器在插入元素时，插入位置之后的元素都要被顺序地向后移动，因此，在总体上vector容器插入操作效率并不高。插入位置越靠前，执行插入所需的时间就越多，但在vector容器尾部插入元素的效率比较高。删除vector容器中的元素时，被删除元素后面的元素会顺序向前移动，将被删除元素留下的空位补上。删除操作的效率和插入类似，被删除元素越靠前，删除操作所需的时间就越多。</p><ol><li>指定容器大小<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;元素类型&gt; 对象名 (容器大小);</span><br></pre></td></tr></table></figure></li><li>指定容器初始值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;元素类型&gt; 对象名 (容器大小, 元素初始值);</span><br></pre></td></tr></table></figure></li><li>初始化列表<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;v1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">vector&lt;string&gt; v2 = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>使用列表初始化时，带“&#x3D;”符号与不带“&#x3D;”符号均可。</li><li>初始化状态为空<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//创建储存类型int类型的容器v1</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;     <span class="comment">//用容器v1初始化容器v2</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = v2;    <span class="comment">//用容器v2初始化容器v3</span></span><br></pre></td></tr></table></figure>需要注意的是，用一个vector容器初始化另一个容器或相互赋值时，两个vector容器的元素类型必须相同。</li></ol><h4 id="获取容器和实际元素个数"><a href="#获取容器和实际元素个数" class="headerlink" title="获取容器和实际元素个数"></a>获取容器和实际元素个数</h4><p>vector容器的容量与容器实际元素个数并不一定相同，容器容量指容器最多可以存储的元素个数，是容器预分配的内存空间。而容器实际元素个数可能小于容器容量。vector提供了两个函数capacity()和size()，分别用于获取容器容量和容器实际元素个数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">capacity</span>();<span class="comment">//返回容器的容量</span></span><br><span class="line">v.<span class="built_in">size</span>();<span class="comment">//返回容器实际元素个数</span></span><br></pre></td></tr></table></figure><h4 id="访问容器中的元素"><a href="#访问容器中的元素" class="headerlink" title="访问容器中的元素"></a>访问容器中的元素</h4><p>由于vector重载了“[]”运算符，因此可以使用索引方式访问vector容器中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">at</span>(<span class="type">int</span> index);</span><br></pre></td></tr></table></figure><h4 id="赋值函数"><a href="#赋值函数" class="headerlink" title="赋值函数"></a>赋值函数</h4><p>vector容器中的元素可以在创建容器时指定，也可以通过“[]”运算符完成赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">assign</span>(n,elem); <span class="comment">//将n个elem元素赋值给容器</span></span><br><span class="line">v.<span class="built_in">assign</span>(begin,end);<span class="comment">//将[begin,end)区间中的元素赋值给容器</span></span><br></pre></td></tr></table></figure><h4 id="获取头部和尾部元素"><a href="#获取头部和尾部元素" class="headerlink" title="获取头部和尾部元素"></a>获取头部和尾部元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">front</span>(); <span class="comment">//获取容器第一个元素</span></span><br><span class="line">v.<span class="built_in">back</span>(); <span class="comment">//获取容器最后一个元素</span></span><br></pre></td></tr></table></figure><h4 id="从尾部插入和删除元素"><a href="#从尾部插入和删除元素" class="headerlink" title="从尾部插入和删除元素"></a>从尾部插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">push_back</span>(type elem&amp;t);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v; <span class="comment">//创建一个空的vector容器v</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        v.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">//从尾部向容器v中插入10个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot;  &quot;</span>; <span class="comment">//输出容器v中的元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();               <span class="comment">//删除尾部元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">//此时元素个数为9</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;   <span class="comment">//输出容器v中的元素</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器的迭代器"><a href="#容器的迭代器" class="headerlink" title="容器的迭代器"></a>容器的迭代器</h4><p>vector容器提供了迭代器，通过迭代器可以访问、修改容器中的元素。vector容器提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，这四种迭代器作用分别如下。<br>iterator：正向遍历容器元素。<br>reverse_iterator：反向遍历容器元素。<br>const_iterator：正向遍历容器元素，但通过const_iterator只能访问容器元素，不能修改元素的值。<br>const_reverse_iterator：反向遍历容器元素，但通过const_reverse_iterator只能访问容器元素，不能修改元素的值。在使用迭代器之前，必须先定义迭代器对象，vector容器迭代器<br>vector&lt;元素类型&gt; 迭代器 迭代器对象名称;</p><p>需要注意的是，迭代器遍历容器到达尾部时，指向最后一个元素的后面，而不是指向最后一个元素，即使用end()函数、rend()函数、cend()函数和crend()函数获取的迭代器，指向最后一个元素后面的位置，而不是指向最后一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;           <span class="comment">//创建vector容器c</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator pos;           <span class="comment">//定义iterator迭代器pos</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::reverse_iterator pos_r; <span class="comment">//定义reverse_iterator迭代器pos_r</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;iterator迭代器:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (pos = c.<span class="built_in">begin</span>(); pos != c.<span class="built_in">end</span>(); ++pos) <span class="comment">//使用迭代器pos遍历容器c中的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;reverse_iterator迭代器:&quot;</span>;</span><br><span class="line">    <span class="comment">//使用迭代器pos_r反向遍历容器c中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (pos_r = c.<span class="built_in">rbegin</span>(); pos_r != c.<span class="built_in">rend</span>(); ++pos_r)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos_r &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：迭代器失效<br>vector容器是一个顺序容器，在内存中是一块连续的内存，当插入或删除一个元素后，内存中的数据会移动，从而保证数据的连续。当插入或删除数据后，其他数据的地址可能会发生变化，迭代器获取容器位置信息的数据不正确，即迭代器失效，会导致访问出错。</p><h4 id="在任意位置插入和删除元素"><a href="#在任意位置插入和删除元素" class="headerlink" title="在任意位置插入和删除元素"></a>在任意位置插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">insert</span>(pos, elem);       <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos, n, elem);    <span class="comment">//在pos位置插入n个elem元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin, end)区间的数据</span></span><br><span class="line">v.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">v.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的数据</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v;                  <span class="comment">//创建空的vector容器v</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;a&#x27;</span>);        <span class="comment">//在头部位置插入元素a</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;b&#x27;</span>);        <span class="comment">//在头部位置插入元素b</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="string">&#x27;c&#x27;</span>);        <span class="comment">//在头部位置插入元素c</span></span><br><span class="line">    v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">5</span>, <span class="string">&#x27;t&#x27;</span>); <span class="comment">//在v.begin()+1位置插入5个元素t</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)      <span class="comment">//输出容器v中的元素</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after erase elems:\n&quot;</span>;</span><br><span class="line">    <span class="comment">//删除begin()+1到begin()+6区间的5个元素</span></span><br><span class="line">    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">begin</span>() + <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">//输出容器v中的元素</span></span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多学一招：deque容器"><a href="#多学一招：deque容器" class="headerlink" title="多学一招：deque容器"></a>多学一招：deque容器</h4><p>deque容器与vector容器非常相似，采用动态内存管理的方式存储元素。与vector不同的是，deque是两端开口的，支持从两端插入、删除数据，并支持元素的随机访问。</p><p>deque的操作方法和vector容器几乎相同。最大的区别是deque容器不支持vector容器中的reserve()函数、capacity()函数和data()函数，并且新增了pop_front()、push_front()函数，用于从队首弹出、插入元素。</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>array是C++11标准新增加的容器，它也是一个序列容器，只是array的大小是固定的，一旦分配了array容器，其大小就不能再改变，不允许向array容器插入元素或从array容器中删除元素，即array容器不支持插入、删除操作。array容器的存储结构如图7-8所示。</p><h4 id="创建array容器"><a href="#创建array容器" class="headerlink" title="创建array容器"></a>创建array容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; a1;             <span class="comment">//定义大小为3的array容器a1</span></span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; a2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//定义array容器a2</span></span><br></pre></td></tr></table></figure><h4 id="修改容器元素"><a href="#修改容器元素" class="headerlink" title="修改容器元素"></a>修改容器元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(val);         <span class="comment">//使用val填充容器 </span></span><br><span class="line">a1.<span class="built_in">swap</span>(a2);         <span class="comment">//交换容器a1和容器a2的元素</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; c = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">//创建array容器c</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt; c1 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                <span class="comment">//创建array容器c1</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 3&gt;::iterator pos;                 <span class="comment">//定义iterator迭代器pos</span></span><br><span class="line">    c.<span class="built_in">swap</span>(c1);                                  <span class="comment">//交换容器c和容器c1的元素</span></span><br><span class="line">    <span class="keyword">for</span> (pos = c.<span class="built_in">begin</span>(); pos != c.<span class="built_in">end</span>(); ++pos) <span class="comment">//使用迭代器pos遍历容器c中的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *pos &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list容器以双向链表形式实现，list容器通过指针将前面的元素和后边的元素链接到一起。list容器的存储结构如图7-10所示。<br>与vector容器和deque容器相比，list容器只能通过迭代器访问元素，不能通过索引方式访问元素。因为同为序列容器，list容器的接口大部分与vector和deque容器都相同，所以读者学习起来也比较容易。下面讲解list容器的常见用法</p><h4 id="创建list容器"><a href="#创建list容器" class="headerlink" title="创建list容器"></a>创建list容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;T&gt; lt;             <span class="comment">//创建一个空的list容器lt</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(n)</span></span>;          <span class="comment">//创建一个list容器lt，大小为n</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(n, elem)</span></span>;    <span class="comment">//创建一个list容器lt，包含n个elem元素</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(begin, end)</span></span>; <span class="comment">//创建一个list容器lt，用[begin, end)区间的值为元素赋值</span></span><br><span class="line"><span class="function">list&lt;T&gt; <span class="title">lt</span><span class="params">(lt1)</span></span>;        <span class="comment">//创建一个list容器lt，用容器lt1初始化</span></span><br></pre></td></tr></table></figure><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lt.<span class="built_in">assign</span>(n, elem);    <span class="comment">//将n个elem元素的值赋给lt</span></span><br><span class="line">lt.<span class="built_in">assign</span>(begin, end); <span class="comment">//用[begin, end)区间的值给lt中的元素赋值</span></span><br></pre></td></tr></table></figure><h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><p>因为list容器是由链表实现的，内存区域并不连续，所以无法用“[]”运算符访问元素，也没有可随机访问元素的at()方法，但list容器提供了front()函数和back()函数用于获取头部元素和尾部元素。此外，list容器也支持迭代器访问元素，提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，还提供了获取这四种迭代器的成员函数。list迭代器的用法与vector迭代器相同，这里不再举例演示。</p><h3 id="插入元素和删除元素"><a href="#插入元素和删除元素" class="headerlink" title="插入元素和删除元素"></a>插入元素和删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lt.<span class="built_in">push_back</span>();             <span class="comment">//在尾部插入元素</span></span><br><span class="line">lt.<span class="built_in">push_front</span>();            <span class="comment">//在头部插入元素</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, elem);       <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, n, elem);    <span class="comment">//在pos位置插入n个元素elem</span></span><br><span class="line">lt.<span class="built_in">insert</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin, end)区间的值作为元素</span></span><br><span class="line">lt.<span class="built_in">pop_back</span>();        <span class="comment">//从尾部删除元素</span></span><br><span class="line">lt.<span class="built_in">pop_front</span>();       <span class="comment">//从头部删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(pos);        <span class="comment">//从中间删除元素</span></span><br><span class="line">lt.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的元素</span></span><br><span class="line">lt.<span class="built_in">remove</span>(elem);      <span class="comment">//从容器中删除所有与elem匹配的元素</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(list&lt;T&gt; mylist)</span> <span class="comment">//定义函数模板，输出list容器元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> list&lt;T&gt;::iterator it; <span class="comment">//创建list的iterator迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (it = mylist.<span class="built_in">begin</span>(); it != mylist.<span class="built_in">end</span>(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lt; <span class="comment">//创建空的list容器lt</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        lt.<span class="built_in">push_back</span>(i + <span class="number">1</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    lt.<span class="built_in">pop_back</span>();    <span class="comment">//删除最后一个元素</span></span><br><span class="line">    lt.<span class="built_in">push_front</span>(<span class="number">5</span>); <span class="comment">//在头部添加元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;再次输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    lt.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除5之后，输出list容器中的元素：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">print</span>(lt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h3><p>C++11标准新增了forward_list容器，该容器由单链表实现。在forward_list容器中，除了最后一个元素，每个元素与下一个元素通过指针链接。由于forward_list容器是单链表实现的，因此它只能向后迭代。</p><p>由于同为链式存储的容器，因此forward_list的接口与list大部分相同。但是又因为forward_list是单链式存储，所以forward_list还提供了一些自己特有的函数，</p><h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><p>forward_list容器不支持insert()函数和erase()函数，但它提供了insert_after()函数和erase_after()函数用于插入和删除元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert_after</span>(pos, val);        <span class="comment">//将元素val插入pos位置</span></span><br><span class="line"><span class="built_in">insert_after</span>(pos, begin, end); <span class="comment">//在pos位置插入[begin,end）区间内的元素</span></span><br><span class="line"><span class="built_in">erase_after</span>(pos);              <span class="comment">//删除pos位置的元素</span></span><br><span class="line"><span class="built_in">erase_after</span>(begin, end);       <span class="comment">//删除[begin,end）区间内的元素</span></span><br></pre></td></tr></table></figure><h4 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h4><p>forward_list新增了两个函数before_begin()和cbefore_begin()，其中，before_begin()函数用于获取指向容器第一个元素之前位置的迭代器；cbefore_begin()用于获取指向容器第一个元素之前位置的const_iterator迭代器。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>序列容器中元素的顺序都是由程序设计者决定的，程序设计者可以随意指定新元素的插入位置，而关联容器的所有元素都是经过排序的，即关联容器都是有序的。它的每一个元素都有一个键（key），容器中的元素是按照键的取值升序排列的。<br>关联容器内部实现为一个二叉树，在二叉树中，每个元素都有一个父节点和两个子节点，左子树的所有元素都比父节点小，右子树的所有元素都比父节点大。关联容器的有序二叉树如图7-13所示。关联容器内部结构都以这种二叉树结构实现，这也使得它可以高效地查找容器中的每一个元素，但却不能实现任意位置的操作。</p><p>STL提供了四种关联容器，分别是set、multiset、m ap和multim ap，其中set与multiset包含在头文件set中，m ap与multim ap包含在头文件m ap中。</p><h3 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h3><p>set与multiset都是集合，用于存储一组相同数据类型的元素。两者的区别是set用来存储一组无重复的元素，而multiset允许存储有重复的元素。集合支持插入、删除、查找等操作，但集合中的元素值不可以直接修改，因为这些元素都是自动排序的，如果想修改其中某一个元素的值，必须先删除原有的元素，再插入新的元素。</p><h4 id="创建set与multiset容器"><a href="#创建set与multiset容器" class="headerlink" title="创建set与multiset容器"></a>创建set与multiset容器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;T&gt; s;                 <span class="comment">//创建一个空的set容器，默认升序排列</span></span><br><span class="line">set&lt;T, op&gt; s;             <span class="comment">//创建一个空的set容器，按op规则排序</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(begin, end)</span></span>;     <span class="comment">//创建一个容器，用[begin,end)区间为其初始化</span></span><br><span class="line"><span class="function">set&lt;T, op&gt; <span class="title">s</span><span class="params">(begin, end)</span></span>; <span class="comment">//创建一个容器，用[begin,end)区间为其初始化，并按op规则排序</span></span><br><span class="line"><span class="function">set&lt;T&gt; <span class="title">s</span><span class="params">(s1)</span></span>;             <span class="comment">//创建一个空的set容器，用另一个容器s1初始化</span></span><br><span class="line">set&lt;<span class="type">char</span>&gt; s1;</span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;()&gt; s2;</span><br><span class="line"><span class="function">set&lt;<span class="type">float</span>&gt; <span class="title">s3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">set&lt;string, greater&lt;string&gt;()&gt; <span class="built_in">s4</span>(begin, end);</span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s5</span><span class="params">(s2)</span></span>;</span><br></pre></td></tr></table></figure><p>上述代码分别用不同的方式定义了char、int等类型的set容器，其中容器s2与s4中的<code>greater&lt;T&gt;</code>是排序规则，指定容器中的元素按照从大到小的顺序排列。如果没有指定排序规则，则默认规则是<code>less&lt;T&gt;</code>，即容器中元素按照从小到大的顺序排列。<code>greater&lt;T&gt;</code>、<code>less&lt;T&gt;</code>是STL中定义的函数对象，包含在functional头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">char</span>&gt; ms1;</span><br><span class="line">multiset&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;()&gt; ms2;</span><br><span class="line"><span class="function">multiset&lt;<span class="type">float</span>&gt; <span class="title">ms3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">multiset&lt;string, greater&lt;string&gt;()&gt; <span class="built_in">ms4</span>(begin, end);</span><br><span class="line"><span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">ms5</span><span class="params">(s2)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="容器的大小"><a href="#容器的大小" class="headerlink" title="容器的大小"></a>容器的大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">size</span>();     <span class="comment">//返回容器中实际元素个数</span></span><br><span class="line">s.<span class="built_in">empty</span>();    <span class="comment">//判断容器是否为空</span></span><br><span class="line">s.<span class="built_in">max_size</span>(); <span class="comment">//返回容器容量</span></span><br></pre></td></tr></table></figure><p>上述函数调用中的s指集合容器，如无特殊说明，s既可以是set容器也可以是multiset容器，即两个容器都提供了这样的函数。<br>容器元素的查找和统计</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(elem);</span><br><span class="line">s.<span class="built_in">count</span>(elem);</span><br></pre></td></tr></table></figure><p>对于set容器，count()函数的返回值只能是0或1；对于multiset容器，count()函数返回值可能大于1。<br>容器的迭代器<br>set与multiset容器支持迭代器操作，提供了iterator、const_iterator、reverse_iterator和const_reverse_iterator四种迭代器，并且提供了获取这四种迭代器的成员函数。set与multiset的迭代用法与vector迭代器相同。</p><h4 id="插入和删除元素-1"><a href="#插入和删除元素-1" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><p>set与multiset容器提供了insert()函数与erase()函数，用于向容器中插入和删除元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(elem);       <span class="comment">//在容器中插入元素elem</span></span><br><span class="line">s.<span class="built_in">insert</span>(pos, elem);  <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">s.<span class="built_in">insert</span>(begin, end); <span class="comment">//在容器中插入[begin,end)区间的元素</span></span><br></pre></td></tr></table></figure><p>第一种形式的insert()函数将元素elem插入容器中。对于set容器，第一种形式的insert()函数调用的返回值是一个pair&lt;iterator,bool&gt;对象。pair&lt;iterator,bool&gt;对象的第一个参数iterator是迭代器，指示元素插入的位置；第二个参数bool类型的值代表元素是否插入成功。这是因为set容器中不允许存在重复的元素，如果要插入一个容器中已存在的元素，则插入操作会失败，而pair中的bool值标志插入是否成功。multiset容器则不存在这样的情况，因此multiset容器返回的是一个iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(elem);       <span class="comment">//删除元素elem</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s; <span class="comment">//创建set容器s，元素按降序排列</span></span><br><span class="line">    multiset&lt;<span class="type">char</span>&gt; ms;        <span class="comment">//创建multiset容器ms</span></span><br><span class="line">                              <span class="comment">//向s中插入元素</span></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ps;</span><br><span class="line">    ps = s.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps.second == <span class="literal">true</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;insert success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">39</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">//向ms中插入元素</span></span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    ms.<span class="built_in">insert</span>(<span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">    <span class="comment">//输出两个容器中的元素</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt;::iterator its; <span class="comment">//创建容器s的迭代器，用于获取元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s容器中元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (its = s.<span class="built_in">begin</span>(); its != s.<span class="built_in">end</span>(); its++)</span><br><span class="line">        cout &lt;&lt; *its &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    multiset&lt;<span class="type">char</span>&gt;::iterator itms; <span class="comment">//创建容器ms的迭代器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ms容器中元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (itms = ms.<span class="built_in">begin</span>(); itms != ms.<span class="built_in">end</span>(); itms++)</span><br><span class="line">        cout &lt;&lt; *itms &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//查找容器ms中元素u的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ms容器中u元素个数：&quot;</span> &lt;&lt; ms.<span class="built_in">count</span>(<span class="string">&#x27;u&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多学一招：pair类模板"><a href="#多学一招：pair类模板" class="headerlink" title="多学一招：pair类模板"></a>多学一招：pair类模板</h4><p>在头文件utility中，定义了一个类模板pair。pair类模板的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> T2 second_type;</span><br><span class="line">    T1 first;</span><br><span class="line">    T2 second;</span><br><span class="line">    <span class="built_in">pair</span>() : <span class="built_in">first</span>(<span class="built_in">T1</span>()), <span class="built_in">second</span>(<span class="built_in">T2</span>()) &#123;&#125;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> T1 &amp;a, <span class="type">const</span> T2 &amp;b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">    <span class="comment">// 允许使用兼容的pair进行复制构造</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">pair</span>(<span class="type">const</span> pair&lt;U1, U2&gt; &amp;p) : <span class="built_in">first</span>(p.first), <span class="built_in">second</span>(p.second) &#123;&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pair的主要作用是将两个数据进行组合，用来表示一个二元组或一个元素对，两个数据可以是同一个类型，也可以是不同的类型。当需要将两个元素组合在一起时，可以选择构造pair对象。当一个函数需要返回两个数据时，可以返回一个pair对象。例如，set容器的insert()函数第一种重载形式，就返回一个pair对象。下面讲解一下pair对象的创建与使用。</p><h4 id="创建pair对象"><a href="#创建pair对象" class="headerlink" title="创建pair对象"></a>创建pair对象</h4><p>创建pair对象可以调用pair的构造函数，还可以调用STL提供的make_pair()函数。make_pair()是一个函数模板，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function">pair&lt;V1, V2&gt; <span class="title">make_pair</span><span class="params">(T1 &amp;&amp;t, T2 &amp;&amp;u)</span></span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="pair对象的使用"><a href="#pair对象的使用" class="headerlink" title="pair对象的使用"></a>pair对象的使用</h4><p>pair类模板提供了两个成员变量first与second，first表示pair对象中的第一个元素，second表示第二个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>, string&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p1.first &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p1.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个pair对象p1，p1.first获取的是第一个元素，即int类型的1；p1.second获取的是第二个元素，即string类型的”abc”。</p><h3 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h3><p>m ap与multim ap称为映射，映射与集合的主要区别在于，集合的元素是键本身，而映射的元素是由键和附加数据构成的二元组，它很像“字典”，通过给定的键，可以快速找出与键对应的值。因此，映射的二叉树节点中存储了两个数据，一个是用来定位的数据，称为键；另一个是与键对应的数据，称为值。通常也说，映射中存储的是一键值对，映射的一种通常用法就是根据键查找对应的值。映射可分为单重映射（m ap）与多重映射（multim ap），两者的主要区别是：m ap存储的是无重复键的元素对，而multim ap允许相同的键重复出现，即一个键可以对应多个值，如图7-14所示。</p><h4 id="创建map与multimap容器"><a href="#创建map与multimap容器" class="headerlink" title="创建map与multimap容器"></a>创建map与multimap容器</h4><p>map与multimap重载了多个构造函数，因此m ap和multim ap容器的创建方式有多种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;T1, T2&gt; m;                 <span class="comment">//创建一个空的map容器</span></span><br><span class="line">map&lt;T1, T2, op&gt; m;             <span class="comment">//创建一个空的map容器，以op为准则排序</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(begin, end)</span></span>;     <span class="comment">//创建一个map容器，用[begin, end)区间赋值</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(begin, end, op)</span></span>; <span class="comment">//创建一个map容器，用[begin, end)区间赋值，op为排序准则</span></span><br><span class="line"><span class="function">map&lt;T1, T2&gt; <span class="title">m</span><span class="params">(m1)</span></span>;             <span class="comment">//创建一个map容器，用另一个map容器m1初始化</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">float</span>, greater&lt;<span class="type">int</span>&gt;()&gt; m2;</span><br><span class="line"><span class="function">map&lt;string, <span class="type">int</span>&gt; <span class="title">m3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">map&lt;string, <span class="type">int</span>, greater&lt;string&gt;()&gt; <span class="built_in">m4</span>(begin, end);</span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">m5</span><span class="params">(m1)</span></span></span><br></pre></td></tr></table></figure><p>上述代码分别调用不同的构造函数创建了五个m ap容器。需要注意的是，创建m ap容器时，类型参数必须有两个，这两个类型参数可以相同，也可以不同。multim ap容器的创建方式与m ap容器相同，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mt1;</span><br><span class="line">multimap&lt;<span class="type">char</span>, <span class="type">float</span>, greater&lt;<span class="type">int</span>&gt;()&gt; mt2;</span><br><span class="line"><span class="function">multimap&lt;string, <span class="type">int</span>&gt; <span class="title">mt3</span><span class="params">(begin, end)</span></span>;</span><br><span class="line">multimap&lt;string, <span class="type">int</span>, greater&lt;string&gt;()&gt; <span class="built_in">mt4</span>(begin, end);</span><br><span class="line"><span class="function">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mt5</span><span class="params">(m1)</span></span></span><br></pre></td></tr></table></figure><h4 id="容器大小"><a href="#容器大小" class="headerlink" title="容器大小"></a>容器大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">cout</span>(key);</span><br><span class="line">m.<span class="built_in">max_size</span>();</span><br><span class="line">m.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>由于m ap容器中无重复元素，因此m ap容器的count()函数返回值只有0和1，而multim ap容器的count()函数返回值可能大于1。<br>容器元素的访问<br>map容器重载了“[]”运算符，可以通过m[key]的方式获取key对应的值。此外，m ap容器也提供了at()函数用于访问指定键对应的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[key];</span><br><span class="line">m.<span class="built_in">at</span>(key);</span><br></pre></td></tr></table></figure><p>m ap容器可以通过上述两种方式随机访问容器中元素，但multim ap容器中允许存在重复的键值，因此无法使用上述两种方式随机访问容器中元素。通过“[]”运算符和at()函数可以访问m ap容器中的元素，那么同样通过“[]”运算符和at()函数可以修改容器中的元素，示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[key] = value;</span><br><span class="line">m.<span class="built_in">at</span>(key) = value;</span><br></pre></td></tr></table></figure><p>如果key尚未存在，则插入元素对；如果key已存在，则新插入的value覆盖key原来的值。<br>容器的迭代器<br>如果key尚未存在，则插入元素对；如果key已存在，则新插入的value覆盖key原来的值。</p><h4 id="插入和删除元素-2"><a href="#插入和删除元素-2" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">insert</span>(elem);       <span class="comment">//在容器中插入元素elem</span></span><br><span class="line">m.<span class="built_in">insert</span>(pos, elem);  <span class="comment">//在pos位置插入元素elem</span></span><br><span class="line">m.<span class="built_in">insert</span>(begin, end); <span class="comment">//在容器中插入[begin, end)区间的值</span></span><br><span class="line">m.<span class="built_in">erase</span>(pos);        <span class="comment">//删除pos位置上的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(begin, end); <span class="comment">//删除[begin, end)区间内的元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(key);        <span class="comment">//删除键为key的元素对</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义printm()函数输出map容器元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printm</span><span class="params">(map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; mymap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt; p;           <span class="comment">//创建pair对象p</span></span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">double</span>&gt;::iterator it; <span class="comment">//定义map的iterator迭代器it</span></span><br><span class="line">    <span class="keyword">for</span> (it = mymap.<span class="built_in">begin</span>(); it != mymap.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (pair&lt;<span class="type">char</span>, <span class="type">double</span>&gt;)*it;                 <span class="comment">//将迭代器指向的一对元素存放到p中</span></span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.second &lt;&lt; endl; <span class="comment">//输出一对元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义printmt()函数输出multimap容器元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printmt</span><span class="params">(multimap&lt;<span class="type">int</span>, string&gt; mymul)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">    multimap&lt;<span class="type">int</span>, string&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mymul.<span class="built_in">begin</span>(); it != mymul.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (pair&lt;<span class="type">int</span>, string&gt;)*it;</span><br><span class="line">        cout &lt;&lt; p.first &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; m; <span class="comment">//创建一个map容器m</span></span><br><span class="line">    <span class="comment">//向容器m中插入元素</span></span><br><span class="line">    m[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1.2</span>;</span><br><span class="line">    m[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3.6</span>;</span><br><span class="line">    m[<span class="string">&#x27;c&#x27;</span>] = <span class="number">6.4</span>;</span><br><span class="line">    m[<span class="string">&#x27;d&#x27;</span>] = <span class="number">0.8</span>;</span><br><span class="line">    m[<span class="string">&#x27;e&#x27;</span>] = <span class="number">5.3</span>;</span><br><span class="line">    m[<span class="string">&#x27;f&#x27;</span>] = <span class="number">3.6</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printm</span>(m); <span class="comment">//调用printm()函数输出容器m中的元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map中key=a的值：&quot;</span> &lt;&lt; m.<span class="built_in">at</span>(<span class="string">&#x27;a&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;map中key=f的元素个数：&quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="string">&#x27;f&#x27;</span>) &lt;&lt; endl;</span><br><span class="line">    multimap&lt;<span class="type">int</span>, string&gt; mt; <span class="comment">//创建一个multimap容器mt</span></span><br><span class="line">    <span class="comment">//向容器mt中插入元素</span></span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;China&quot;</span>));</span><br><span class="line">    mt.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;!&quot;</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;multimap: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printmt</span>(mt); <span class="comment">//调用printmt()函数输出容器mt中的元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>C++标准库中提供了三个容器适配器：stack（栈）、queue（队列）和priority queue（优先队列）。这三种容器适配器提供了简单易用的接口，满足了编程中的特殊数据处理需求，本节将针对这三种容器适配器进行讲解。</p><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stack中的元素具有后进先出的特点。stack只能从一端插入、删除、读取元素，不允许一次插入或删除多个元素，且不支持迭代器操作。</p><h4 id="创建stack"><a href="#创建stack" class="headerlink" title="创建stack"></a>创建stack</h4><ol><li>创建空的stack<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br></pre></td></tr></table></figure></li><li>创建存储序列容器的stack<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建vector容器v</span></span><br><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(v); <span class="comment">//创建stack容器适配器s，存储容器v</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h4><p>stack除了具有vector容器相同功能的成员函数，如empty()、size()、emplace()和swap()函数，还提供以下操作函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span> <span class="comment">//包含头文件stack</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建vector容器v</span></span><br><span class="line">    stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(v); <span class="comment">//创建stack容器适配器s</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    s.<span class="built_in">emplace</span>(<span class="number">5</span>);</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>queue中的元素具有先进先出的特点，元素只能从一端使用push()函数进行插入，从另一端使用pop()函数进行删除。<br>queue也不允许一次插入或删除多个元素，且不支持迭代器操作。queue创建对象的方式与stack相同，并且其接口与stack大部分都相同。除了提供了与vector相同的接口，queue还提供两个自己特有的成员函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//包含头文件queue</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">//创建list容器l</span></span><br><span class="line">    queue&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">q</span>(l); <span class="comment">//创建queue容器适配器q</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    q.<span class="built_in">emplace</span>(<span class="number">5</span>);</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素&quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;  <span class="comment">//获取第一个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最后一个元素&quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl; <span class="comment">//获取最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例7-9中，第7行代码创建了list容器l。第8行代码创建了queue容器适配器q，封装容器l。第9～10行代码分别调用push()函数和em place()函数在q尾部插入元素4和5。第11行代码调用pop()函数删除q头部元素，即第一个元素。第12～13行代码分别调用front()函数和back()函数获取第一个元素和最后一个元素并输出。由图7-20可知，程序输出的第一个元素和最后一个元素分别是2和5。第14～18行代码在while循环中调用front()函数获取第一个元素并输出，然后调用pop()函数删除第一个元素。由图7-20可知，程序成功输出了q中的元素。</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>priority_queue中的元素可以按照自定义的方式进行动态排序。向priority_queue中插入或删除元素时，priority_queue会动态地调整，以保证元素有序。priority_queue的存储结构如图7-21所示。priority_queue创建方式与queue相同，只是在创建priority_queue时，可以指定优先规则，即最后一个模板参数可以是一个函数对象，指定元素排序规则。创建priority_queue的示例代码如下：</p><p>priority_queue的接口与queue相同，使用比较简单。下面通过案例演示priority_queue的具体用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q1.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q1);</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, Comp&gt; q2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>&#125;)</span><br><span class="line">        q2.<span class="built_in">push</span>(n);</span><br><span class="line">    <span class="built_in">print</span>(q2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>通过迭代器既可分离容器与算法，又可连接容器与算法。从容器的角度看，只需提供适当的迭代器，就可以遍历容器中的数据，而不必关心数据将用于何种操作；从算法的角度看，只需要通过迭代器操作数据，不必关心是什么类型的容器。容器设计者只需要专注于容器的设计，算法设计者只需要专注于算法的设计，这样就可以很好地实现数据结构与算法的分离。STL提供了五种基本的迭代器：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机迭代器。</p><h3 id="输入迭代器与输出迭代器"><a href="#输入迭代器与输出迭代器" class="headerlink" title="输入迭代器与输出迭代器"></a>输入迭代器与输出迭代器</h3><p>输入迭代器和输出迭代器是最基本、要求最低的迭代器，几乎所有的迭代器都具备这两个迭代器的功能。</p><h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><p>输入迭代器（Input Iterator）只能一次一个地向后读取元素，并按此顺序传回元素值。输入迭代器支持对序列进行不可重复的单向遍历。</p><p>如果有两个输入迭代器itr1和itr2，且有itr1&#x3D;&#x3D;itr2，但这并不保证++itr1&#x3D;&#x3D;++itr2，更不能保证*(++itr1)&#x3D;&#x3D;*(++itr2)。因此，使用输入迭代器读入的序列不能保证是可重复的。</p><h4 id="输入迭代器-1"><a href="#输入迭代器-1" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><p>输出迭代器（Output Iterator）与输入迭代器相反，其作用是将元素逐个写入容器。输出迭代器也支持对序列进行单向遍历，当把迭代器移到下一个位置后，也不能保证之前的迭代器是有效的。</p><h4 id="前向迭代器"><a href="#前向迭代器" class="headerlink" title="前向迭代器"></a>前向迭代器</h4><p>前向迭代器（Forward Iterator）是输入迭代器和输出迭代器的集合，具有输入迭代器和输出迭代器的全部功能。前向迭代器支持对序列进行可重复的单向遍历，可以多次解析一个迭代器指定的位置，因此可以对一个值进行多次读写。前向迭代器去掉了输入迭代器与输出迭代器的一些不确定性，例如，如果有两个前向迭代器itr1和itr2，且有itr1&#x3D;&#x3D;itr2，那么++itr1&#x3D;&#x3D;++itr2一定是成立的。前后两次使用相等的前向迭代器读取同一个序列，只要序列的值在这个过程中没有被改写，就一定会得到相同的结果。<br>####双向迭代器与随机访问迭代器<br>双向迭代器（Bidirectional Iterator）是在前向迭代器的基础上增加了一个反向操作，即双向迭代器既可以前进，又可以后退，因此它比前向迭代器新增一个功能，可以进行自减操作，如itr++或者++itr。<br>随机访问迭代器（Random Iterator）是在双向迭代器的基础上又支持直接将迭代器向前或向后移动n个元素，而且还支持比较运算的操作。因此，随机访问迭代器的功能几乎和指针一样。随机访问迭代器支持的操作如表7-7所示。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法实际上是一系列的函数模板，STL定义了大约70个算法，这些算法以迭代器为参数，可以处理各种类型容器的元素。学习STL算法时，读者可以不必知道算法是如何设计的，但需要知道如何在自己的程序中使用这些算法。本节将介绍STL算法。</p><h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="算法的头文件"><a href="#算法的头文件" class="headerlink" title="算法的头文件"></a>算法的头文件</h4><p>STL中提供的所有算法都包含在algorithm、numeric、functional三个头文件中。<br>其中，algorithm是最大的一个算法头文件，它由一系列函数模板组成，涉及的功能有比较、交换、查找、遍历、复制、修改、删除、合并、排序等。<br>numeric比较小，只包括在容器中进行简单数学运算的几个函数模板。<br>functional中定义了一些类模板，用于生成一些函数对象。</p><h4 id="算法的分类"><a href="#算法的分类" class="headerlink" title="算法的分类"></a>算法的分类</h4><p>STL中的算法大致可分为4类，分别如下所示。<br>不可变序列算法：不可变序列算法可以获取容器元素执行一定的操作，但算法不会改动原容器中元素的次序，也不改动元素值。<br>可变序列算法：可变序列算法能够修改容器中的元素值。由于可变序列算法可以修改元素的值，而迭代器指向的位置可能并不可用，可能会导致程序出错，因此可变序列算法对操作区间有一定要求。<br>排序算法：排序算法包括对序列进行排序、合并、搜索等，有序序列的集合操作以及堆操作相关算法也涉及排序，所有这些算法都通过对序列元素的比较操作完成。排序算法一般通过对容器中元素的赋值和交换来改变元素顺序。<br>数值算法：数值算法主要是对容器中的元素进行数值计算，例如，容器元素的累加计算、相邻元素差等。</p><h3 id="常用的算法"><a href="#常用的算法" class="headerlink" title="常用的算法"></a>常用的算法</h3><h4 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each()算法"></a>for_each()算法</h4><p>for_each()属于不可变序列算法，该算法可以依次处理容器中的每一个元素。for_each()算法原型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt; </span></span><br><span class="line"><span class="function"><span class="title">for_each</span><span class="params">(InputIterator begin, InputIterator end, Function fun</span></span></span><br></pre></td></tr></table></figure><p>在上述算法原型中，参数begin、end表示要操作的元素区间；参数func是一个函数对象，表示对[begin,end)区间中的每个元素要施加的操作。for_each()算法只是对取出的元素进行相应操作，它不会对容器中的元素做任何修改，也不会改变原来容器的元素次序。</p><h4 id="find-算法"><a href="#find-算法" class="headerlink" title="find()算法"></a>find()算法</h4><p>find()也是不可变序列算法，用于在指定区间查找某一元素是否存在。find()算法原型如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">(InputIterator begin, InputIterator end, <span class="type">const</span> T&amp; valu</span></span></span><br></pre></td></tr></table></figure><p>在上述算法原型中，参数begin、end表示要查找的元素区间；参数value表示要查找的元素值。find()算法是在[begin,end)区间查找value元素是否存在，如果存在，就返回指向这个元素的迭代器；如果不存在，就返回指向容器末尾的迭代器。</p><h4 id="copy-算法"><a href="#copy-算法" class="headerlink" title="copy()算法"></a>copy()算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator&gt; </span></span><br><span class="line"><span class="function">OutputIterator <span class="title">copy</span><span class="params">(InputIterator begin, InputIterator end, OutputIterator DestBe</span></span></span><br></pre></td></tr></table></figure><p>在上述算法原型中，参数begin、end表示要复制的元素区间；参数D estBeg表示目的存储空间的起始位置。由于在讲解迭代器时，已经多次调用copy()函数将元素复制到cout流对象中从而输出到屏幕，因此这里不再赘述。</p><h4 id="sort-算法"><a href="#sort-算法" class="headerlink" title="sort()算法"></a>sort()算法</h4><p>sort()算法属于可变序列算法，用于对容器元素进行排序。sort()算法有两种重载形式，分别如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt&gt; <span class="comment">//第一种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Pred&gt; <span class="comment">//第二种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end, Pred op)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt&gt; <span class="comment">//第一种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Pred&gt; <span class="comment">//第二种形式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RanIt begin, RanIt end, Pred op)</span></span>;</span><br></pre></td></tr></table></figure><p>第一种形式是默认的，按从小到大的顺序排列容器中的元素；第二种形式可以指定排序规则。第二种重载形式比第一种形式更加通用。</p><h4 id="accumulate-算法"><a href="#accumulate-算法" class="headerlink" title="accumulate()算法"></a>accumulate()算法</h4><p>accumulate()算法属于数值算法，用于累加指定区间的元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">T <span class="title">accumulate</span><span class="params">(InputIterator begin, InputIterator end, T ini</span></span></span><br></pre></td></tr></table></figure><p>在上述算法原型中，参数begin、end表示要累加的元素区间；参数init表示累加的初始值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Multi</span> <span class="comment">//定义类模板</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Multi</span>(<span class="type">const</span> T &amp;v) : <span class="built_in">value</span>(v) &#123;&#125; <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;elem)</span> <span class="type">const</span>  <span class="comment">//重载“()”运算符</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        elem *= value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">assign</span>(arr, arr + <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//用数组为v容器赋值                                                  //调用for_each()函数将容器中每个元素都乘以2</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>(), <span class="built_in">Multi</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//调用copy()构造函数将容器中的元素输出到屏幕</span></span><br><span class="line">    <span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用find()算法查找容器中是否存在值为200的元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器中有值为200的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;容器中不存在值为200的元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用sort()算法将容器中的元素从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序之后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//累加容器中的元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-STL&quot;&gt;&lt;a href=&quot;#第七章-STL&quot; class=&quot;headerlink&quot; title=&quot;第七章 STL&quot;&gt;&lt;/a&gt;第七章 STL&lt;/h1&gt;&lt;p&gt;STL主要由六个部分组成：空间配置器（Allocator）、适配器（Adapters）、容器（Con</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c6/"/>
    <id>http://example.com/2022/12/18/c6/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:17.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-模板"><a href="#第六章-模板" class="headerlink" title="第六章 模板"></a>第六章 模板</h1><p>模板是C++支持参数化多态的工具，是泛型编程的基础。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型占位符&gt;</span><br><span class="line">返回值类型 函数名(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//定义函数模板</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T t1, T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;     <span class="comment">//传入int类型参数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.2</span>, <span class="number">4.2</span>) &lt;&lt; endl; <span class="comment">//传入double类型参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模板实例化"><a href="#函数模板实例化" class="headerlink" title="函数模板实例化"></a>函数模板实例化</h3><ol><li>隐式实例化<br>隐式实例化是根据函数调用时传入的参数的数据类型确定模板参数T的类型，模板参数的类型是隐式确定的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> t1, <span class="type">int</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当传入double类型的数据时，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> t1, <span class="type">double</span> t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>每一次调用时都会根据不同的类型实例化出不同类型的函数，最终的可执行程序的大小并不会减少，只是提高了代码的复用性。</li><li>显式实例化<br>每一次调用时都会根据不同的类型实例化出不同类型的函数，最终的可执行程序的大小并不会减少，只是提高了代码的复用性。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">int</span> <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> t1, <span class="type">int</span> t2);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T t1, T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">int</span> <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> t1, <span class="type">int</span> t2); <span class="comment">//显式实例化为int类型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>, <span class="string">&#x27;B&#x27;</span>) &lt;&lt; endl; <span class="comment">//函数模板调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.2</span>, <span class="number">3.4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第8行代码显式声明add()函数模板，指定模板参数类型为int。在调用int类型模板函数时，传入了一个字符’B’，则编译器会将字符类型的’B’转换为对应的ASCII码值，然后再与10相加得出结果。实际上就是隐式的数据类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在要调换两个学生的id编号，但是又不想交换学生的姓名、成绩等其他信息，那么此时就可以用显式具体化解决这个问题，重新定义函数模板只交换结构体的部分数据成员。显式具体化的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;Student&gt;(Student &amp;s1, Student &amp;t2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = s1.id;</span><br><span class="line">    s1.id = s2.id;</span><br><span class="line">    s2.id = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数有多个原型，则编译器在选择函数调用时，非模板函数优先于模板函数，显式具体化模板优先于函数模板，例如下面三种定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;)</span></span>; <span class="comment">//直接定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//模板定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T &amp;t1, T &amp;t2)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;); <span class="comment">//显式具体化</span></span><br></pre></td></tr></table></figure><p>对于int a，int b，如果存在swap(a,b)的调用，则优先调用直接定义的函数；如果没有，则优先调用显式具体化，如果两者都没有才会调用函数模板。</p><h3 id="函数模板重载"><a href="#函数模板重载" class="headerlink" title="函数模板重载"></a>函数模板重载</h3><p>函数模板可以进行实例化，以支持不同类型的参数，不同类型的参数调用会产生一系列重载函数<br>函数模板本身也可以被重载，即名称相同的函数模板可以具有不同的函数模板定义，当进行函数调用时，编译器根据实参的类型与个数决定调用哪个函数模板实例化函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span> <span class="comment">//非模板函数，求两个int类型数据的较大值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//定义求两个任意类型数据的较大值</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T &amp;t1, T &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t1 &gt; t2) ? t1 : t2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//定义求三个任意类型数据的最大值</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(<span class="type">const</span> T &amp;t1, <span class="type">const</span> T &amp;t2, <span class="type">const</span> T &amp;t3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(t1, t2), t3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;     <span class="comment">//调用非模板函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;&lt; endl;  <span class="comment">//调用三个参数的函数模板</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>) &lt;&lt; endl; <span class="comment">//调用两个参数的函数模板</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="number">6</span>, <span class="number">3.2</span>) &lt;&lt; endl;   <span class="comment">//调用非模板函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="脚下留心：使用函数模板要注意的问题"><a href="#脚下留心：使用函数模板要注意的问题" class="headerlink" title="脚下留心：使用函数模板要注意的问题"></a>脚下留心：使用函数模板要注意的问题</h3><p>（1）&lt;&gt;中的每一个类型参数在函数模板参数列表中必须至少使用一次。例如，下面的函数模板声明是不正确的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T1 t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）全局作用域中声明的与模板参数同名的对象、函数或类型，在函数模板中将被隐藏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T num;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">//输出的是局部变量num，全局int类型的num被屏蔽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数体内访问的num是T类型的变量num，而不是全局int类型的变量num。<br>（3）函数模板中声明的对象或类型不能与模板参数同名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">float</span> T; <span class="comment">//错误，定义的类型与模板参数名相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）模板参数名在同一模板参数列表中只能使用一次，但可在多个函数模板声明或定义之间重复使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T&gt; <span class="comment">//错误，在同一个模板中重复定义模板参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(T t1, T t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T t1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在不同函数模板中可重复使用相同的模板参数名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(T t1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）模板的定义和多处声明所使用的模板参数名不是必须相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板的前向声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line"><span class="comment">//模板的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(U t1, U t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）如果函数模板有多个模板参数，则每个模板参数前都必须使用关键字class或typename修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="comment">//两个关键字可以混用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt; <span class="comment">//错误，每一个模板参数前都必须有关键字修饰</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类也可以像函数一样被不同的类型参数化，如STL中的vector容器就是典型的例子，使用vector不需要关心容器中的数据类型，就可以对数据进行操作。</p><h3 id="类模板定义与实例化"><a href="#类模板定义与实例化" class="headerlink" title="类模板定义与实例化"></a>类模板定义与实例化</h3><p>函数可以定义函数模板，同样地，对于类来说，也可以定义一个类模板。类模板是针对成员数据类型不同的类的抽象，它不是一个具体实际的类，而是一个类型的类，一个类模板可以生成多种具体的类。类模板的定义格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 类型占位符&gt;</span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板中的关键字含义与函数模板相同。需要注意的是，类模板的模板参数不能为空。一旦声明类模板，就可以用类模板的参数名声明类中的成员变量和成员函数，即在类中使用数据类型的地方都可以使用模板参数名来声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">    <span class="function">T <span class="title">func</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A&lt;<span class="type">int</span>&gt; a;</span><br></pre></td></tr></table></figure><p>这样类A中凡是用到模板参数的地方都会被int类型替换。如果类模板有多个模板参数，创建对象时，多个类型之间要用逗号分隔开。例如，定义一个有两个模板参数的类模板B，然后用B创建类对象，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 a;</span><br><span class="line">    T2 b;</span><br><span class="line">    <span class="function">T1 <span class="title">func</span><span class="params">(T1 a, T2 &amp;b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">B&lt;<span class="type">int</span>, string&gt; b; <span class="comment">//创建模板类B&lt;int,string&gt;的对象b</span></span><br></pre></td></tr></table></figure><p>使用类模板时，必须要为模板参数显式指定实参，不存在实参推演过程，也就是说不存在将整型值10推演为int类型再传递给模板参数的过程，必须要在&lt;&gt;中指定int类型，这一点与函数模板不同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    T *_ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(T arr[], <span class="type">int</span> s);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//类模板外定义其成员函数</span></span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(T arr[], <span class="type">int</span> s)</span><br><span class="line">&#123;</span><br><span class="line">    _ptr = <span class="keyword">new</span> T[s];</span><br><span class="line">    _size = s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _ptr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//类模板外定义其成员函数</span></span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; i++)</span><br><span class="line">        cout &lt;&lt; *(_ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> cArr[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line">    <span class="function">Array&lt;<span class="type">char</span>&gt; <span class="title">a1</span><span class="params">(cArr, <span class="number">5</span>)</span></span>; <span class="comment">//创建类模板的对象</span></span><br><span class="line">    a1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="type">int</span> iArr[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">3</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a2</span><span class="params">(iArr, <span class="number">10</span>)</span></span>;</span><br><span class="line">    a2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板的派生"><a href="#类模板的派生" class="headerlink" title="类模板的派生"></a>类模板的派生</h3><ol><li>类模板派生普通类<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> <span class="comment">//类模板Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x;</span><br><span class="line">    T y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>();</span><br><span class="line">    <span class="built_in">Base</span>(T x, T y);</span><br><span class="line">    <span class="function">Base <span class="title">getx</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Base <span class="title">gety</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base&lt;<span class="type">double</span>&gt; <span class="comment">//普通类Derive公有继承类模板Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c) : <span class="built_in">num</span>(c), <span class="built_in">Base</span>&lt;<span class="type">double</span>&gt;(a, b) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>类模板派生类模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T _a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(T n) : _a(n) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base&lt;U&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U _b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(T t, U u) : <span class="built_in">Base</span>&lt;T&gt;(t), _b(u) &#123;&#125;</span><br><span class="line">    <span class="function">U <span class="title">sum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _b + <span class="built_in">U</span>(Base::<span class="built_in">get</span>()); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>普通类派生类模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> n) : _a(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    T _b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> n, T t) : <span class="built_in">Base</span>(n), _b(t) &#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _b + (T)<span class="built_in">get</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="类模板与友元函数"><a href="#类模板与友元函数" class="headerlink" title="类模板与友元函数"></a>类模板与友元函数</h3><ol><li>非模板友元函数<br>非模板友元函数就是将一个普通函数声明为友元函数。例如，在一个类模板中声明一个友元函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="type">_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>除此之外，还可以将带有模板类参数的函数声明为友元函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T <span class="type">_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;T&gt; &amp;a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在上述代码中，show()函数并不是函数模板，只是有一个模板类参数。调用带有模板类参数的友元函数时，友元函数必须显式具体化，指明友元函数要引用的参数的类型，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;<span class="type">int</span>&gt;&amp; a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;<span class="type">double</span>&gt;&amp; a)</span></span>;</span><br></pre></td></tr></table></figure>上述代码中，模板参数为int类型的show()函数是<code>A&lt;int&gt;</code>类的友元函数，模板参数为double类型的show()函数是<code>A&lt;double&gt;</code>类的友元函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    T _item;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count; <span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> T &amp;t) : _item(t) &#123; _count++; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; _count--; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;              <span class="comment">//无参友元函数func()</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;T&gt; &amp;a)</span></span>; <span class="comment">//有参友元函数show()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> A&lt;T&gt;::_count = <span class="number">0</span>; <span class="comment">//初始化静态变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>           <span class="comment">// func()函数实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int count:&quot;</span> &lt;&lt; A&lt;<span class="type">int</span>&gt;::_count &lt;&lt; <span class="string">&quot;;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double count:&quot;</span> &lt;&lt; A&lt;<span class="type">double</span>&gt;::_count &lt;&lt; <span class="string">&quot;;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板参数为int类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;int:&quot;</span> &lt;&lt; a._item &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> A&lt;<span class="type">double</span>&gt; &amp;a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;double:&quot;</span> &lt;&lt; a._item &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();       <span class="comment">//调用无参友元函数</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//创建int类型对象</span></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="function">A&lt;<span class="type">double</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1.2</span>)</span></span>;</span><br><span class="line">    <span class="built_in">show</span>(a); <span class="comment">//调用有参友元函数</span></span><br><span class="line">    <span class="built_in">show</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>约束模板友元函数<br>约束模板友元函数是将一个函数模板声明为类的友元函数。函数模板的实例化类型取决于类模板被实例化时的类型，类模板实例化时会产生与之匹配的具体化友元函数。在使用约束模板友元函数时，首先需要在类模板定义的前面声明函数模板。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T &amp;t)</span></span>;</span><br></pre></td></tr></table></figure>声明函数模板之后，在类模板中将函数模板声明为友元函数。在声明友元函数时，函数模板要实现具体化，即函数模板的模板参数要与类模板的模板参数保持一致，以便类模板实例化时产生与之匹配的具体化友元函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//其他成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">func</span>&lt;U&gt;();               <span class="comment">//声明无参友元函数func()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(A&lt;U&gt; &amp;a); <span class="comment">//声明有参友元函数show()</span></span><br><span class="line">    …                            <span class="comment">//其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//声明函数模板func()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//声明函数模板show()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T &amp;t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    U _item;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> U &amp;u) : _item(u) &#123; _count++; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; _count--; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">func</span>&lt;U&gt;();       <span class="comment">//声明友元函数func()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> show&lt;&gt;(A&lt;U&gt; &amp;a); <span class="comment">//声明友元函数show()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">int</span> A&lt;T&gt;::_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//函数模板func()的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A&lt;T&gt;) &lt;&lt; <span class="string">&quot;;&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template func():&quot;</span> &lt;&lt; A&lt;T&gt;::_count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//函数模板show()的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; t._item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();      <span class="comment">//调用int类型的函数模板实例，int类型，其大小为4字节</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">//定义A&lt;int&gt;类对象a</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;     <span class="comment">//定义A&lt;int&gt;类对象b</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.2</span>)</span></span>; <span class="comment">//定义A&lt;double&gt;类对象c</span></span><br><span class="line">    <span class="built_in">show</span>(a);          <span class="comment">//调用show()函数，输出类对象a的值</span></span><br><span class="line">    <span class="built_in">show</span>(b);          <span class="comment">//调用show()函数，输出类对象b的值</span></span><br><span class="line">    <span class="built_in">show</span>(c);          <span class="comment">//调用show()函数，输出类对象c的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func&lt;int&gt;output:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//运行到此，已经创建了两个int类型对象</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func&lt;double&gt;()output:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>非约束模板友元函数<br>非约束模板友元函数是将函数模板声明为类模板的友元函数，但函数模板的模板参数不受类模板影响，即友元函数模板的模板参数与类模板的模板参数是不同的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(U &amp;u, V &amp;v)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>在上述代码中，类模板A将函数模板show()声明为友元函数，但show()的模板参数U、V不受类模板A的模板参数T影响，则函数模板show()就是类模板A的非约束友元函数。函数模板show()的每个模板函数都是类模板A每个模板类的友元函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//定义类模板A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _item;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> T &amp;t) : _item(t) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">V</span>&gt; <span class="comment">//声明非约束模板友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">show</span><span class="params">(U &amp;u, V &amp;v)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt; <span class="comment">//函数模板show()的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(U &amp;u, V &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; u._item &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; v._item &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">//定义A&lt;int&gt;类对象a</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;     <span class="comment">//定义A&lt;int&gt;类对象b</span></span><br><span class="line">    <span class="function">A&lt;<span class="type">double</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.2</span>)</span></span>; <span class="comment">//定义A&lt;int&gt;类对象c</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a,b: &quot;</span>;</span><br><span class="line">    <span class="built_in">show</span>(a, b); <span class="comment">//调用show()函数，传入对象a、b作为实参</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a,c: &quot;</span>;</span><br><span class="line">    <span class="built_in">show</span>(a, c); <span class="comment">//调用show()函数，传入对象a、c作为实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>非约束模板友元函数的模板参数与类模板的模板参数不相关，它可以接受任何类型的参数。</li></ol><h2 id="模板的参数"><a href="#模板的参数" class="headerlink" title="模板的参数"></a>模板的参数</h2><ol><li>类型参数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T t1, T t2)</span></span>;</span><br></pre></td></tr></table></figure>T就是一个类型参数，类型参数的名称由用户自行确定，表示的是一个未知类型。模板的类型参数可以作为类型说明符用在模板中的任何地方，与内置类型说明符或类类型说明符的使用方式完全相同。可以为模板定义多个类型参数，也可以为类型参数指定默认值，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">func</span>(T, U);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>非类型参数<br>非类型参数是指内置类型参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> a&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> len&gt; <span class="comment">//非类型参数unsigned len</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="type">unsigned</span> i) <span class="comment">//重载“[]”运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= len)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;数组越界&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T arr[len];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="type">char</span>, <span class="number">5</span>&gt; arr1; <span class="comment">//定义一个长度为5的char类型数组</span></span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">10</span>&gt; arr2; <span class="comment">//定义一个长度为10的int类型数组</span></span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; arr1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) <span class="comment">//为int类型数组arr2赋值并输出</span></span><br><span class="line">        arr2[i] = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>使用非类型参数时，有以下几点需要注意。<br>（1）调用非类型参数的实参必须是常量表达式，即必须能在编译时计算出结果。<br>（2）任何局部对象、局部变量的地址都不是常量表达式，不能用作非类型的实参，全局指针类型、全局变量也不是常量表达式，也不能用作非类型的实参。<br>（3）sizeof()表达式结果是一个常量表达式，可以用作非类型的实参。<br>（4）非类型参数一般不用于函数模板。</li><li>模板类型参数<br>模板类型参数就是模板的参数为另一个模板，<br>template &lt;typename T, template &lt;typename U, typename Z&gt; class A&gt;<br>class Parameter<br>{<br>    A&lt;T, T&gt; a;<br>};<br>上述代码中，类模板Param eter的第二个模板参数就是一个类模板。需要注意的是，只有类模板可以作为模板参数，参数声明中必须要有关键字class。</li></ol><h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>特化就是将泛型的东西具体化，模板特化就是为已有的模板参数进行具体化的指定，使得不受任何约束的模板参数受到特定约束或完全被指定。<br>通过模板特化可以优化基于某种特定类型的实现，或者克服某种特定类型在实例化模板时出现的不足，如该类型没有提供某种操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Special</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Special</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">compare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _a &gt; _b ? _a : _b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _a;</span><br><span class="line">    T _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>全特化<br>全特化就是将模板中的模板参数全部指定为确定的类型，其标志就是产生出完全确定的东西。对于类模板，包括类的所有成员函数都要进行特化。进行类模板特化时，需要将类的成员函数重新定义为普通成员函数。在全特化时，首先使用tem plate&lt;&gt;进行全特化声明，然后重新定义需要全特化的类模板，并指定特化类型。下面通过案例演示类模板的全特化，<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Special</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Special</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">compare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> _a &gt; _b ? _a : _b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _a;</span><br><span class="line">    T _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类模板全特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Special</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt; <span class="comment">//指定特化类型为const char*</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Special</span>(<span class="type">const</span> <span class="type">char</span> *a, <span class="type">const</span> <span class="type">char</span> *b)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = a;</span><br><span class="line">        _b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">compare</span><span class="params">()</span> <span class="comment">//重新定义成员函数compare()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;类模板特化&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(_a, _b) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> _a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> _b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *_a;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建Special&lt;string&gt;类对象s</span></span><br><span class="line">    <span class="function">Special&lt;string&gt; <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;nihao&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s1.<span class="built_in">compare</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建Special&lt;const char*&gt;类对象s</span></span><br><span class="line">    <span class="function">Special&lt;<span class="type">const</span> <span class="type">char</span> *&gt; <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;nihao&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s2.<span class="built_in">compare</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>偏特化<br>偏特化就是模板中的模板参数没有被全部指定，需要编译器在编译时进行确定。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>将其中一个模板参数特化为int类型，另一个参数由用户指定，</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六章-模板&quot;&gt;&lt;a href=&quot;#第六章-模板&quot; class=&quot;headerlink&quot; title=&quot;第六章 模板&quot;&gt;&lt;/a&gt;第六章 模板&lt;/h1&gt;&lt;p&gt;模板是C++支持参数化多态的工具，是泛型编程的基础。&lt;/p&gt;
&lt;h2 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c8/"/>
    <id>http://example.com/2022/12/18/c8/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:30.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-I-O流"><a href="#第八章-I-O流" class="headerlink" title="第八章 I&#x2F;O流"></a>第八章 I&#x2F;O流</h1><p>输入&#x2F;输出（I&#x2F;O）用于完成数据传输。C++语言支持两种I&#x2F;O，一种是C语言中的I&#x2F;O函数，另一种是面向对象的I&#x2F;O流类库。</p><h2 id="I-O流类库"><a href="#I-O流类库" class="headerlink" title="I&#x2F;O流类库"></a>I&#x2F;O流类库</h2><h3 id="ios类库"><a href="#ios类库" class="headerlink" title="ios类库"></a>ios类库</h3><p>ios类库以ios类为基类，ios类是一个抽象类，提供了输入&#x2F;输出所需的公共接口，如设置数据流格式、错误状态恢复、设置文件的输入&#x2F;输出模式等</p><p>（1）ifstream类：文件输入流类，支持文件的读操作。<br>（2）istringstream类：字符串输入流类，支持字符串的输入操作。<br>（3）ofstream类：文件输出流类，支持文件的写操作。<br>（4）ostringstream类：字符串输出流类，支持字符串的输出操作。<br>（5）fstream类：文件输入&#x2F;输出流类，支持文件的读写操作。<br>（6）stringstream类：字符串输入&#x2F;输出流类，支持字符串的输入和输出操作。</p><h3 id="streambuf类库"><a href="#streambuf类库" class="headerlink" title="streambuf类库"></a>streambuf类库</h3><p>streambuf类库以streambuf类为基类，streambuf类是一个抽象类，提供了缓冲区操作接口，如设置缓冲区、从缓冲区提取字节、向缓冲区插入字节等。streambuf类库的层次结构如图8-2所示。由图8-2可知，streambuf类派生了3个类，分别是stdiobuf类、filebuf类、stringstreambuf类。其中，stdiobuf类用于标准I&#x2F;O缓冲区管理，filebuf类用于文件缓冲区管理，stringstreambuf类用于内存缓冲区管理。</p><h2 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h2><h3 id="预定义流对象"><a href="#预定义流对象" class="headerlink" title="预定义流对象"></a>预定义流对象</h3><p>C++提供了四个预定义流对象，包括cin、cout、cerr和clog。cin是istream类的对象，用于处理标准输入（键盘输入）。cout、cerr和clog是ostream类的对象，其中，cout用于处理标准输出（屏幕输出），cerr和clog用于处理标准错误信息。<br>clog有缓冲区，而cerr没有缓冲，意味着cerr输出的信息会直接发送给屏幕，不会等到缓冲区填满或遇到换行符才输出错误信息。</p><h3 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h3><h4 id="put-函数"><a href="#put-函数" class="headerlink" title="put()函数"></a>put()函数</h4><p>put()函数用于输出单个字符。put()函数将字符插入输出流对象，通过输出流对象将字符输出到指定位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">put</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><p>上述函数声明中，参数ch表示要输出的字符，函数返回值为ostream类对象引用。由于put()函数返回的是输出流对象，因此put()函数与输出运算符“&lt;&lt;”一样，可以连续调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);          <span class="comment">//输出字符&#x27;a&#x27;</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>);         <span class="comment">//输出换行符</span></span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;d&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;h&#x27;</span>); <span class="comment">//连续调用put()函数输出字符</span></span><br></pre></td></tr></table></figure><h4 id="write-函数"><a href="#write-函数" class="headerlink" title="write()函数"></a>write()函数</h4><p>write()函数用于输出一个字符串。write()函数将指定个数的字符串插入输出流对象，通过输出流对象将字符串输出到指定位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, streamsize count)</span></span>;</span><br><span class="line">cout.<span class="built_in">write</span>(<span class="string">&quot;I love China&quot;</span>, <span class="number">6</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(<span class="string">&quot;I love China&quot;</span>,<span class="number">6</span>).<span class="built_in">write</span>(<span class="string">&quot;I love China&quot;</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一行代码调用write()函数输出字符串“I love China”的前6个字符；第二行代码连续调用write()函数输出字符串“I love China”的前6个和前5个字符。</p><h3 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h3><p>istream类预定义了输入流对象cin，并且重载了“&gt;&gt;”运算符，输入流对象与“&gt;&gt;”运算符结合使用，可以输入各种类型的数据。此外，istream类还提供了成员函数用于输入数据，如get()函数、getline()函数、read()函数等，下面分别介绍这些函数。</p><h4 id="get-函数"><a href="#get-函数" class="headerlink" title="get()函数"></a>get()函数</h4><p>（1）第一种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>第一种重载形式的get()函数没有参数，返回值为int类型。get()函数的作用是从输入流读取一个字符，返回该字符的ASCII码值。<br>（2）第二种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="type">char</span>&amp; ch)</span></span>; </span><br></pre></td></tr></table></figure><p>第二种重载形式的get()函数有一个char类型的引用作为参数，返回值为istream类对象引用。get()函数的作用是从输入流读取一个字符存储到字符ch中。<br>（3）第三种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">get</span><span class="params">(<span class="type">char</span> *dst, streamsize count,<span class="type">char</span> delimiter)</span></span>;</span><br></pre></td></tr></table></figure><p>第三种重载形式的get()函数有三个参数，其中dst为char类型的指针，指向一块内存空间；count表示读取的字符个数；delim iter表示结束符，默认是’\0’。get()函数的作用是从输入流中读取count?1个字符（最后一个字符要留给’\0’），存储到dst指向的内存空间。在读取过程中，遇到结束符就结束读取，即使没有读取够count?1个字符，遇到结束符之后也会结束读取，结束符不包含在读取的字符串内。如果读取了count?1个字符也没有遇到结束符，则在结束读取时，系统自动在字符串末尾添加’\0’。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种形式：&quot;</span> &lt;&lt; cin.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二种形式：&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>(buf, <span class="number">6</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三种形式：&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getline-函数"><a href="#getline-函数" class="headerlink" title="getline()函数"></a>getline()函数</h4><p>getline()函数用于从输入流中读取字符，直到读取到指定长度的字符或遇到终止字符时结束读取。getline()有两种重载形式，具体如下。<br>（1）第一种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">getline</span><span class="params">(<span class="type">char</span> *dst, streamsize count)</span></span>;</span><br></pre></td></tr></table></figure><p>第一种重载形式的getline()函数有两个参数，第一个参数dst指向一块内存空间；第二个参数count表示读取的字符个数。getline()函数的作用是从输入流中读取count?1个字符存储到dst指向的内存空间。<br>（2）第二种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream &amp;<span class="title">getline</span><span class="params">(<span class="type">char</span> *dst, streamsize count, <span class="type">char</span> delimiter)</span></span>;</span><br></pre></td></tr></table></figure><p>第二种重载形式的getline()函数有三个参数，前两个参数与第一种形式的参数含义相同，第三个参数delim iter表示结束符。getline()函数的作用是从输入流中读取count?1个字符存储到dst指向的内存空间，遇到结束符就结束读取。<br>下面调用getline()函数读取一个字符串，示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf1[<span class="number">20</span>]，buf2[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(buf1, <span class="number">20</span>);</span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">20</span>,’d’); <span class="comment">//从输入流中读取19个字符，遇到字符&#x27;d&#x27;结束读取</span></span><br></pre></td></tr></table></figure><p>上述代码中，第一次调用getline()函数，表示从输入流中读取19个字符存储到buf1数组中。第二次调用getline()函数，表示从输入流中读取19个字符，在读取过程中，如果遇到字符’d’就结束读取。</p><h4 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h4><p>read()函数用于从输入流中读取指定字符个数的字符串，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span>* dst, streamsize count)</span></span>; </span><br></pre></td></tr></table></figure><p>上述函数声明中，read()函数的参数与getline()函数的参数含义相同，只是read()函数没有结束符，直到读取count?1个字符才会结束读取。read()函数在读取数据时，对读取到的字节序列不作任何处理。read()函数不会识别换行符、空格等特殊字符，遇到换行符’\n’也不会结束读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个字符串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">read</span>(buf, <span class="number">25</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出：&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在例8-2中，第7行代码调用read()函数读取24个字符存储到buf数组中。第8行代码输出buf数组中的数据。由图8-4可知，当换行输入两行字符串时，read()函数成功读取了两行字符串，并存储到buf数组中，在输出时成功输出了buf数组中的数据。在读取过程中，遇到换行符’\n’，read()函数并没有结束读取。</p><h4 id="多学一招：istream类的其他成员函数"><a href="#多学一招：istream类的其他成员函数" class="headerlink" title="多学一招：istream类的其他成员函数"></a>多学一招：istream类的其他成员函数</h4><h5 id="ignore-函数"><a href="#ignore-函数" class="headerlink" title="ignore()函数"></a>ignore()函数</h5><p>ignore()函数的作用是跳过输入流中的n个字符，函数声明如下所示：<br>istream&amp; ignore(streamsize count, int delimeter);<br>在上述函数声明中，参数count表示要跳过的字符个数，默认值是1；参数delimeter表示结束符，在跳跃过程中，如果遇到结束符就结束跳跃。ignore()函数不识别换行符、空格、制表符等特殊字符。ignore()函数用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">6</span>, <span class="string">&#x27;T&#x27;</span>);  <span class="comment">//跳过前面6个字符，遇到字符&#x27;T&#x27;终止跳跃</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buf, <span class="number">8</span>); <span class="comment">//跳跃结束，读取7个字符并存储到buf数组中</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl; <span class="comment">//输出buf数组中的数据</span></span><br></pre></td></tr></table></figure><h5 id="gcout-函数"><a href="#gcout-函数" class="headerlink" title="gcout()函数"></a>gcout()函数</h5><p>gcount()函数的作用是计算上一次读取到的字符个数，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streamsize <span class="title">gcount</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line"><span class="built_in">gcount</span>()函数的声明与用法很简单，其用法示例代码如下所示：</span><br><span class="line"><span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf, <span class="number">20</span>);     <span class="comment">//读取字符串并存储到buf数组中</span></span><br><span class="line"><span class="type">int</span> count = cin.<span class="built_in">gcount</span>(); <span class="comment">//统计上次读取的字符个数</span></span><br></pre></td></tr></table></figure><h4 id="peek-函数"><a href="#peek-函数" class="headerlink" title="peek()函数"></a>peek()函数</h4><p>peek()函数的作用是检测输入流中待读取的字符，函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在上述函数声明中，peek()函数没有参数，返回值为int类型，即返回检测字符的ASCII码值。peek()函数只是检测待读取的字符，但并不会真正读取它。peek()函数用法示例代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = cin.<span class="built_in">peek</span>(); <span class="comment">//检测字符</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">cin.<span class="built_in">get</span>(ch); <span class="comment">//读取字符</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>运行上述代码，两次输出的ch值是一样的，表明peek()函数并没有真正去读取检测到的字符。如果peek()函数读取了检测的字符，输入流自动向后移动一个位置（字符），则调用get()函数读取时会读取到输入流中下一个字符，两次输出的ch会不同。</p><h4 id="putback-函数"><a href="#putback-函数" class="headerlink" title="putback()函数"></a>putback()函数</h4><p>putback()函数的作用是将上一次读取的字符放回输入流中，使之可被下一次读取，函数声明如下所示：<br>istream&amp; putback(char ch);<br>在上述函数声明中，参数ch是上一次通过get()函数或getline()函数读取的字符。putback()函数是将字符ch重新放回输入流中。putback()函数用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch = cin.<span class="built_in">get</span>(); <span class="comment">//读取字符</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">cin.<span class="built_in">putback</span>(ch);           <span class="comment">//将字符重新放回输入流</span></span><br><span class="line">cout &lt;&lt; cin.<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">//再次读取</span></span><br></pre></td></tr></table></figure><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="文件流对象的创建"><a href="#文件流对象的创建" class="headerlink" title="文件流对象的创建"></a>文件流对象的创建</h3><p>在C++中，要进行文件的读写操作，首先必须建立一个文件流对象，然后把文件流对象与文件关联起来（打开文件）。文件流对象与文件关联之后，程序就可以调用文件流类的各种方法对文件进行操作了。<br>C++提供了三个类支持文件流的输入、输出，这三个类都包含在fstream头文件中。ifstream：输入文件流类，用于实现文件的输入。ofstream：输出文件流类，用于实现文件的输出。fstream：输入&#x2F;输出文件流类，可同时实现文件的输入和输出。<br>文件流不像标准I&#x2F;O流预定义了输入流对象和输出流对象，使用文件流时，需要创建文件流对象。创建文件流对象时，可以调用文件流类的无参构造函数，也可以调用文件流类的有参构造函数，具体如下所示。</p><ol><li>调用无参构造函数创建文件流对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs; <span class="comment">//定义一个文件输入流对象</span></span><br><span class="line">ofstream ofs; <span class="comment">//定义一个文件输出流对象</span></span><br><span class="line">fstream fs;   <span class="comment">//定义一个文件输入、输出流对象</span></span><br></pre></td></tr></table></figure></li><li>调用有参构造函数创建文件流对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;filename&quot;</span>, ios::in)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;filename&quot;</span>, ios::out)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;filename&quot;</span>,ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>ifstream类默认文件打开模式为ios::in，ofstream类默认文件打开模式为ios::out，fstream类默认文件打开模式为ios::in|ios::out。<br>文件的打开与关闭<br>文件最基本的操作就是打开和关闭，在对文件进行读写之前，需要先打开文件；读写结束之后，要及时关闭文件。下面将针对文件的打开与关闭进行讲解。</li></ol><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>C++提供了两种打开文件的方式：第一种方式是调用文件流类的构造函数；第二种方式是调用文件流类的成员函数open()。第一种调用文件流类的构造函数打开文件方式就是在创建文件流对象时传入文件名和文件打开模式，这种方式在8.3.1节已经讲解。下面主要讲解第二种调用open()函数打开文件的方式。ifstream类、ostream类和fstream类都提供了成员函数open()用于打开文件，open()函数声明如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> mode)</span></span>; </span><br></pre></td></tr></table></figure><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> <span class="comment">//包含fstream文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ifstream ifs;                   <span class="comment">//创建输入流对象</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;hello.txt&quot;</span>, ios::in); <span class="comment">//以只读方式打开hello.txt</span></span><br><span class="line">    <span class="keyword">if</span> (!ifs)                       <span class="comment">//判断文件打开是否成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本文件的读写"><a href="#文本文件的读写" class="headerlink" title="文本文件的读写"></a>文本文件的读写</h3><h4 id="使用提取运算符“-”和插入运算符“"><a href="#使用提取运算符“-”和插入运算符“" class="headerlink" title="使用提取运算符“&gt;&gt;”和插入运算符“&lt;&lt;”读写文件"></a>使用提取运算符“&gt;&gt;”和插入运算符“&lt;&lt;”读写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建文件流对象，并以只写模式打开hello.txt文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;hello.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ofs) <span class="comment">//判断文件打开是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;写文件时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入要写入文件的数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义数组str</span></span><br><span class="line">    cin &gt;&gt; str;           <span class="comment">//从键盘输入数据并存储到str数组</span></span><br><span class="line">    ofs &lt;&lt; str;           <span class="comment">//将str数组中数据写入文件</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="comment">//创建文件流对象，并以只读模式打开hello.txt文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;hello.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ifs) <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;读文件时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//定义数组buf</span></span><br><span class="line">    ifs &gt;&gt; buf;           <span class="comment">//将文件内容读入buf</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件读取成功，内容如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl; <span class="comment">//输出buf数组中的数据</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();         <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用文件流类的成员函数读写文件"><a href="#调用文件流类的成员函数读写文件" class="headerlink" title="调用文件流类的成员函数读写文件"></a>调用文件流类的成员函数读写文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建文件流对象，并以只写模式打开hello.txt文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;hello.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ofs) <span class="comment">//判断文件打开是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;写文件时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将26个字母写入文件&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ofs.<span class="built_in">put</span>(ch1 + i); <span class="comment">//调用put()函数将字母写入文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="comment">//创建文件流对象，并以只读模式打开hello.txt文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;hello.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ifs) <span class="comment">//判断文件是否打开成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;读文件时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件读取成功，内容如下：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> ch2;</span><br><span class="line">    ifs.<span class="built_in">get</span>(ch2);      <span class="comment">//调用get()函数将字母读取到ch2变量中</span></span><br><span class="line">    <span class="keyword">while</span> (!ifs.<span class="built_in">eof</span>()) <span class="comment">//循环读取剩余字母</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch2; <span class="comment">//输出ch2的值</span></span><br><span class="line">        ifs.<span class="built_in">get</span>(ch2);</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多学一招：文件流类的其他成员函数"><a href="#多学一招：文件流类的其他成员函数" class="headerlink" title="多学一招：文件流类的其他成员函数"></a>多学一招：文件流类的其他成员函数</h4><p>除了读写函数，文件流类还提供了其他成员函数，如eof()、bad()等，这些函数一般用于处理文件读写过程中的错误。下面介绍几种常用的错误处理函数。</p><h5 id="eof-函数"><a href="#eof-函数" class="headerlink" title="eof()函数"></a>eof()函数</h5><p>eof()函数用于检测文件是否到达末尾，函数声明如下所示：<br>bool eof() const;<br>在读文件时，如果文件到达末尾，eof()函数会返回true。例8-5中的第31行代码就调用了eof()函数判断文件读取是否到达末尾，这里不再针对其用法举例。</p><h5 id="bad-函数"><a href="#bad-函数" class="headerlink" title="bad()函数"></a>bad()函数</h5><p>bad()函数用于检测文件在读写过程中是否出错，函数声明如下所示：<br>bool bad() const;<br>如果文件读写出错，bad()函数会返回true。例如，对一个打开模式为ios::in的文件进行写入操作，或者写入的设备没有足够空间，调用bad()函数会返回true。bad()函数的用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//创建fstream类对象，以只读模式打开a.txt</span></span><br><span class="line">fs.<span class="built_in">put</span>(<span class="string">&#x27;a&#x27;</span>);                  <span class="comment">//向文件中写入字符&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="built_in">bad</span>())                 <span class="comment">//调用bad()函数检测，写入过程是否出错</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件写入失败&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h5 id="fail-函数"><a href="#fail-函数" class="headerlink" title="fail()函数"></a>fail()函数</h5><p>fail()函数也用于检测在读写过程中是否出错，函数声明如下所示：<br>bool fail() const;<br>fail()函数比bad()函数的检错范围更广泛。文件到达末尾，或者读写过程没有达到预期条件，例如，想要读取一个整数却获得了一个字母时，fail()函数都能检测到并返回true。fail()函数的用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//创建fstream类对象，以只读模式打开a.txt</span></span><br><span class="line">cout &lt;&lt; fs.<span class="built_in">get</span>() &lt;&lt; endl;     <span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="built_in">fail</span>())                <span class="comment">//如果文件不存在或到达末尾，则读取失败</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h5 id="good-函数"><a href="#good-函数" class="headerlink" title="good()函数"></a>good()函数</h5><p>good()函数用于检测文件流状态和文件读写过程是否正常，函数声明如下所示：<br>bool good() const;<br>如果文件流状态、文件读写过程没有错误，good函数就返回true。它的作用与bad()函数、fail()函数相反，对于bad()函数、fail()函数返回<br>true的情况，good()函数会返回false。good()函数的用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>, ios::in)</span></span>; <span class="comment">//创建fstream类对象，以只读模式打开a.txt</span></span><br><span class="line">cout &lt;&lt; fs.<span class="built_in">get</span>() &lt;&lt; endl;     <span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">if</span> (fs.<span class="built_in">good</span>())                <span class="comment">//如果没有错误，good()函数返回true</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件读取成功&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h5 id="clear-函数"><a href="#clear-函数" class="headerlink" title="clear()函数"></a>clear()函数</h5><p>clear()函数用于清除文件流的错误状态，即重置文件流的状态标志位，函数声明如下所示：<br>void clear(iostate state &#x3D; goodbit);<br>在上述函数声明中，参数state表示流的状态，默认值为goodbit（值为0）。在文件读写过程中，调用close()关闭文件之后，如果再使用文件流对象打开其他文件，一般先调用clear()函数将文件流对象的标志位重新初始化。clear()函数的用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;file1&quot;</span>); <span class="comment">//打开file1文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();       <span class="comment">//关闭file1文件</span></span><br><span class="line">ofs.<span class="built_in">clear</span>();       <span class="comment">//调用clear()函数重置文件流的状态标志位</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;file2&quot;</span>); <span class="comment">//关闭file1文件后，再打开file2文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h4 id="二进制文件的读写"><a href="#二进制文件的读写" class="headerlink" title="二进制文件的读写"></a>二进制文件的读写</h4><p>文件流类从istream类和ostream类分别继承了write()函数和read()函数，这两个函数可以用来读写二进制文件。write()函数与read()函数的声明与用法在8.2.2节和8.2.3节已经讲解，这里不再赘述。下面通过案例演示二进制文件的读写，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> <span class="comment">//定义学生结构体Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> age;       <span class="comment">//年龄</span></span><br><span class="line">    <span class="type">char</span> sex;      <span class="comment">//性别</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stus[<span class="number">3</span>]; <span class="comment">//定义学生结构体数组，大小为3</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入3个学生的信息:\n（姓名 年龄 性别）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">//通过for循环从键盘输入学生信息</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; stus[i].name &gt;&gt; stus[i].age &gt;&gt; stus[i].sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建输出文件流对象，以二进制、写入模式打开student.dat二进制文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;student.dat&quot;</span>, ios::out | ios_base::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ofs)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;写入时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过for循环将3个学生的信息写入文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用write()函数写入数据，每次写入一个学生信息</span></span><br><span class="line">        ofs.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;stus[i]), <span class="built_in">sizeof</span>(stus[i]));</span><br><span class="line">        ofs.<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ofs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;写入成功&quot;</span> &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;读取文件:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建输入文件流对象，以只读和二进制模式打开student.txt文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;student.dat&quot;</span>, ios::in | ios_base::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ifs)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;读取时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Student stus1[<span class="number">3</span>]; <span class="comment">//定义学生结构体数组存储读取的文件内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用read()函数读取数据，每次读取一个学生信息</span></span><br><span class="line">        ifs.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;stus1[i]), <span class="built_in">sizeof</span>(stus1[i]));</span><br><span class="line">        cout &lt;&lt; stus1[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stus1[i].age</span><br><span class="line">             &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; stus1[i].sex &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件随机读写"><a href="#文件随机读写" class="headerlink" title="文件随机读写"></a>文件随机读写</h4><p>在C语言中实现文件的随机读写要依靠文件位置指针，在C++中文件的随机读写也是通过移动文件位置指针完成的。C++文件流类提供了设置文件位置指针的函数。ifstream类提供了tellg()函数、seekg()函数，这两种函数声明分别如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streampos <span class="title">tellg</span><span class="params">()</span></span>;   </span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">(streampos)</span></span>;   </span><br><span class="line"><span class="function">istream&amp; <span class="title">seekg</span><span class="params">(streamoff, ios::seek_dir)</span></span></span><br></pre></td></tr></table></figure><p>在上述函数声明中，tellg()函数用于返回文件位置指针的位置。seekg()函数用于设置文件位置指针的位置，即移动文件位置指针，它有两种重载形式。第一种重载形式有一个参数stream pos，表示文件位置指针从文件开头移动stream pos长度的距离；第二种重载形式有两个参数，第一个参数stream off表示文件位置指针的移动距离，第二个参数ios::seek_dir表示参照位置。ios::seek_dir有以下三个取值。<br>ios::beg&#x3D;0,表示从文件开头开始移动文件位置指针。ios::cur&#x3D;1,表示从当前位置开始移动文件位置指针。ios::end&#x3D;2,表示从文件结尾开始移动文件位置指针。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>streampos和streamoff是C++标准库重定义的数据类型。tellg()函数与seekg()函数的用法示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>;    <span class="comment">//创建输入文件流对象ifs</span></span><br><span class="line">ifs.<span class="built_in">tellg</span>();              <span class="comment">//调用tellg()函数获取文件位置指针</span></span><br><span class="line">ifs.<span class="built_in">seekg</span>(<span class="number">20</span>);            <span class="comment">//将文件位置指针移动20个字节</span></span><br><span class="line">ifs.<span class="built_in">seekg</span>(<span class="number">-20</span>, ios::end); <span class="comment">//将文件位置指针从文件末尾处向前移动20个字节</span></span><br></pre></td></tr></table></figure><p>ofstream类提供了tellp()函数、seekp()函数用于移动文件位置指针，这两种函数声明分别如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streampos <span class="title">tellp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">seekp</span><span class="params">(streampos)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">seekp</span><span class="params">(streamoff, ios::seek_dir</span></span></span><br></pre></td></tr></table></figure><p>tellp()函数与tellg()函数的含义与用法相同，seekp()函数与seekg()函数的含义与用法相同。fstream类拥有上述所有函数，即拥有tellg()函数、seekg()函数、tellp()函数和seekp()函数。为了加深读者对这两组函数的理解，下面通过案例演示文件的随机读写，如例8-7所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建输出文件流对象ofs</span></span><br><span class="line">    <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;random.dat&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!ofs)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;写入文件时，文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出文件位置指针的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件打开时，文件位置指针位置：&quot;</span> &lt;&lt; ofs.<span class="built_in">tellp</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;        <span class="comment">//定义字符数组buf</span></span><br><span class="line">    cin.<span class="built_in">getline</span>(buf, <span class="number">1024</span>, <span class="string">&#x27;/&#x27;</span>); <span class="comment">//将从键盘输入的数据存储到buf中</span></span><br><span class="line">    ofs.<span class="built_in">write</span>(buf, <span class="number">30</span>);          <span class="comment">//调用write()函数将buf中的数据写入文件</span></span><br><span class="line">    <span class="comment">//写入完成之后，输出文件位置指针的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;写入完成后，文件位置指针位置：&quot;</span> &lt;&lt; ofs.<span class="built_in">tellp</span>() &lt;&lt; endl;</span><br><span class="line">    ofs.<span class="built_in">seekp</span>(<span class="number">-10</span>, ios::end); <span class="comment">//移动文件位置指针</span></span><br><span class="line">    <span class="comment">//移动之后，输出文件位置指针的位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;移动之后，文件位置指针位置：&quot;</span> &lt;&lt; ofs.<span class="built_in">tellp</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><p>字符串流是以string对象为输入&#x2F;输出对象的数据流，这些数据流的传输在内存中完成，因此字符串流也称为内存流。C++提供了istringstream、ostringstream和stringstream这三个类支持string对象的输入&#x2F;输出。这三个类都由istream类和ostream类派生而来，因此它们都可以使用“&gt;&gt;”运算符和“&lt;&lt;”运算符，以及istream类和ostream类的成员函数。下面简单介绍这三个类。</p><h3 id="istringstream类"><a href="#istringstream类" class="headerlink" title="istringstream类"></a>istringstream类</h3><p>istringstream是输入字符串流类，用于实现字符串对象的输入。istringstream类的构造函数有三个，具体如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">istringstream</span>(openmode = ios_base::in);</span><br><span class="line"><span class="built_in">istringstream</span>(<span class="type">const</span> string &amp;str, openmode = ios_base::in);</span><br><span class="line"><span class="built_in">istringstream</span>(istringstream &amp;&amp;x)</span><br></pre></td></tr></table></figure><p>第一个构造函数带有一个默认参数openm ode，表示流的打开方式，默认值为ios_base::in。第二个构造函数带有两个参数：第一个参数str为string对象的常引用；第二个参数openm ode是流的打开模式，默认值为ios_base::in。第三个构造函数为移动构造函数。istringstream类的一个典型用法就是将一个数字字符串转换成对应的数值。相比于C语言的数字和字符串转换函数，istringstream类具有模板亲和性，转换效率更高而且更安全。下面通过案例演示如何将数字字符串转换成对应的数值，如例8-8所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义模板函数：将一个数字字符串转换成对应的数值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">swapString</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">istr</span><span class="params">(str)</span></span>; <span class="comment">//创建istringstream类对象istr</span></span><br><span class="line">    T t;                     <span class="comment">//定义变量t</span></span><br><span class="line">    istr &gt;&gt; t;               <span class="comment">//将对象istr中的数据输入t中</span></span><br><span class="line">    <span class="keyword">return</span> t;                <span class="comment">//返回t</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">swapString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;10&quot;</span>); <span class="comment">//将字符串&quot;10&quot;转换成数值10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num=&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">swapString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;3.14&quot;</span>); <span class="comment">//将字符串&quot;3.14&quot;转换成数值3.14</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d=&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="type">float</span> f = <span class="built_in">swapString</span>&lt;<span class="type">float</span>&gt;(<span class="string">&quot;abc&quot;</span>); <span class="comment">//将字符串&quot;abc&quot;转换成float类型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;f=&quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ostringstream类"><a href="#ostringstream类" class="headerlink" title="ostringstream类"></a>ostringstream类</h3><p>ostringstream是输出字符串流类，用于实现字符串对象的输出。ostringstream类也提供了三个构造函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span>(openmode = ios_base::out);</span><br><span class="line"><span class="built_in">ostringstream</span>(<span class="type">const</span> string &amp;str, openmode = ios_base::out);</span><br><span class="line"><span class="built_in">ostringstream</span>(ostringstream &amp;&amp;x)</span><br></pre></td></tr></table></figure><p>ostringstream类构造函数的参数含义与istringstream类构造函数的参数含义相同。除了构造函数，ostringstream类还提供了一个比较常用的成员函数str()。str()函数用于获取ostringstream流缓冲区中的内容副本，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>str()函数获取ostringstream流缓冲区的数据后，并不对数据进行修改，获取的数据可以存储到一个string对象中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ostringstream ostr; <span class="comment">//创建ostringstream类对象ostr</span></span><br><span class="line">    string str;         <span class="comment">//创建string类对象str</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个字符串&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);          <span class="comment">//调用getline()函数从键盘为str输入内容</span></span><br><span class="line">    ostr &lt;&lt; str;                <span class="comment">//将str内容插入到ostr类对象中</span></span><br><span class="line">    string result = ostr.<span class="built_in">str</span>(); <span class="comment">//调用str()成员函数获取ostr对象缓冲区内容</span></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;     <span class="comment">//输出获取的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stringstream类"><a href="#stringstream类" class="headerlink" title="stringstream类"></a>stringstream类</h3><p>stringstream类是输入&#x2F;输出字符串流类，可同时实现字符串对象的输入&#x2F;输出。stringstream类也提供了三种形式的构造函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span>(openmode = ios_base::in | ios_base::out);</span><br><span class="line"><span class="built_in">stringstream</span>(<span class="type">const</span> string &amp;str, openmode = ios_base::in | ios_base::out);</span><br><span class="line"><span class="built_in">stringstream</span>(stringstream &amp;&amp;x)</span><br></pre></td></tr></table></figure><p>stringstream类构造函数的参数含义与istringstream类构造函数的参数含义相同。stringstream类包括了istringstream类与ostringstream类的功能，这里不再举例演示。<br>小提示：字符串流类<br>在C++98标准之前，C++使用istrstream、ostrstream和strstream三个类完成string对象的输入&#x2F;输出，但从C++98标准开始，这三个类被弃用了，取而代之的是istringstream类、ostringstream类和stringstream类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第八章-I-O流&quot;&gt;&lt;a href=&quot;#第八章-I-O流&quot; class=&quot;headerlink&quot; title=&quot;第八章 I&amp;#x2F;O流&quot;&gt;&lt;/a&gt;第八章 I&amp;#x2F;O流&lt;/h1&gt;&lt;p&gt;输入&amp;#x2F;输出（I&amp;#x2F;O）用于完成数据传输。C++语言支持</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/12/18/c9/"/>
    <id>http://example.com/2022/12/18/c9/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-21T10:14:37.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h2 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h2><p>在C++中，如果函数在调用时发生异常，异常通常会被传递给函数的调用者进行处理，而不在发生异常的函数内部处理。如果函数调用者也不能处理异常，则异常会继续向上一层调用者传递，直到异常被处理为止。如果最终异常没有被处理，则C++运行系统就会捕捉异常，终止程序运行。C++的异常处理机制使得异常的引发和处理不必在同一函数中完成，函数的调用者可以在适当的位置对函数抛出的异常进行处理。这样，底层的函数可以着重解决具体的业务问题，而不必考虑对异常的处理。C++的异常处理通过throw关键字和try…catch语句结构实现。通常情况下，被调用的函数如果发生异常，就通过throw关键字抛出异常，而函数的上层调用者通过try…catch语句检测、捕获异常，并对异常进行处理。throw关键字抛出异常的语法格式如下所示：throw关键字抛出异常的语法格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式; </span><br></pre></td></tr></table></figure><p>在上述格式中，throw后面的表达式可以是常量、变量或对象。如果函数调用中出现异常，就可以通过throw将表示异常的表达式抛给它的调用者。函数调用者通过try…catch语句捕获、处理异常，try…catch语句的语法格式如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//可能会出现异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (异常类型<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (异常类型<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line">… <span class="built_in">catch</span> (异常类型n)</span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    … <span class="comment">//异常处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述语法格式中，try语句块用于检测可能发生异常的代码（函数调用），如果这段代码抛出了异常，则catch语句会依次对抛出的异常进行类型匹配，如果某个catch语句中的异常类型与抛出的异常类型相同，则该catch语句就捕获异常并对异常进行处理。在使用try…catch语句时，有以下几点需要注意。（1）一个try…catch语句中只能有一个try语句块，但可以有多个catch语句块，以便与不同的异常类型匹配。catch语句必须有参数，如果try语句块中的代码抛出了异常，无论抛出的异常的值是什么，只要异常的类型与catch语句的参数类型匹配，异常就会被catch语句捕获。最后一个catch语句参数为“…”符号，表示可以捕获任意类型的异常。（2）一旦某个catch语句捕获到了异常，后面的catch语句将不再被执行，其用法类似switch…case语句。（3）try和catch语句块中的代码必须使用大括号“{}”括起来，即使语句块中只有一行代码。（4）try语句和catch语句不能单独使用，必须连起来一起使用。<br>在使用try…catch语句处理异常时，如果try语句块中的某一行代码抛出了异常，则无论异常是否被处理，抛出异常的语句后面的代码都不再被执行。例如，有如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">    cout &lt;&lt; <span class="number">3</span> / <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;异常处理&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;异常处理完毕，程序从此处开始向下执行&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果try语句块中的func()函数调用抛出了异常，并且catch语句成功捕获到了异常，则异常处理结束之后，程序会执行try…catch语句后面的代码，而不会执行try语句块中的add()函数。下面通过案例演示C++的异常处理，如例9-1所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractException</span> <span class="comment">//定义抽象异常类AbstractException</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printErr</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数printErr()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义文件异常类FileException公有继承AbstractException</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileException</span> : <span class="keyword">public</span> AbstractException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printErr</span><span class="params">()</span> <span class="comment">//实现printErr()函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：文件不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义整除异常类DivideException公有继承AbstractException</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivideException</span> : <span class="keyword">public</span> AbstractException</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printErr</span><span class="params">()</span> <span class="comment">//实现printErr()函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;错误：除零异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="comment">//定义readFile()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;log.txt&quot;</span>)</span></span>; <span class="comment">//创建文件输入流对象ifs并打开log.txt文件</span></span><br><span class="line">    <span class="keyword">if</span> (!ifs)                <span class="comment">//如果文件打开失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">FileException</span>(); <span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">()</span> <span class="comment">//定义divide()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (num2 == <span class="number">0</span>) <span class="comment">//如果除数num2为0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivideException</span>(); <span class="comment">//抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret = num1 / num2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;两个数相除结果：&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">readFile</span>(); <span class="comment">//检测readFile()函数调用</span></span><br><span class="line">        <span class="built_in">divide</span>();   <span class="comment">//检测divide()函数调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (FileException &amp;fex) <span class="comment">//捕获FileException&amp;类型异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        fex.<span class="built_in">printErr</span>(); <span class="comment">//调用相应函数输出异常信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (DivideException &amp;dex) <span class="comment">//捕获DivideException&amp;类型异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        dex.<span class="built_in">printErr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) <span class="comment">//捕获任意类型异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;处理其他异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;程序执行结束&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> <span class="comment">//定义形状类Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>();          <span class="comment">//构造函数</span></span><br><span class="line">    ~<span class="built_in">Shape</span>();         <span class="comment">//析构函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">//静态成员变量count</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Shape::count = <span class="number">0</span>; <span class="comment">// count初始值为0</span></span><br><span class="line">Shape::<span class="built_in">Shape</span>()        <span class="comment">//实现构造函数</span></span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (Shape::count == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;纸张画不下啦！！&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shape构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Shape::~<span class="built_in">Shape</span>() <span class="comment">//实现析构函数</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Shape析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape circle; <span class="comment">//画圆形</span></span><br><span class="line">    <span class="keyword">try</span>           <span class="comment">// try语句块检测可能抛出异常的代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">2</span>; <span class="comment">//定义int类型变量num,表示纸张可画两个图形</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;纸张可画图形个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        Shape rectangle; <span class="comment">//画长方形</span></span><br><span class="line">        Shape triangle;  <span class="comment">//画三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> *e) <span class="comment">//捕获异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，栈解旋只能析构栈上的对象，不会析构动态对象。</p><h3 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h3><p>C++提供了一组标准异常类，这些类以exception为根基类，程序中抛出的所有标准异常都继承自exception类。exception类定义在exception头文件中，C++11标准对exception类的定义如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">exception</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">exception</span>() <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">exception</span>(<span class="type">const</span> exception &amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">    exception &amp;<span class="keyword">operator</span>=(<span class="type">const</span> exception &amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">exception</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//定义动物类Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明虚函数speak()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Animal::speak</span><span class="params">()</span> <span class="comment">//类外实现speak()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物叫声&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal <span class="comment">//猫类Cat公有继承Animal类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>; <span class="comment">//声明虚函数speak()</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::speak</span><span class="params">()</span> <span class="comment">//类外实现speak()函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫喵喵叫&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal animal;        <span class="comment">//创建Animal类对象animal</span></span><br><span class="line">    Animal &amp;ref = animal; <span class="comment">//定义Animal类引用ref</span></span><br><span class="line">    ref.<span class="built_in">speak</span>();          <span class="comment">//通过Animal的引用ref调用speak()函数</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将引用ref强制转换为Cat&amp;类型</span></span><br><span class="line">        Cat &amp;cat = <span class="built_in">dynamic_cast</span>&lt;Cat &amp;&gt;(ref);</span><br><span class="line">        cat.<span class="built_in">speak</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_cast &amp;ex) <span class="comment">//捕获异常，bad_cast标准异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小提示：noexcept关键字在exception类定义中，noexcept关键字表示函数不抛出异常。noexcept关键字是C++11新增的关键字，在C++11之前，如果一个函数不抛出异常，则在函数后面添加throw()函数，示例代码如下所示：<br>void func() throw();<br>相比于throw()，noexcept关键字有利于编译器优化代码，但它并不适用于任何地方。在指定函数是否抛出异常时，如果读者对noexcept关键字不是很熟悉，尽量使用throw()，而不要轻易使用noexcept关键字。</p><h4 id="静态断言"><a href="#静态断言" class="headerlink" title="静态断言"></a>静态断言</h4><p>断言是编程中常用的一种调试手段。在C++11之前，C++使用assert()宏进行断言。但是，assert()宏只能在程序运行时期执行，这意味着不运行程序将无法检测到断言错误。如果每次断言都要执行一遍程序，则检测效率就会降低。另外，对于C++中使用较多的模板来说，模板实例化是在编译阶段完成的，assert()断言不能在编译阶段完成对模板实例化的检测。为此，C++11引入了静态断言static_assert，用于实现编译时断言。静态断言的语法格式如下所示：<br>static_assert(常量表达式， 提示字符串);<br>在上述语法格式中，static_assert有两个参数：第一个参数是一个常量表达式，即断言表达式；第二个参数是一个字符串。在执行断言时，编译器首先检测“常量表达式”的值，若常量表达式的值为真，则static_assert()不做任何操作，程序继续完成编译；若常量表达式的值为假，则static_assert()产生一条编译错误提示，错误提示的内容就是第二个参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;   </span></span><br><span class="line"><span class="function"> <span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; t, U&amp; u)</span>       <span class="comment">//定义函数模板func() </span></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">       <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(t) == <span class="built_in">sizeof</span>(u),    <span class="comment">//静态断言 </span></span><br><span class="line">            <span class="string">&quot;the parameters must be the same width.&quot;</span>); </span><br><span class="line">       cout &lt;&lt; t &lt;&lt; <span class="string">&quot;与 &lt;&lt; u &lt;&lt; &quot;</span>字节大小相同<span class="string">&quot; &lt;&lt; endl; </span></span><br><span class="line"><span class="string">  &#125; </span></span><br><span class="line"><span class="string"> int main() </span></span><br><span class="line"><span class="string"> &#123; </span></span><br><span class="line"><span class="string">      int x = 100;        //定义变量 </span></span><br><span class="line"><span class="string">    int y = 20;        //定义变量 </span></span><br><span class="line"><span class="string">    char ch = &#x27;a&#x27;;        //定义变量 </span></span><br><span class="line"><span class="string">    func(x, y);        //调用func()函数 </span></span><br><span class="line"><span class="string">    func(x, ch);        //调用func()函数 </span></span><br><span class="line"><span class="string">      return 0; </span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，static_assert()断言表达式的结果必须在编译阶段就可以计算出来，即必须是常量表达式。如果使用了变量，则会导致编译错误，示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(n &gt; <span class="number">0</span>, <span class="string">&quot;The age should be greater than zero!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，在static_assert()中使用了参数变量n，编译时报错“表达式的计算结果不是常数”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-异常&quot;&gt;&lt;a href=&quot;#第九章-异常&quot; class=&quot;headerlink&quot; title=&quot;第九章 异常&quot;&gt;&lt;/a&gt;第九章 异常&lt;/h1&gt;&lt;h2 id=&quot;异常处理方式&quot;&gt;&lt;a href=&quot;#异常处理方式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
</feed>
